{
  "projectName": "docsrs-mcp",
  "lastUpdated": "2025-08-05",
  "research": {
    "modelContextProtocol": {
      "overview": "Open standard by Anthropic for LLM-tool communication",
      "version": "2025-06-18 specification",
      "pythonSupport": {
        "officialSDK": "Available via MCP Python SDK",
        "fastAPIIntegration": {
          "library": "FastMCP",
          "method": "FastMCP.from_fastapi()",
          "features": "Automatic REST to MCP conversion"
        }
      },
      "bestPractices": [
        "Use descriptive operation_ids",
        "Provide comprehensive docstrings",
        "Implement proper error handling",
        "Follow MCP manifest structure"
      ]
    },
    "vectorSearch": {
      "sqliteVss": {
        "status": "DEPRECATED - DO NOT USE",
        "backend": "FAISS",
        "limitations": [
          "1GB index size limit",
          "No GPU support",
          "CPU-only operations",
          "No longer maintained",
          "Incompatible with modern SQLite versions"
        ],
        "replacement": "sqlite-vec (REQUIRED for new projects)"
      },
      "sqliteVec": {
        "status": "Current standard for SQLite vector search",
        "version": "0.1.6",
        "backend": "Native SQLite extension",
        "features": [
          "Production-ready vector search",
          "MATCH operator for vector queries",
          "KNN search with k constraint",
          "Better performance than sqlite-vss",
          "Active maintenance and development"
        ],
        "syntax": {
          "searchOperator": "MATCH (not vec_distance)",
          "knnConstraint": "Requires 'k = ?' parameter for KNN queries",
          "example": "SELECT * FROM embeddings WHERE vec MATCH ? AND k = 10"
        },
        "installation": "pip install sqlite-vec"
      },
      "embedding": {
        "library": "FastEmbed",
        "version": "<0.7.0",
        "versionConstraint": "Required for onnxruntime compatibility",
        "model": "BAAI/bge-small-en-v1.5",
        "dimensions": 384,
        "optimization": "ONNX for CPU inference",
        "performance": "2-4x faster than PyTorch",
        "modelDownload": "Automatic on first use - no manual download needed",
        "onnxruntimeCompatibility": {
          "issue": "FastEmbed newer versions incompatible with onnxruntime >=1.20",
          "solution": "Pin onnxruntime <1.20 OR use FastEmbed <0.7.0",
          "recommendation": "Use FastEmbed <0.7.0 for better stability"
        },
        "requirements": [
          "libgomp1",
          "libatlas-base-dev",
          "liblapack-dev"
        ]
      },
      "implementation": {
        "batchSize": 32,
        "insertBatchSize": 1000,
        "indexCommand": "CREATE INDEX (for sqlite-vec)",
        "searchMethod": "k-NN cosine similarity with MATCH operator",
        "asyncDatabase": {
          "library": "aiosqlite",
          "purpose": "Async SQLite operations for better performance",
          "installation": "pip install aiosqlite"
        }
      }
    },
    "docsRsIntegration": {
      "rustdocJson": {
        "availability": "Started 2025-05-23",
        "formats": [".json", ".json.zst", ".json.gz"],
        "urlPattern": "https://docs.rs/{crate}/{version}/{crate_name}.json[.zst|.gz]",
        "compressionPreference": ".zst (zstandard) - better compression than gzip",
        "fileSizes": {
          "compressed": "Varies significantly by crate",
          "uncompressed": "Can exceed 100MB for large crates",
          "efficiency": "Zstandard compression preferred for size reduction"
        },
        "parsingLibrary": "rustdoc-types crate",
        "parsingComplexity": {
          "status": "Complex nested JSON structure",
          "mvpApproach": "Use only crate descriptions for initial implementation",
          "fullParsing": "Requires significant effort for complete documentation extraction",
          "recommendation": "Start simple, expand incrementally based on user needs"
        },
        "memoryConsiderations": {
          "issue": "Large JSON files can cause memory spikes",
          "solution": "Use streaming decompression and parsing",
          "library": "ijson for memory-efficient streaming JSON parsing",
          "bestPractice": "Avoid loading entire JSON into memory at once"
        }
      },
      "apiEndpoints": {
        "latestVersion": "/crate/{crate}/latest/json",
        "specificVersion": "/crate/{crate}/{version}/json",
        "versionList": "/crate/{crate}/versions.json"
      },
      "limitations": [
        "Not all crates have rustdoc JSON",
        "Older crates may lack JSON docs",
        "Format varies by rustdoc version"
      ],
      "ingestionBestPractices": {
        "concurrency": {
          "approach": "Per-crate locking to prevent duplicate ingestion",
          "mechanism": "File-based or database-based locks",
          "rationale": "Avoid race conditions when multiple processes ingest same crate"
        },
        "sizeManagement": {
          "downloadLimits": "Set reasonable size limits for HTTP downloads",
          "decompressionLimits": "Limit decompressed size to prevent memory exhaustion",
          "monitoring": "Track file sizes and memory usage during processing"
        },
        "cacheEviction": {
          "strategy": "LRU eviction based on file modification time",
          "rationale": "Keep recently accessed crates while freeing space for new ones",
          "implementation": "Use filesystem timestamps for eviction decisions"
        },
        "errorHandling": {
          "retryMechanism": "Use tenacity library for robust HTTP request retries",
          "backoffStrategy": "Exponential backoff with jitter",
          "maxRetries": "Configure reasonable retry limits to avoid infinite loops"
        }
      }
    },
    "serverInfrastructure": {
      "fastAPI": {
        "version": ">=0.111",
        "features": [
          "Async support",
          "Pydantic validation",
          "OpenAPI generation",
          "Middleware support"
        ]
      },
      "uvicorn": {
        "version": ">=0.30",
        "eventLoop": "uvloop",
        "httpParser": "httptools",
        "workerFormula": "(2 Ã— CPU cores + 1)",
        "performanceGain": "2-4x over standard"
      },
      "httpClient": {
        "library": "aiohttp",
        "version": "3.9.5",
        "versionConstraint": "CRITICAL: Pin to 3.9.5 - versions 3.10+ have severe memory leaks",
        "memoryLeakIssue": {
          "affectedVersions": "3.10.0 and higher",
          "severity": "Severe memory leaks in production",
          "solution": "Pin to aiohttp==3.9.5 until issue resolved",
          "tracking": "Monitor aiohttp releases for fix"
        },
        "bestPractices": [
          "Single ClientSession per app",
          "Connection pooling",
          "Proper cleanup on shutdown",
          "Monitor memory usage in production"
        ]
      },
      "rateLimiting": {
        "library": "slowapi",
        "version": ">=0.1",
        "backend": "Redis for distributed",
        "limit": "30 requests/second per IP"
      },
      "compression": {
        "library": "zstandard",
        "version": ">=0.22",
        "method": "ZstdDecompressor().copy_stream()",
        "features": "Streaming decompression",
        "advantages": "Better compression ratio than gzip for rustdoc JSON files"
      },
      "jsonParsing": {
        "library": "ijson",
        "version": ">=3.2.0",
        "purpose": "Memory-efficient streaming JSON parsing",
        "use_case": "Parse large rustdoc JSON files without loading entire file into memory",
        "method": "ijson.parse() for streaming, ijson.items() for extracting objects",
        "benefits": [
          "Constant memory usage regardless of file size",
          "Ability to process 100MB+ JSON files efficiently",
          "Compatible with compressed streams"
        ]
      },
      "retryLogic": {
        "library": "tenacity",
        "version": ">=8.0.0",
        "purpose": "Robust retry mechanisms for HTTP requests",
        "features": [
          "Exponential backoff with jitter",
          "Configurable retry conditions",
          "Maximum retry limits",
          "Integration with async/await"
        ],
        "use_case": "Handle network failures when downloading rustdoc JSON files"
      }
    },
    "deployment": {
      "zeroInstall": {
        "tool": "uvx",
        "command": "uvx docsrs-mcp@latest",
        "gitSupport": "uvx --from git+https://..."
      },
      "containerization": {
        "baseImage": "python:slim",
        "minMemory": "256 MiB",
        "recommendedMemory": "1 GiB"
      },
      "platforms": [
        "Fly.io",
        "Railway",
        "Render",
        "Generic VPS"
      ]
    },
    "pythonTooling": {
      "uv": {
        "version": ">=0.4.0",
        "description": "Exclusive Python infrastructure tool for this project",
        "capabilities": [
          "Package management (replaces pip)",
          "Virtual environment management (replaces venv)",
          "Project execution (uvx for zero-install)",
          "Dependency resolution and locking",
          "Build system integration"
        ],
        "commands": {
          "development": [
            "uv sync --dev (install all dependencies)",
            "uv run python -m module (execute with project env)",
            "uv run pytest (run tests)",
            "uv add package (add dependency)",
            "uv remove package (remove dependency)"
          ],
          "distribution": [
            "uvx --from . docsrs-mcp (test local install)",
            "uvx --from git+URL docsrs-mcp (test from git)",
            "uv build (create distribution packages)"
          ]
        },
        "advantages": [
          "10-100x faster than pip for dependency resolution",
          "Built-in virtual environment management",
          "Zero-install execution with uvx",
          "Consistent lockfile management",
          "No mixing with other package managers needed"
        ],
        "projectStructure": {
          "configFile": "pyproject.toml",
          "lockFile": "uv.lock",
          "noRequirementsTxt": "All dependencies managed through pyproject.toml"
        }
      },
      "ruff": {
        "version": ">=0.1.0",
        "description": "Exclusive code quality tool - replaces multiple Python linters/formatters",
        "capabilities": [
          "Linting (replaces flake8, pylint, pycodestyle)",
          "Code formatting (replaces black, autopep8)",
          "Import sorting (replaces isort)",
          "Fast Rust-based implementation",
          "Single configuration in pyproject.toml"
        ],
        "commands": {
          "linting": [
            "uv run ruff check . (lint all files)",
            "uv run ruff check --fix . (lint and auto-fix)",
            "uv run ruff check --diff . (show potential changes)",
            "uv run ruff check path/to/file.py (lint specific file)"
          ],
          "formatting": [
            "uv run ruff format . (format all files)",
            "uv run ruff format --check . (check formatting without changes)",
            "uv run ruff format --diff . (show formatting changes)"
          ]
        },
        "advantages": [
          "10-100x faster than traditional Python tools",
          "Single tool replaces black + isort + flake8 + more",
          "Built-in auto-fix for many lint violations",
          "Comprehensive rule set with sensible defaults",
          "Excellent editor integration and LSP support"
        ],
        "configuration": {
          "location": "pyproject.toml under [tool.ruff]",
          "sections": [
            "[tool.ruff] - general settings",
            "[tool.ruff.lint] - linting rules",
            "[tool.ruff.format] - formatting options"
          ]
        }
      }
    }
  },
  "recommendations": {
    "implementation": [
      "Start with FastMCP for quick MCP server setup",
      "MANDATORY: Use sqlite-vec 0.1.6 (sqlite-vss is deprecated)",
      "CRITICAL: Pin aiohttp to 3.9.5 to avoid memory leaks",
      "Use FastEmbed <0.7.0 for onnxruntime compatibility",
      "Implement aiosqlite for async database operations",
      "Use MATCH operator syntax for sqlite-vec queries",
      "Implement connection pooling for aiohttp from start",
      "Set up proper asyncio task management",
      "Use streaming decompression for large rustdoc files",
      "Start with simple crate description parsing for MVP",
      "Use ijson for memory-efficient parsing of large JSON files",
      "Implement per-crate locking to prevent duplicate ingestion",
      "Use tenacity for robust HTTP request retry mechanisms",
      "Set reasonable size limits for downloads and decompression",
      "Prefer .zst compressed format over .gz for rustdoc JSON files"
    ],
    "performance": [
      "Batch embeddings in groups of 32",
      "Batch database inserts in groups of 1000",
      "Use uvloop for event loop optimization",
      "Implement caching at multiple levels",
      "Profile memory usage early and often",
      "Monitor aiohttp memory usage closely due to version constraints",
      "Use sqlite-vec MATCH operator for optimal query performance",
      "Include k constraint in all KNN queries for sqlite-vec",
      "Use streaming decompression to avoid memory spikes",
      "Implement LRU eviction based on file modification time",
      "Monitor download and decompression size limits"
    ],
    "production": [
      "Configure proper worker count for uvicorn",
      "Set up distributed rate limiting with Redis",
      "Implement health checks and monitoring",
      "Use volume mounts for cache persistence",
      "Plan for horizontal scaling if needed"
    ]
  }
}