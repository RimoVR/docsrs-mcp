{
  "meta": {
    "projectName": "docsrs-mcp",
    "lastUpdated": "2025-08-23T18:45:00",
    "compressionVersion": "1.2",
    "originalTokens": 51200,
    "legend": {
      "keys": {
        "desc": "description",
        "impl": "implementation", 
        "perf": "performance",
        "cfg": "configuration",
        "opt": "optimization",
        "compat": "compatibility",
        "reqs": "requirements",
        "vulns": "vulnerabilities",
        "thresh": "thresholds",
        "strat": "strategies",
        "proc": "processing",
        "mem": "memory",
        "lib": "library",
        "ver": "version",
        "feat": "features",
        "vals": "validators",
        "sched": "scheduling",
        "mgmt": "management",
        "mod": "modularization",
        "import": "imports",
        "compat": "compatibility",
        "api": "API",
        "bloom": "bloom filter",
        "cross_platform": "cross-platform",
        "priority_q": "priority queue",
        "mmap": "memory-mapped"
      },
      "phrases": {
        "p1": "Use for optimal performance",
        "p2": "CRITICAL implementation requirement",
        "p3": "Memory efficiency optimization",
        "p4": "Backward compatibility maintenance",
        "p5": "Security vulnerability mitigation",
        "p6": "Performance bottleneck resolution",
        "p7": "Production readiness requirement",
        "p8": "Token usage optimization",
        "p9": "Error handling best practice",
        "p10": "Database operation optimization",
        "p11": "Code organization best practice",
        "p12": "Import optimization strategy",
        "p13": "Modularization pattern",
        "p14": "Backward compatibility requirement",
        "p15": "Alternative implementation required",
        "p16": "Cross-platform path detection",
        "p17": "JSON API unavailable",
        "p18": "Priority queue optimization",
        "p19": "Memory efficiency strategy"
      }
    },
    "globals": {
      "versions": {
        "fastmcp": "2.11.3",
        "official_mcp_sdk": "1.13.1",
        "sqlitevec": "0.1.0+",
        "aiohttp": "3.9.5",
        "fastembed": "0.7.1",
        "rapidfuzz": "3.13.0",
        "pydantic": "2.11.7",
        "uvicorn": "0.27.1",
        "ijson": "3.4.0",
        "pygments": "2.19.2",
        "slowapi": "0.1.10",
        "tiktoken": "0.11.0",
        "pybloomfiltermmap3": "0.6.0",
        "mmh3": "4.1.0"
      },
      "perf_metrics": {
        "sqlite_vec_query": "<100ms for 1M+ vectors",
        "rapidfuzz_speedup": "4000%+ vs FuzzyWuzzy (16x baseline)", 
        "fastembed_speedup": "2-10x vs HuggingFace",
        "ijson_speedup": "656x with yajl2_c backend",
        "treesitter_speedup": "36x vs regex",
        "memory_efficiency": "7-25x with generators",
        "mmr_diversification_overhead": "<5ms additional latency",
        "fuzzy_normalization_overhead": "<1ms per query",
        "bloom_filter_lookup": "O(1) with 0.1% false positive rate",
        "priority_queue_insert": "O(log n) with negative values for max-heap",
        "memory_mapped_hash": "mmh3 provides fast hashing for bloom filters",
        "rapidfuzz_simd_memory": "10x memory reduction with SIMD optimizations",
        "prefix_scope_reduction": "60-80% search space reduction",
        "rrf_fusion_overhead": "Minimal latency for Reciprocal Rank Fusion",
        "partial_index_improvement": "Optimized filtering with partial database indices"
      },
      "memory_limits": {
        "embeddings_10k": "1GB",
        "warning_threshold": "80%",
        "critical_threshold": "90%",
        "sqlite_param_limit": "999",
        "batch_size_optimal": "1000"
      },
      "phase_2_implementation": {
        "pybloomfiltermmap3_compatibility": {
          "issue": "Version compatibility issue with Python 3.13",
          "problem": "C extension compilation fails with newer Python versions",
          "alternative": "Set-based implementation provides O(1) lookups with reasonable memory usage",
          "future_migration": "p15 - Migration path when library updates for Python 3.13+",
          "workaround": "JSON serialization adequate for moderate-sized dependency sets"
        },
        "rustup_detection": {
          "cross_platform_paths": {
            "windows": "%USERPROFILE%\\.rustup",
            "macos_linux": "~/.rustup",
            "wsl": "/home/{user}/.rustup"
          },
          "rust_docs_json_location": "toolchains/{toolchain}/lib/rustlib/{target}/json/",
          "nightly_requirement": "Nightly toolchain required for rust-docs-json component",
          "detection_strategy": "p16 - Cross-platform environment variable and filesystem detection"
        },
        "rust_lang_org_api": {
          "json_availability": "p17 - Currently no JSON API available from rust-lang.org",
          "documentation_format": "HTML documentation only at https://doc.rust-lang.org",
          "local_source": "Local rustup JSON is the only reliable source for stdlib rustdoc",
          "fallback_necessity": "HTML parsing required for online stdlib documentation"
        },
        "priority_queue_behavior": {
          "heap_type": "Python's heapq uses min-heap by default",
          "max_heap_implementation": "p18 - Negative values required for max-heap behavior",
          "infinity_handling": "float('-inf') works correctly for highest priority items",
          "asyncio_compatibility": "asyncio.PriorityQueue handles infinity values properly",
          "performance": "O(log n) insertion with proper priority ordering"
        },
        "memory_mapped_files": {
          "mmh3_library": "mmh3 library provides fast hashing for bloom filters",
          "memory_efficiency": "p19 - Memory-mapped files reduce memory usage for large filters",
          "serialization_strategy": "JSON serialization adequate for moderate-sized dependency sets",
          "bloom_alternative": "Set-based implementation when bloom filters unavailable",
          "performance_characteristics": "Hash-based lookups maintain O(1) complexity"
        }
      }
    }
  },
  "research": {
    "mcp": {
      "overview": "Open standard by Anthropic for LLM-tool communication",
      "spec_ver": "2025-06-18",
      "fastapi": {
        "lib": "FastMCP",
        "ver": "#{fastmcp}",
        "method": "FastMCP.from_fastapi()",
        "feat": ["Auto REST→MCP conversion", "Tool auto-discovery", "Dual mode operation"],
        "transport": "STDIO required for Claude Desktop - all logging to stderr",
        "modes": {
          "mcp": {"default": true, "purpose": "Claude Desktop integration"},
          "rest": {"purpose": "Debug/direct API", "flag": "--mode rest"}
        },
        "client_compatibility": {
          "claude_code": "NO support for anyOf schemas (confirmed 2025-08-13)",
          "claude_desktop": "Partial/buggy anyOf support",
          "fastmcp": "Limited polymorphism support for anyOf/oneOf/allOf",
          "general": "Inconsistent JSON Schema support across MCP clients"
        },
        "issues": {
          "vulns": {"cve": "N/A", "type": "Protocol corruption via stdout"},
          "type_coercion": {
            "problem": "Client sends strings for numeric/boolean params",
            "solution": "Use anyOf patterns + Pydantic mode='before' vals"
          },
          "validation": "Double validation: FastMCP + MCP client inconsistencies",
          "parameter_serialization": "Claude Code bugs with empty dictionaries",
          "anyof_failures": "anyOf patterns cause validation failures in multiple clients",
          "inspector_ui": "MCP Inspector UI sends null values for form parameters"
        },
        "best_practices_discovered": {
          "parameter_compatibility": "Use string-only parameters for maximum MCP client compatibility",
          "field_validation": "Implement field validators with mode='before' for type coercion",
          "schema_examples": "Provide examples arrays in parameter schemas",
          "description_hints": "Include clear format hints in descriptions",
          "schema_override_technique": "Modify FastMCP _tool_manager schemas post-generation for client compatibility",
          "validation_flow_optimization": "Leverage FastMCP's lenient JSON Schema validation with Pydantic conversion"
        },
        "manifest": {
          "structure": "MCPManifest with MCPTool objects",
          "critical_fields": ["tutorial", "examples", "desc"],
          "patterns": "MANDATORY anyOf for numeric/boolean params"
        },
        "library_validation": {
          "fastmcp_double_validation": "FastMCP performs double validation (JSON Schema → Pydantic)",
          "pydantic_v2_coercion": "Pydantic v2 field validators handle coercion perfectly with mode='before'",
          "performance_impact": "Double validation adds overhead but ensures compatibility"
        }
      },
      "parameter_validation_investigation": {
        "research_date": "2025-08-13",
        "updated": "2025-08-23",
        "context": "Investigation during MCP parameter validation fix with enhanced findings",
        "client_compatibility_matrix": {
          "claude_code": {
            "anyof_support": "NONE - confirmed no support for anyOf schemas",
            "parameter_handling": "String serialization only",
            "known_bugs": "Empty dictionary parameter serialization failures",
            "critical_bug": "Parameter serialization bug causes failures after first MCP call",
            "boolean_handling": "Requires string representations: true/false, 1/0, yes/no, on/off, enabled/disabled"
          },
          "claude_desktop": {
            "anyof_support": "PARTIAL - buggy implementation",
            "parameter_handling": "Mixed type support with inconsistencies"
          },
          "fastmcp": {
            "anyof_support": "LIMITED - basic oneOf/allOf/anyOf polymorphism",
            "validation_behavior": "Double validation: JSON Schema then Pydantic"
          },
          "mcp_inspector": {
            "parameter_handling": "Sends null values for form parameters",
            "ui_limitations": "Form-based parameter input inconsistent with protocol"
          }
        },
        "validation_patterns": {
          "string_only_parameters": {
            "compatibility": "Maximum compatibility across all MCP clients",
            "implementation": "Use str type with field validators for coercion",
            "benefit": "Eliminates anyOf-related validation failures"
          },
          "field_validators": {
            "mode_before": "Required for type coercion from string inputs",
            "pydantic_v2": "Handles coercion perfectly with proper configuration",
            "error_handling": "Must raise ValueError, not ValidationError"
          },
          "schema_enhancements": {
            "examples_arrays": "Provide concrete usage examples in parameter schemas",
            "format_hints": "Include clear format descriptions for complex parameters",
            "type_documentation": "Document expected input formats in descriptions"
          }
        },
        "technical_findings": {
          "double_validation_overhead": {
            "description": "FastMCP validates parameters twice: JSON Schema then Pydantic",
            "impact": "Adds processing overhead but ensures compatibility",
            "mitigation": "Optimize validators for performance with isinstance() checks"
          },
          "anyof_schema_limitations": {
            "problem": "anyOf patterns cause validation failures across multiple clients",
            "root_cause": "Inconsistent JSON Schema implementation in MCP clients",
            "solution": "Avoid anyOf patterns; use string parameters with validation"
          },
          "fastmcp_schema_override": {
            "discovery": "FastMCP internal architecture allows post-generation schema modification",
            "implementation": "Access via mcp._tool_manager after FastMCP.from_fastapi()",
            "modification_window": "Between tool generation and server startup",
            "json_schema_leniency": "FastMCP's validation layer accepts type mismatches when schemas declare strings but receive native types",
            "double_validation_bypass": "Schema override prevents first validation layer from rejecting valid inputs",
            "validation_flow": [
              "FastMCP generates anyOf schemas from Pydantic models",
              "Override replaces schemas with string-only types", 
              "Client sends native JSON types",
              "JSON Schema validation passes (lenient checking)",
              "Pydantic validators perform actual type conversion"
            ],
            "compatibility_matrix": {
              "claude_code": "WORKING with override",
              "rest_api": "Unaffected (different validation path)",
              "other_mcp_clients": "Compatible (handle strings naturally)"
            },
            "performance_impact": "Minimal - override runs once at startup, no runtime overhead after initialization"
          }
        },
        "fastmcp_2113_enhancements": {
          "research_date": "2025-08-23",
          "automatic_schema_generation": "FastMCP 2.11.3 provides automatic schema generation from type hints with full Pydantic integration",
          "pydantic_integration": "Native Pydantic field validators with mode='before' essential for MCP client compatibility",
          "schema_override_requirement": "anyOf schema patterns not supported by Claude Code - requires schema override workarounds",
          "type_coercion_necessity": "MCP clients may send any parameter as string, requiring robust string-to-type coercion"
        },
        "boolean_validation_optimization": {
          "performance_finding": "Lookup tables for boolean validation provide 10x performance improvement over string parsing",
          "implementation_pattern": "Use isinstance(value, bool) fast path before string validation lookup table",
          "supported_representations": {
            "true_values": ["true", "1", "yes", "on", "enabled"],
            "false_values": ["false", "0", "no", "off", "disabled"],
            "case_handling": "Case-insensitive matching required for MCP client compatibility"
          },
          "performance_data": {
            "lookup_table_speedup": "10x faster than string parsing methods",
            "fast_path_optimization": "isinstance(v, bool) check provides immediate return for native boolean values",
            "overhead": "Negligible impact on overall validation performance"
          }
        },
        "mcp_client_parameter_handling": {
          "universal_string_requirement": "MCP clients may send any parameter as string regardless of declared type",
          "validation_architecture": "Double validation pattern: FastMCP JSON Schema → Pydantic field validators",
          "compatibility_strategy": "Use string-only parameters with robust field validators for maximum client compatibility",
          "error_handling": "Provide clear error messages with expected formats when type coercion fails"
        }
      }
    },
    "official_python_mcp_sdk_migration": {
      "overview": "Research on migrating from FastMCP to official Python MCP SDK",
      "research_date": "2025-08-22",
      "context": "Investigation of official SDK migration path for improved compatibility",
      "key_findings": {
        "fastmcp_incorporation": "FastMCP 1.0 incorporated into official SDK as 'from mcp.server.fastmcp import FastMCP'",
        "decorator_pattern": "Official SDK provides @mcp.tool() decorators for cleaner tool definitions",
        "compatibility_improvement": "Better Claude Code compatibility expected without schema override hacks",
        "transport_support": "Supports stdio, SSE, and StreamableHTTP transports",
        "python_requirement": "Python 3.10+ requirement aligns with current project setup"
      },
      "migration_strategy": {
        "approach": "Parallel implementation allows safe testing before switchover",
        "modularization": "Provides natural break points for refactoring",
        "business_logic": "Business logic remains unchanged, only interface layer changes"
      },
      "security_considerations": {
        "stdio_vulnerabilities": "Stdio transport has known vulnerabilities (avoid in production)",
        "authentication_gap": "Official SDK lacks built-in authentication (implement custom TokenVerifier)",
        "production_transport": "StreamableHTTP preferred for future production deployments"
      },
      "performance_expectations": {
        "stdio_latency": "Microsecond-level latency (same as current)",
        "regression_risk": "No performance regression expected for local MCP operations",
        "validation_overhead": "Potential for better performance without double validation overhead"
      },
      "version_information": {
        "current_fastmcp": "#{fastmcp}",
        "target_sdk": "mcp>=#{official_mcp_sdk} (official SDK)",
        "installation": "uv add 'mcp[cli]'"
      },
      "implementation_benefits": {
        "cleaner_apis": "Decorator-based tool definitions more readable",
        "better_integration": "Native MCP protocol compliance",
        "reduced_workarounds": "Eliminates need for schema override hacks",
        "future_proof": "Aligned with official MCP ecosystem evolution"
      },
      "migration_priorities": {
        "phase_1": "Parallel implementation with official SDK alongside FastMCP",
        "phase_2": "Comprehensive testing with actual MCP clients",
        "phase_3": "Performance benchmarking and validation", 
        "phase_4": "Production switchover after validation"
      }
    },
    "official_mcp_python_sdk_research": {
      "overview": "Comprehensive research on official MCP Python SDK for accurate migration planning",
      "research_date": "2025-08-22",
      "context": "Detailed investigation of actual SDK version, features, and implementation patterns",
      "version_correction": {
        "assumed_version": "v3.0 (incorrect assumption)",
        "actual_version": "1.13.1 (August 2025)",
        "no_v3_exists": "No v3.0 version exists despite initial assumptions",
        "version_history": "FastMCP 1.0 incorporated into official SDK in 2024",
        "current_status": "SDK 1.13.1 is current official version with FastMCP 1.0 integrated"
      },
      "installation_details": {
        "primary_method": "pip install 'mcp[cli]' or uv add 'mcp[cli]'",
        "python_requirements": "Python >=3.10",
        "license": "MIT License",
        "maintainer": "Anthropic, PBC",
        "github_repo": "https://github.com/modelcontextprotocol/python-sdk",
        "pypi_package": "https://pypi.org/project/mcp/"
      },
      "sdk_features": {
        "fastmcp_integration": "FastMCP 1.0 incorporated into official SDK in 2024",
        "tool_registration": "@server.tool() decorator pattern for tool registration",
        "import_pattern": "from mcp.server import Server",
        "structured_output": "Native support for Pydantic models, TypedDicts, classes with type hints",
        "transport_modes": "STDIO (local) and HTTP/SSE (remote) dual-mode support",
        "context_injection": "Progress reporting via ctx.report_progress()",
        "parameter_handling": "Native support for string parameters from MCP clients"
      },
      "migration_patterns": {
        "import_statement": "from mcp.server import Server",
        "server_creation": "server = Server('docsrs-mcp')",
        "tool_decorator": "@server.tool() decorator pattern for tool registration",
        "function_signature": "async def tool_name(param: str, optional: Optional[int] = None) -> dict",
        "documentation": "Tool description for auto-documentation via docstring",
        "type_hints": "Use type hints for automatic schema generation",
        "service_layer_extraction": "Extract business logic for reuse across implementations"
      },
      "claude_code_integration": {
        "configuration": "JSON with mcpServers object",
        "scopes": "local (project), project (.mcp.json), user (cross-project)",
        "authentication": "OAuth 2.0 for remote servers",
        "parameter_handling": "SDK handles string conversion automatically",
        "transport_preference": "STDIO for local development, HTTP for remote"
      },
      "performance_characteristics": {
        "warm_search": "<50ms with proper caching",
        "memory_leak_confirmed": "Known memory leak in SDK 1.13.1 (GitHub issues #1076, #756)",
        "leak_pattern": "Continuous tool calls cause memory accumulation",
        "mitigation_strategy": "Server rotation every 1000 calls recommended",
        "transport_alternative": "Use stdio transport instead of HTTP to reduce leak impact",
        "concurrency": "Async/await patterns recommended",
        "transport_choice": "STDIO for local, HTTP for remote",
        "comparison_to_fastmcp": "Similar performance, potentially better validation"
      },
      "best_practices": {
        "type_hints": "Use type hints for automatic schema generation",
        "structured_output": "Implement structured output with Pydantic models",
        "stdout_prohibition": "Never write to stdout in STDIO mode (use stderr)",
        "configuration": "Use environment variables for configuration",
        "error_handling": "Implement proper error handling with McpError",
        "background_testing": "Use nohup for background process testing"
      },
      "documentation_references": {
        "github": "https://github.com/modelcontextprotocol/python-sdk",
        "quickstart": "https://modelcontextprotocol.io/quickstart/server",
        "pypi": "https://pypi.org/project/mcp/",
        "claude_code_docs": "https://docs.anthropic.com/en/docs/claude-code/mcp",
        "specification": "https://spec.modelcontextprotocol.io/specification/"
      },
      "important_caveats": {
        "version_confusion": "No v3.0 version exists despite initial assumptions",
        "fastmcp_separation": "FastMCP 2.11.1 has enhanced features not in SDK",
        "api_divergence": "FastMCP vs SDK differences require code changes, not just imports",
        "schema_override_obsolete": "Schema override workaround no longer needed with SDK",
        "memory_leak": "Memory leak confirmed in 1.13.1 - implement monitoring",
        "testing_requirement": "Use nohup for background process testing",
        "validation_differences": "Validation behavior may differ from FastMCP standalone"
      },
      "migration_readiness": {
        "sdk_maturity": "Production ready as of 1.13.1",
        "feature_parity": "Full feature parity with FastMCP standalone",
        "compatibility_improvements": "Expected better Claude Code compatibility",
        "migration_risk": "Low risk - same underlying FastMCP implementation",
        "rollback_strategy": "Can maintain both implementations during transition",
        "parallel_implementation": "Service layer extraction enables safe parallel deployment",
        "feature_flag_rollout": "Gradual cutover with validation using feature flags",
        "parameter_validation_required": "Type conversion and bounds checking for string parameters"
      }
    },
    "sdk_migration_detailed_findings": {
      "overview": "Detailed research findings on Python MCP SDK 1.13.1 migration",
      "research_date": "2025-08-22",
      "context": "Comprehensive SDK migration analysis with implementation patterns",
      "current_sdk_version": {
        "version": "1.13.1",
        "status": "Current official version",
        "fastmcp_integration": "FastMCP 1.0 integrated natively",
        "import_pattern": "from mcp.server import Server",
        "decorator_pattern": "@server.tool() for tool registration"
      },
      "memory_leak_analysis": {
        "confirmed_issue": "Memory leak in SDK 1.13.1",
        "github_issues": ["#1076", "#756"],
        "leak_mechanism": "Continuous tool calls cause memory accumulation",
        "impact_assessment": "Production servers affected with high call volumes",
        "mitigation_strategies": {
          "server_rotation": "Rotate server instance every 1000 calls",
          "transport_selection": "Use stdio transport instead of HTTP",
          "monitoring_required": "Implement memory usage monitoring",
          "restart_automation": "Automated restart triggers based on memory thresholds"
        }
      },
      "migration_implementation_patterns": {
        "service_layer_extraction": {
          "purpose": "Enable business logic reuse across implementations",
          "pattern": "Extract core functionality to service classes",
          "benefit": "Interface layer changes without business logic modification"
        },
        "parallel_deployment": {
          "strategy": "Run FastMCP and SDK implementations side by side",
          "validation": "Compare responses and performance metrics",
          "safety": "Safe testing before complete switchover"
        },
        "feature_flag_controlled_rollout": {
          "mechanism": "Use feature flags to control SDK vs FastMCP usage",
          "gradual_migration": "Percentage-based traffic routing",
          "rollback_capability": "Instant rollback if issues detected"
        }
      },
      "parameter_compatibility_analysis": {
        "sdk_expectation": "SDK expects string parameters from MCP clients",
        "type_conversion_required": {
          "boolean_handling": "Handle 'true'/'false' strings from clients",
          "integer_conversion": "Convert numeric strings with bounds checking",
          "validation_layer": "Implement validation for type conversion"
        },
        "client_behavior": {
          "claude_code": "Sends string parameters consistently",
          "claude_desktop": "Mixed parameter types depending on context",
          "mcp_inspector": "Form-based input sends string values"
        }
      },
      "fastmcp_vs_sdk_differences": {
        "enhanced_features": "FastMCP 2.11.1 has features not available in SDK",
        "api_changes": "Code changes required beyond simple import substitution",
        "schema_override_obsolete": "Schema override workaround unnecessary with SDK",
        "validation_improvements": "SDK provides better native validation patterns",
        "breaking_changes": {
          "decorator_syntax": "@server.tool() vs @fastmcp.tool()",
          "server_initialization": "Server() constructor vs FastMCP.from_fastapi()",
          "transport_configuration": "Different transport setup patterns"
        }
      },
      "implementation_recommendations": {
        "business_logic_separation": "Extract to service layer for reusability",
        "gradual_migration": "Implement parallel systems with feature flags",
        "memory_monitoring": "Implement comprehensive memory leak monitoring",
        "parameter_validation": "Add robust string-to-type conversion logic",
        "testing_strategy": "Test with actual MCP clients, not synthetic tests",
        "rollback_preparation": "Maintain FastMCP implementation during transition"
      }
    },
    "vector_search": {
      "sqlite_vss": "DEPRECATED - unmaintained",
      "sqlite_vec": {
        "ver": "#{sqlitevec}",
        "perf": "#{sqlite_vec_query}",
        "feat": ["Brute force <1M vectors", "SIMD acceleration", "Binary quantization 8x reduction"],
        "syntax": "MATCH operator required",
        "opt": {
          "quantization": "75% mem reduction float32→uint8",
          "chunking": "O(NM)→O(N) complexity",
          "wal_mode": "Improved write perf"
        }
      },
      "embedding": {
        "models": {
          "all_minilm_l6_v2": {"mem_reduction": "85%", "perf": "good"},
          "baai_bge_small_en_v1_5": {
            "mteb_score": 62.17, 
            "skip_instructions": true,
            "usage": "Primary embedding model for MCP semantic search",
            "context": "Referenced during MCP parameter validation research 2025-08-13"
          }
        },
        "fastembed": {
          "ver": "#{fastembed}",
          "issue": "Memory leak 1.5GB→16GB",
          "opt": ["Session caching", "Generator pattern", "ONNX Runtime"],
          "batch_sizes": {"cpu": 16, "gpu": 256, "general": 32}
        },
        "onnx_env": ["ORT_DISABLE_CPU_ARENA_ALLOCATOR=1", "ORT_DISABLE_MEMORY_PATTERN=1"],
        "onnx_runtime_optimization": {
          "arena_configuration": "Proper arena settings prevent memory bloat during embedding generation",
          "memory_management": "ONNX runtime memory optimizable through environment variable configuration",
          "performance_impact": "Arena optimization reduces memory footprint for batch embedding operations"
        }
      },
      "sync": {
        "libs": {"sqlite_vec": "#{sqlitevec}", "aiosqlite": "3.0.0", "embedding_model": "fastembed"},
        "findings": {
          "trigger_limits": "Manual sync required for virtual tables",
          "insert_replace_issues": "Use DELETE+INSERT pattern",
          "autoincrement": "Solves lastrowid issues"
        },
        "patterns": {
          "manual_sync": "Explicit sync calls required",
          "hash_dedup": "SHA256-based deduplication",
          "batch_proc": "#{batch_size_optimal} records per transaction"
        }
      }
    },
    "implementation": {
      "hierarchy": {"adjacency_list": "Parent-child relationships", "recursive_ctes": "Tree traversal"},
      "async_db": {"lib": "aiosqlite", "ver": "3.0.0"},
      "pytest": {
        "compat": {
          "stable": "pytest-asyncio-mode=auto",
          "problematic": "pytest-asyncio 0.21.0 + Python 3.11"
        },
        "cfg": "asyncio_mode=auto in pytest.ini"
      },
      "batch_insert": {
        "sqlite_limit": "#{sqlite_param_limit} parameters max",
        "virtual_tables": "No lastrowid support - use SELECT last_insert_rowid()",
        "optimal_size": "#{batch_size_optimal}",
        "opts": {
          "pre_serialize": "Vectors to bytes before batch",
          "transaction_per_batch": "One transaction per #{batch_size_optimal}",
          "adaptive": {"mem_thresh": "#{warning_threshold}%/#{critical_threshold}%"},
          "sqlite_vec_storage": {
            "serialization_method": "sqlite_vec.serialize_float32() for proper embedding storage",
            "storage_optimization": "Native serialize function ensures optimal SQLite vector storage format",
            "performance_benefit": "Proper serialization prevents storage corruption and query failures"
          },
          "batch_processing_enhancement": {
            "adaptive_sizing": "Dynamic batch size adjustment based on memory pressure monitoring",
            "stability_improvement": "Prevents memory exhaustion during large dataset ingestion",
            "memory_threshold_response": "Reduces batch size automatically when memory usage exceeds thresholds"
          }
        }
      },
      "search_opt": {
        "semantic_chunk": "50-200 tokens optimal",
        "brute_force_thresh": "<1M vectors",
        "binary_quant": "32x mem reduction minimal accuracy loss",
        "simd": "Built-in acceleration",
        "filters": {
          "partial_idx": "WHERE clause optimization", 
          "progressive": "Multi-stage filtering",
          "selectivity": "Analyze filter effectiveness"
        }
      }
    },
    "ranking": {
      "hybrid": "Vector + metadata signals",
      "similarity_norm": "(1 + cosine_similarity) / 2",
      "perf_target": "<500ms latency",
      "scoring": "Multi-factor approach",
      "mmr_diversification": {
        "desc": "Maximum Marginal Relevance algorithm for result diversification",
        "formula": "MMR = λ * relevance + (1-λ) * diversity",
        "default_lambda": "0.6 (balances relevance vs diversity)",
        "diversity_weight": "0.1 (enables/disables MMR globally)",
        "perf": "Minimal overhead with intelligent over-fetching",
        "diversity_factors": {
          "type_penalty": "0.2 per duplicate item type",
          "path_similarity": "Module-based path comparison",
          "max_type_penalty": "0.6 (prevents excessive penalization)"
        },
        "dynamic_fetch": {
          "base_strategy": "k + 10 over-fetch",
          "mmr_boost": "1.5x multiplier when enabled",
          "performance_cap": "Maximum 50 candidates for latency"
        }
      },
      "multi_factor_scoring": {
        "weights": {
          "vector": "0.6 (reduced from 0.7)",
          "type": "0.15 (enhanced type-specific boosts)",
          "quality": "0.1 (documentation quality heuristics)",
          "examples": "0.15 (increased from 0.05)"
        },
        "type_weights": {
          "function": "1.2x boost",
          "trait": "1.15x boost",
          "struct": "1.1x boost",
          "trait_impl": "1.1x boost",
          "module": "0.9x penalty"
        }
      },
      "code_extraction": {
        "lib": "Pygments #{pygments}",
        "impl": "Language detection + syntax highlighting",
        "storage": "JSON format in TEXT columns",
        "backward_compat": "Support legacy list format",
        "search_opt": "Vector similarity search",
        "dedup": "Hash-based prevention",
        "embedding_storage": "sqlite-vec integration"
      }
    },
    "see_also": {
      "constraints": {"k_param": "Required for sqlite-vec queries"},
      "embedding": {"similarity_thresh": "0.7-0.8 with BAAI/bge-small-en-v1.5"},
      "cognitive": {"suggestion_count": "3-5 items optimal"},
      "impl": {"caching": "TTL LRU 60s"},
      "thresh_validation": "Empirical testing required"
    },
    "fallback_extraction": {
      "three_tier_system": {
        "description": "Multi-source extraction system for comprehensive documentation coverage",
        "tier1": {
          "source": "Rustdoc JSON from docs.rs",
          "coverage": "~10-15% of crates",
          "quality": "highest", 
          "format": "Structured JSON with complete metadata"
        },
        "tier2": {
          "source": "Source code extraction from crates.io CDN",
          "coverage": "80%+ of crates",
          "quality": "medium-high",
          "cdn_url": "https://static.crates.io/crates/{name}/{name}-{version}.crate",
          "rate_limits": "None - CDN has no rate limiting",
          "format": "Tar.gz archives with .rs files",
          "extraction_method": "Regex-based documentation parsing"
        },
        "tier3": {
          "source": "Latest version fallback",
          "coverage": "100% guaranteed",
          "quality": "basic",
          "purpose": "Ensure no crate is left without documentation"
        },
        "decision_logic": {
          "tier1_to_tier2": "RustdocVersionNotFoundError or parsing failure",
          "tier2_to_tier3": "CDN unavailable or extraction timeout",
          "performance": "Sub-500ms search maintained across all tiers"
        },
        "stdlib_special_case": {
          "limitation": "Standard library crates (std, core, alloc, proc_macro, test) bypass tier1",
          "reason": "Not published on crates.io, docs.rs redirects to doc.rust-lang.org HTML",
          "fallback_strategy": "Direct tier3 fallback with basic functionality",
          "user_solution": "rustup component add --toolchain nightly rust-docs-json for complete stdlib JSON"
        }
      }
    },
    "auto_ingestion_analysis": {
      "universal_coverage_status": {
        "desc": "Assessment of auto-ingestion implementation across all MCP tools",
        "finding": "Most tools already implement auto-ingestion correctly with await ingest_crate() pattern",
        "coverage_estimate": "85-90% of tools have proper auto-ingestion",
        "standard_pattern": "await ingest_crate() as first operation in tool implementations",
        "gap_identification": "Need comprehensive audit to ensure 100% coverage",
        "implementation_consistency": "Consistent pattern across existing tools indicates good design",
        "remaining_work": "Systematic audit and gap filling for remaining 10-15% of tools"
      },
      "audit_methodology": {
        "approach": "Systematic review of all MCP tool implementations",
        "verification_steps": [
          "Check for ingest_crate() call presence",
          "Verify call placement at function start",
          "Confirm proper error handling",
          "Test with uninitalized crate scenarios"
        ],
        "success_criteria": "100% of tools handle uninitialized crates gracefully",
        "performance_impact": "Minimal - ingestion checks are fast for already-processed crates"
      }
    },
    "docs_rs": {
      "rustdoc_json": {
        "compression": {
          "zstd": {"magic_bytes": "[0x28, 0xb5, 0x2f, 0xfd]", "preferred": true},
          "gzip": {"fallback": true}
        },
        "delivery": "static.docs.rs CDN",
        "sizes": {"stdlib": "100MB+", "avg_crate": "1-10MB"},
        "parsing": "High complexity - nested JSON",
        "mem": "Stream processing required",
        "best_practices": {
          "streaming": "ijson with yajl2_c",
          "symbol_intern": "String deduplication", 
          "on_demand": "Parse sections as needed",
          "format_ver": "Always validate FORMAT_VERSION"
        },
        "findings": {
          "ver_tracking": "Format compatibility checks",
          "json_structure": {
            "module_hierarchy": "From paths section",
            "perf_opts": {
              "ijson_streaming": "#{ijson_speedup}",
              "adjacency_list": "Hierarchical storage",
              "recursive_ctes": "Tree queries",
              "batch_insert": "#{batch_size_optimal} per transaction",
              "re_export_opts": {
                "ijson_optimized": "Stream processing",
                "batch_inserts": "Transaction batching", 
                "sqlite_idx": "Query optimization",
                "lru_cache": "Result caching"
              }
            }
          },
          "lib_vers": {
            "ijson": "#{ijson}",
            "zstandard": "0.23.0",
            "aiosqlite": "3.0.0"
          },
          "structural": {
            "item_types": "Function, struct, trait, module, etc",
            "signature_extract": "From inner.function.decl",
            "parent_resolution": "Via paths section mapping",
            "trait_impls": {
              "impl_block": "trait + for fields",
              "type_objects": "Multiple formats (resolved_path, path, generic, primitive)",
              "type_extraction": "Recursive processing"
            },
            "code_examples": {
              "pygments": "#{pygments}",
              "lang_detect": "30% confidence threshold",
              "storage": "JSON in TEXT columns",
              "search": "Vector similarity",
              "patterns": "Hash deduplication"
            },
            "re_export_discovery": {
              "format": {"kind": "import", "path": "source info", "target": "destination"},
              "patterns": {
                "trait_re_exports": "pub use trait::*",
                "function_re_exports": "pub use module::function",
                "module_flattening": "pub use module::*",
                "glob_imports": "Wildcard re-exports"
              }
            }
          },
          "db_opts": {
            "sqlite_limit": "#{sqlite_param_limit} params",
            "backward_compat": "NULL defaults for new columns"
          }
        }
      },
      "api": "/crate/{name}/{ver}/json",
      "ingestion": {
        "concurrency": "Per-crate locking",
        "size_mgmt": "Download limits + monitoring",
        "cache_evict": "LRU by modification time",
        "error_handling": "Tenacity retry logic",
        "module_tree": {
          "rustdoc_paths": "kind=module entries",
          "cargo_modules": "Workspace handling",
          "workspace": "Multi-crate scenarios"
        }
      },
      "rust_stdlib": {
        "source": "rust-docs-json component via rustup",
        "format_compat": "Same as crate docs",
        "chars": "100MB+ files",
        "mirror": "docs.rs unified API",
        "ver_mgmt": {"manifest": "https://static.rust-lang.org/version"},
        "best_practices": {
          "streaming": "ijson for large files",
          "mem_mgmt": "Chunk processing",
          "caching": "Aggressive - expensive parsing",
          "performance_optimization": {
            "ijson_backend": "yajl2_c provides 1329K objects/sec optimal performance",
            "streaming_parser": "ijson with C backend significantly outperforms standard JSON parser",
            "memory_pressure_handling": "Adaptive batch sizing based on memory monitoring prevents OOM"
          }
        },
        "docs_rs_limitations": {
          "json_unavailable": "Standard library rustdoc JSON NOT available on docs.rs",
          "redirect_issue": "docs.rs/std URLs redirect to doc.rust-lang.org which serves HTML only",
          "crates_io_absence": "Stdlib crates (std, core, alloc, proc_macro, test) not published on crates.io",
          "json_access_method": "rustup component add --toolchain nightly rust-docs-json required",
          "fallback_implemented": "Basic stdlib functionality provided via fallback mechanism when JSON unavailable",
        "phase_2_enhancements": {
          "rustup_detection": "Automatic cross-platform rustup installation detection",
          "component_validation": "Verify rust-docs-json component availability",
          "toolchain_selection": "Prefer nightly toolchain for complete stdlib access",
          "graceful_degradation": "Fallback to basic functionality when local JSON unavailable"
        }
        }
      },
      "phase_2_stdlib_findings": {
        "rustup_component_requirement": {
          "component_name": "rust-docs-json",
          "installation": "rustup component add --toolchain nightly rust-docs-json",
          "toolchain_requirement": "Nightly toolchain required for stdlib JSON documentation",
          "location_pattern": "~/.rustup/toolchains/{toolchain}/lib/rustlib/{target}/json/"
        },
        "cross_platform_rustup_detection": {
          "windows_path": "%USERPROFILE%\\.rustup",
          "unix_path": "$HOME/.rustup or ~/.rustup",
          "wsl_path": "/home/{user}/.rustup",
          "validation_strategy": "Check for toolchains directory existence"
        },
        "stdlib_documentation_limitations": {
          "docs_rs_unavailability": "Standard library rustdoc JSON NOT available on docs.rs",
          "redirect_behavior": "docs.rs/std URLs redirect to doc.rust-lang.org HTML",
          "api_gap": "No JSON API endpoint for stdlib documentation online",
          "local_dependency": "Local rustup installation required for complete stdlib access"
        }
      },
      "cross_reference_support": {
        "rustdoc_links_field": {
          "native_field": "links: FxHashMap<String, Id>",
          "desc": "Pre-resolved intra-doc link mappings in rustdoc JSON",
          "format": "link_text -> item_id mapping",
          "advantage": "No regex parsing needed - rustdoc provides resolved links"
        },
        "docs_rs_availability": {
          "json_start_date": "May 23, 2025",
          "compatibility": "Older crate versions may not have rustdoc JSON available",
          "fallback": "HTML-only documentation for pre-JSON era crates"
        },
        "api_endpoints": {
          "pattern": "https://docs.rs/crate/{name}/{version}/json",
          "version_specific": "Each crate version has dedicated JSON endpoint",
          "cdn_delivery": "Served via static.docs.rs CDN"
        },
        "compression_formats": {
          "primary": ".json.zst (Zstandard compression)",
          "fallback": ".json.gz (Gzip compression)", 
          "uncompressed": ".json (raw JSON)",
          "preference": "zstd for optimal size/speed balance"
        },
        "extraction_strategy": {
          "no_regex": "Native rustdoc links field eliminates parsing complexity",
          "pre_resolved": "Links already resolved to target item IDs",
          "implementation": "Direct JSON field access via ijson streaming",
          "performance": "Significant speedup vs HTML parsing + regex extraction"
        }
      }
    },
    "validation": {
      "pydantic": {
        "ver": "#{pydantic}",
        "perf": "17x improvement v1→v2",
        "field_vals": {
          "mcp_compat": "mode='before' for type coercion",
          "cross_field": "ValidationInfo.data access",
          "best_practices": "Specific error messages"
        },
        "extensions": {
          "json_schema_extra": {"examples": "Usage demonstrations"},
          "optional_pattern": "default=None explicit",
          "strict_validation": "Prevent type coercion",
          "annotated": "Field(description=...) pattern",
          "constraints": {
            "string": "min_length, max_length, pattern",
            "array": "min_items, max_items",
            "numeric": "ge, gt, le, lt"
          }
        },
        "mcp_params": {
          "client_inconsistency": "String params for numeric/boolean",
          "double_validation": "FastMCP + client side",
          "anyof_schema": "MANDATORY pattern for flexibility"
        },
        "boolean_validation": {
          "requirement": "field_validator with mode='before' REQUIRED for MCP boolean parameter compatibility",
          "performance_pattern": "Use fast path with isinstance(v, bool) check first for performance",
          "lookup_table_optimization": "Lookup tables provide 10x performance improvement over string parsing methods",
          "accepted_strings": "Comprehensive support: 'true', '1', 'yes', 'on', 'enabled' / 'false', '0', 'no', 'off', 'disabled' (case-insensitive)",
          "mcp_manifest_status": "MCP manifest anyOf patterns correctly configured, issue was only in Pydantic validation layer",
          "decorator_order": "field_validator must precede @classmethod decorator",
          "mode_purpose": "mode='before' processes raw input before Pydantic's type conversion",
          "default_behavior": "Return False as default for invalid/None inputs maintains consistency",
          "claude_code_compatibility": "Critical for Claude Code which has parameter serialization bugs after first MCP call"
        },
        "error_handling": {
          "field_validators": {
            "decorator": "@field_validator(mode='before')",
            "type_coercion": "Handle string→numeric/boolean conversion",
            "error_type": "Must raise ValueError, not ValidationError",
            "business_logic": "Use PydanticCustomError for domain-specific validation"
          },
          "config": {
            "strict_validation": "ConfigDict(extra='forbid') prevents unknown fields",
            "validation_alias": "Support multiple input formats",
            "json_schema_extra": "Include examples and descriptions"
          },
          "fastapi_integration": {
            "request_validation": "RequestValidationError inherits from Pydantic ValidationError",
            "exception_handler": "@app.exception_handler(RequestValidationError)",
            "http_status": "422 Unprocessable Entity for validation errors",
            "response_format": "Include field path, message, type, context"
          },
          "message_patterns": {
            "structure": "What went wrong + why + how to fix",
            "examples": "Provide concrete valid value examples", 
            "consistency": "Use uniform formatting across all errors",
            "specificity": "Avoid vague messages like 'Invalid input'",
            "proximity": "Place error messages near relevant field"
          },
          "performance": {
            "template_precompile": "Compile error templates at module level",
            "regex_precompile": "Pre-compile validation patterns",
            "fail_fast": "Use FailFast mode when completeness not required",
            "response_cache": "Cache error responses with appropriate TTL",
            "json_parsing": "model_validate_json() faster than model_validate(json.loads())"
          }
        }
      },
      "semver": {
        "lib": "semantic-version",
        "regex": "Standard SemVer 2.0.0 pattern",
        "special": {"latest": "Special case handling"},
        "integration": "Pydantic field validators",
        "perf": "Precompiled regex patterns"
      },
      "best_practices": {
        "boundaries": "Service layer only",
        "errors": "Specific actionable messages",
        "defaults": {"none_vals": "Application level", "empty_strings": "Context dependent"},
        "perf": {"regex_precompile": "Module level", "validation_cache": "TTL-based", "lazy": "On-demand validation"},
        "error_messages": {
          "structure": "What + Why + How to fix pattern",
          "examples": "Concrete valid values",
          "consistency": "Uniform formatting",
          "avoid": "Vague messages like 'Invalid input'",
          "http_422": "Standard code for validation errors"
        }
      }
    },
    "memory_mgmt": {
      "monitoring": "psutil with #{warning_threshold}%/#{critical_threshold}% thresh",
      "opts": {
        "generators": "#{memory_efficiency} vs lists",
        "adaptive_batch": "Threshold-based sizing",
        "streaming": "ijson for large files"
      }
    },
    "server_infra": {
      "fastapi": {
        "ver": "0.104.1",
        "auto_docs": {"openapi": "Swagger UI", "redoc": "ReDoc", "enhance": "Pydantic field descriptions"},
        "error_handling": {
          "http_exceptions": {"codes": "400, 401, 403, 404, 422, 500, 503"},
          "logging": {"stderr": "p2 - STDIO transport", "validation": "Structured error logs"}
        },
        "modularization_patterns": {
          "api_router": {
            "purpose": "p13 - Prevents circular imports in FastAPI applications",
            "pattern": "APIRouter instances for logical endpoint grouping",
            "benefits": ["Clean separation of concerns", "Individual rate limiting", "Modular middleware configuration"]
          },
          "router_organization": {
            "principle": "p11 - Group related endpoints in separate modules",
            "file_size_limit": "<500 LOC for maintainability",
            "separation_strategy": "Extract cross-cutting concerns into middleware"
          },
          "backward_compatibility": {
            "facade_pattern": "p14 - Preserve existing imports during refactoring",
            "re_exports": "Star imports in facade modules for comprehensive compatibility",
            "api_preservation": "Maintain public API while refactoring internals"
          }
        },
        "import_optimization": {
          "type_checking_pattern": {
            "purpose": "p12 - Reduce runtime import overhead",
            "implementation": "from __future__ import annotations + TYPE_CHECKING",
            "benefit": "Heavy dependencies loaded only for type checking",
            "architectural_benefit": "Prevents circular imports in modular Python architectures",
            "dependency_injection_support": "Enables clean separation of concerns without runtime import cycles",
            "refactoring_enabler": "Allows conditional imports for type hints only, supporting modular design"
          },
          "lazy_imports": {
            "targets": ["ONNX models", "Database operations", "Heavy ML libraries"],
            "strategy": "Import inside functions or conditional blocks",
            "performance": "Faster startup times"
          },
          "public_api_control": {
            "__all__": "Strategic use for clean public APIs",
            "module_organization": "Control what gets exported from modules"
          }
        },
        "pydantic_integration": {
          "field_naming": {
            "requirement": "p2 - snake_case field names (input_schema not inputSchema)",
            "validation": "Extra fields not allowed with strict validation",
            "schema_matching": "Model fields must match database schema exactly"
          },
          "fastapi_compatibility": {
            "request_validation": "RequestValidationError for field mismatches",
            "json_schema": "Field names must follow Python conventions",
            "type_hints": "Proper type annotations required"
          }
        }
      },
      "uvicorn": {"ver": "#{uvicorn}", "workers": "Production scaling"},
      "http_client": {
        "aiohttp": {"ver": "#{aiohttp}", "issue": "Memory leak in later versions"},
        "mem_leak": "p5 - Pin to 3.9.5"
      },
      "rate_limiting": {
        "lib": "SlowAPI #{slowapi}",
        "backend": {"memory": "Single worker", "redis": "Multi-worker"},
        "algorithm": {"token_bucket": "p1 - burst handling"},
        "impl": {
          "request_param": "Explicit Request parameter",
          "limiter_state": "app.state.limiter required",
          "decorator": "@limiter.limit() pattern",
          "headers": {"retry_after": "Rate limit guidance", "rate_limit": "X-RateLimit-* headers"},
          "exceptions": "Custom handler for consistent format"
        },
        "avoid": "BaseHTTPMiddleware (70-80% perf penalty)",
        "production": {"single_worker": "In-memory OK", "multi_worker": "Redis required", "monitoring": "Response time tracking"}
      },
      "compression": "gzip middleware for API responses",
      "json_parsing": {
        "ijson": "#{ijson_speedup}",
        "opts": {"module_hierarchy": "Stream extraction", "mem_opt": {"stream_proc": "Constant memory", "progressive": "Batch processing"}}
      },
      "retry": "Tenacity with exponential backoff",
      "db_security": "Parameterized queries only",
      "input_validation": "All entry points"
    },
    "security": {
      "mcp": {
        "schema_poisoning": "p5 - Validate all schema fields",
        "param_extraction": "p5 - Allowlist vetted schemas",
        "production": {"error_masking": "mask_error_details=True", "allowlisting": "Tool schema validation"}
      }
    },
    "deployment": {
      "zero_install": "uvx --from git+URL docsrs-mcp",
      "container": "Multi-stage Docker builds",
      "cicd": {
        "github": {
          "uv_setup": "hynek/setup-uv@v2",
          "perf": {"cache_opt": "~/.cache/uv caching", "cache_key": "uv.lock hash"},
          "publishing": "PyPI via trusted publishing",
          "platforms": {"windows": "Separate workflow branch"}
        }
      }
    },
    "tooling": {
      "uv": {
        "ver": "0.3.0+",
        "commands": {
          "dev_setup": "uv sync --dev",
          "run_module": "uv run python -m module", 
          "test": "uv run pytest",
          "add_dep": "uv add package",
          "add_dev": "uv add --dev package"
        },
        "project": "pyproject.toml-based",
        "deploy": {
          "uvx": {"test_local": "uvx --from . docsrs-mcp", "test_git": "uvx --from git+URL"}
        }
      },
      "ruff": {
        "ver": "0.5.0+",
        "replaces": ["black", "flake8", "pylint", "isort", "autopep8"],
        "commands": {"lint": "uv run ruff check", "format": "uv run ruff format", "fix": "uv run ruff check --fix"},
        "cfg": "pyproject.toml [tool.ruff]",
        "consolidation": "Single Rust-based tool"
      },
      "best_practices": {
        "string_iter": {
          "type_check": "isinstance(obj, str) - 88% adoption",
          "perf": {"python312": "2-20x isinstance() speedup", "word_level": "7x vs char-level"},
          "pitfalls": {"string_iter": "Wrap single strings in lists", "char_fragment": "p6 - Prevent unintended iteration"}
        },
        "cache_mgmt": {
          "priority_queues": "heapq [priority, counter, item]",
          "eviction": {"lru": "functools.lru_cache", "hybrid_lru": "LRU + priority", "log_scale": "Prevent extreme differences"},
          "python_opts": {"os_walk": "Python 3.5+ scandir integration", "size_limits": "Prevent unbounded growth", "functools_limits": "Avoid for complex eviction"}
        }
      }
    },
    "query_preprocessing": {
      "unicode_norm": {
        "method": "unicodedata.normalize('NFKC')",
        "perf": "<1ms overhead C-optimized",
        "cases": {"accented": "Café → Cafe", "compat": "Compatibility chars", "composed": "Multi-char normalization", "ligatures": "ﬁ → fi"},
        "alternatives": {"nfc": "Canonical composition", "nfd": "Canonical decomposition", "nfkd": "Compatibility decomposition"},
        "guideline": "First step in preprocessing pipeline"
      },
      "pydantic_val": {
        "field_vals": "@field_validator mode='before'",
        "pipeline": "Unicode norm → length check → content validation",
        "best_practices": {
          "type_flex": "Accept str/bytes input",
          "errors": "Specific actionable messages",
          "defaults": "None handling",
          "perf": "Precompiled patterns"
        },
        "integration": "Preprocessing + validation single step"
      },
      "perf_chars": {
        "norm_overhead": "<1ms per query",
        "validation": "<0.1ms typical",
        "memory": "Minimal impact",
        "concurrency": "Thread-safe operations"
      },
      "best_practices": {
        "query_val": {"length": "1-500 chars", "char_val": "Unicode categories", "sanitization": "XSS prevention"},
        "error_handling": {"validation": "Field-specific errors", "graceful": "Fallback processing"},
        "testing": "Unicode edge cases + international chars",
        "monitoring": "Preprocessing latency + success rates"
      },
      "findings": {
        "optimal": "NFKC normalization + Pydantic integration",
        "real_world": "Handles international queries effectively",
        "production": "Sub-millisecond processing reliable"
      },
      "rapidfuzz": {
        "ver": "#{rapidfuzz}",
        "perf": "4000%+ speedup over FuzzyWuzzy (#{rapidfuzz_speedup})",
        "breaking": "v3.0 API changes",
        "fuzzy_thresh": "60% optimal threshold",
        "algorithms": {
          "token_set_ratio": "Best for handling subsets in path matching",
          "token_sort_ratio": "Handles word order variations effectively", 
          "partial_ratio": "Excellent for substring matching"
        },
        "v3_requirements": {
          "preprocessing": "Explicit preprocessing with utils.default_process required",
          "unicode_norm": "No built-in Unicode normalization - must use unicodedata.normalize('NFC')"
        },
        "fuzzy_normalization": {
          "purpose": "Handle British/American English spelling variations",
          "patterns": {
            "ise_to_ize": "serialise → serialize, realise → realize",
            "our_to_or": "colour → color, honour → honor",
            "re_to_er": "centre → center, theatre → theater"
          },
          "implementation": {
            "regex_based": "Word boundary matching only",
            "case_preservation": "Maintains original case patterns",
            "performance": "<1ms overhead per query",
            "integration": "Pydantic field validator with mode='before'"
          },
          "benefits": {
            "search_consistency": "Unified American spelling for embedding consistency",
            "user_experience": "Accepts both British and American spellings",
            "no_database_changes": "Applied at query preprocessing only"
          }
        },
        "best_practices": {
          "thresh_select": "Dataset-specific optimization",
          "suggestion_count": "3-5 cognitive limit",
          "edit_distance": "Levenshtein + variants",
          "scoring": "Normalized 0-100 scale",
          "caching": "TTL-based for performance",
          "composite_scoring": "Multiple algorithms improve accuracy",
          "position_aware": "Word boundary bonuses enhance relevance",
          "adaptive_thresholds": "Query length-based reduces false positives"
        },
        "insights": {
          "multiproc": "Avoid - overhead outweighs benefits",
          "explicit": "Direct processing preferred",
          "score_norm": "Consistent 0-100 scaling",
          "performance_finding": "RapidFuzz 3.13.0 delivers exceptional performance gains without NumPy dependency since sqlite-vec handles vector operations efficiently"
        }
      },
      "mcp_manifest": {
        "boolean_params": {
          "anyof": "MANDATORY pattern",
          "pydantic_val": "mode='before' coercion",
          "string_to_bool": "Handle client inconsistencies"
        },
        "param_flex": {"union_types": "Union[str, int] patterns", "anyof": "JSON Schema generation"}
      },
      "path_resolution": {
        "fuzzy_integration": {"thresh": "60% similarity", "strategy": "Exact → case-insensitive → fuzzy"},
        "doc_systems": {"norm": "Path standardization", "hierarchical": "Tree structure matching", "contextual": "Relevance scoring"},
        "alias_resolution": {
          "perf": "Sub-second response times",
          "dependency": "Module relationship optimization",
          "rust_patterns": "pub use, mod declarations",
          "impl_strategy": "Discovery source prioritization",
          "rust_aliases": {
            "patterns": "std::collections::HashMap vs HashMap",
            "impl": "Path alias database",
            "discovery": "rustdoc JSON + manifest analysis"
          }
        }
      },
      "rapidfuzz_opt": {"bulk_thresh": "60% optimal", "strategies": "SIMD acceleration"},
      "structure_preservation": {
        "markitdown": "Microsoft text extraction",
        "pdf_convert": "Structured content preservation", 
        "terminal": "ANSI code handling"
      },
      "cross_refs": {"sphinx": "Domain-specific references", "mkdocstrings": "API documentation links"}
    },
    "code_extraction": {
      "current": "Regex-based with performance issues",
      "recommended": {
        "tree_sitter": "#{treesitter_speedup} + language awareness"
      },
      "macro_extraction": {
        "enhanced_extractor": {
          "class": "EnhancedMacroExtractor",
          "purpose": "Advanced macro extraction from Rust source code",
          "patterns": {
            "declarative": "macro_rules! with fragment specifiers",
            "procedural": "#[proc_macro] attribute macros",
            "derive": "#[proc_macro_derive] custom derive macros", 
            "attribute": "#[proc_macro_attribute] function-like macros"
          },
          "fragment_specifiers": ["expr", "ident", "pat", "ty", "stmt", "block", "item", "meta", "tt", "vis", "literal", "path"],
          "validation": {
            "lazy_static": "4 macros extracted successfully",
            "serde_derive": "5 macros extracted successfully",
            "anyhow": "15 macros extracted successfully"
          },
          "implementation": "Python-based regex extraction with comprehensive pattern matching"
        }
      }
    },
    "memory_mgmt_detailed": {
      "streaming": {"ijson": "#{ijson_speedup}"},
      "generators": "#{memory_efficiency} improvement",
      "batch_proc": "#{batch_size_optimal} optimal size",
      "sqlite_constraints": {
        "unique_add": "p2 - Requires 12-step rebuild procedure"
      },
      "monitoring": {"thresh": "#{warning_threshold}%/#{critical_threshold}%"}
    },
    "mcp_best_practices": {
      "tool_desc": "p8 - Token efficiency",
      "parameter_handling": "MANDATORY anyOf patterns",
      "transport_reqs": "STDIO for Claude Desktop"
    },
    "best_practices": {
      "project_cfg": {
        "pyproject": "Modern Python packaging",
        "semver": "Strict version management"
      },
      "operational_docs": {"perf": "Sub-500ms targets"}
    },
    "known_issues": {
      "pkg_dist": {"pypi_readme": "Markdown rendering limitations"}
    },
    "crate_pre_ingestion": {
      "reactive_caching": "Demand-driven approach",
      "selective_loading": "Priority-based",
      "background": {"priority_queues": "Download count ordering"},
      "non_blocking": "Startup optimization",
      "rate_limiting": {"upstream": "Respect API limits"},
      "cdn_edge": "Geographic optimization",
      "cratesio_api": {
        "rate_limit": "30 req/burst",
        "response": "JSON metadata",
        "client": "aiohttp connection pooling"
      },
      "binary_serial": {
        "format": "msgpack vs pickle",
        "perf": "25x faster loads (50ms→2ms)",
        "compat": "Version handling"
      },
      "connection_pool": {
        "optimal": {"limit": 100, "limit_per_host": 10},
        "perf": "Connection reuse efficiency",
        "comparison": "aiohttp vs httpx"
      },
      "cache_patterns": {
        "ttl": "24h popular crates",
        "stale_revalidate": "75% threshold",
        "atomic_writes": "temp + rename pattern",
        "concurrency": "filelock coordination"
      },
      "memory_mgmt": {
        "monitoring": "psutil integration",
        "adaptive": "900MB threshold",
        "priority": "Download count ordering"
      }
    },
    "asyncio_task_mgmt": {
      "task_refs": {
        "weak_refs": "Prevent GC issues",
        "task_group": "Python 3.11+ structured concurrency",
        "eager_tasks": "Python 3.12 perf improvement"
      },
      "memory_mgmt": {"monitoring": "psutil integration", "thresh": "#{warning_threshold}%"},
      "sched_patterns": {
        "interval": {"jitter": "±10% thundering herd prevention", "simple": "asyncio.sleep()"},
        "complex": "APScheduler for cron patterns"
      },
      "fastapi": {
        "background": {
          "resource_sep": "Avoid contention",
          "non_blocking": "Server responsiveness",
          "duplicate_prevent": {"force_param": "Override existing tasks"},
          "error_isolation": "Prevent startup failures"
        }
      },
      "best_practices": [
        "Strong task references with background_tasks.add()",
        "Cleanup with task.add_done_callback()",
        "Separate resource instances for background tasks",
        "Python 3.12+ for eager task performance"
      ]
    },
    "mcp_tool_opt": {
      "token_efficient": {"desc": "50-125 chars", "examples": "Concrete usage demonstrations"},
      "action_oriented": "Verb-noun combinations",
      "json_schema": {
        "guidelines": ["Minimize nested depth", "additionalProperties: false", "Provide defaults", "Use examples"],
        "opt": ["format for semantic validation", "Minimize object nesting", "Parameter drift prevention"]
      },
      "three_tier": {
        "tier1": "Tool name 2-4 words",
        "tier2": "Description 50-125 chars",
        "tier3": "Parameters 20-80 chars each"
      },
      "naming": {
        "params": ["Semantic names", "Type hints in naming", "Consistent patterns", "Avoid abbreviations"],
        "tools": ["Verb-noun combos", "Namespace prefixes", "Consistent families"]
      },
      "tutorial": {
        "quickstart": ["Purpose statement", "Required params only", "Expected output", "Concrete example"],
        "patterns": {"org": "Group related patterns", "progression": "Simple→advanced", "errors": "Common conditions", "practices": "Optimal usage"}
      }
    },
    "token_optimization": {
      "counting_libraries": {
        "tiktoken": {
          "ver": "0.11.0",
          "purpose": "Standard OpenAI token counting library",
          "encoding": "cl100k_base for GPT-4 models",
          "performance_warning": "Stack overflow risk with >100k character inputs",
          "best_practice": "Truncate text before tokenization to avoid performance issues"
        },
        "character_estimation": {
          "fallback_ratio": "1 token ≈ 4 characters",
          "accuracy": "Approximate - varies by language and content type",
          "use_case": "Quick estimation when tiktoken unavailable"
        }
      },
      "optimization_strategies": {
        "writing_patterns": {
          "bullet_points": "Reduce token count vs paragraph format",
          "technical_abbreviations": "Use standard abbreviations when clear",
          "imperative_voice": "More concise than descriptive prose"
        },
        "content_structuring": {
          "hierarchical": "Use headers and sections for scanability",
          "key_information_first": "Front-load critical details",
          "eliminate_redundancy": "Remove repeated information"
        }
      },
      "mcp_manifest_issues": {
        "token_overflow": {
          "range": "23K-93K tokens for large responses",
          "cause": "Extensive tool manifests with detailed schemas",
          "mitigation": "Optimize tool descriptions and parameter documentation"
        },
        "best_practices": {
          "description_length": "50-125 characters per tool description",
          "parameter_docs": "20-80 characters per parameter",
          "tutorial_limits": "200-token limit per tutorial section"
        }
      },
      "performance_considerations": {
        "tiktoken_limitations": "Memory and CPU intensive for large inputs",
        "preprocessing": "Apply truncation before token counting",
        "caching": "Cache token counts for frequently processed content",
        "monitoring": "Track token usage to identify optimization opportunities"
      }
    },
    "mcp_documentation": {
      "protocol_principles": {
        "api_design": "Token-efficient, self-documenting APIs with JSON schemas",
        "structured_outputs": "100% format consistency best practice",
        "token_optimization": "60% usage reduction through concise, focused content",
        "tutorial_embedding": "Industry standard: tutorials in tool schemas as additive metadata"
      },
      "semantic_search": {
        "embedding_model": "BAAI/bge-small-en-v1.5",
        "performance": "<50ms warm searches",
        "optimization": "Token context window exhaustion mitigation"
      },
      "common_issues": {
        "token_limits": "200-token limit per tutorial prevents context window exhaustion",
        "type_coercion": "JSON Schema anyOf patterns handle MCP client type coercion requirements"
      },
      "sources": {
        "primary": ["Model Context Protocol specification", "OpenAI Platform Documentation on Structured Outputs"],
        "industry": "AI agent documentation best practices"
      }
    },
    "version_diff": {
      "semantic_comparison": {
        "purpose": "Compare documentation changes between crate versions for Rust coding agents",
        "optimization": "Hash-based comparison for efficient change detection",
        "performance": "Sub-500ms for cached comparisons, 10-30s for initial ingestion",
        "target_audience": "Rust coding agents understanding API evolution"
      },
      "breaking_change_detection": {
        "framework": "Rust RFC 1105 semver guidelines compliance",
        "categories": {
          "added": "New items introduced (non-breaking)",
          "removed": "Items deleted (potential breaking change)", 
          "modified": "Items with signature or behavior changes",
          "deprecated": "Items marked as deprecated"
        },
        "migration_hints": "Contextual guidance for handling breaking changes",
        "semver_analysis": "Automatic breaking change identification"
      },
      "implementation": {
        "engine": "VersionDiffEngine with LRU caching",
        "detector": "RustBreakingChangeDetector for semver analysis", 
        "endpoint": "/mcp/tools/compare_versions accessible via REST API and MCP",
        "caching_strategy": "LRU cache with configurable size limits"
      },
      "performance_characteristics": {
        "cached_comparison": "<500ms response time",
        "initial_ingestion": "10-30s for version processing",
        "memory_usage": "<1GB with streaming processing",
        "cache_eviction": "LRU-based with configurable limits",
        "priority_scoring_optimization": {
          "lru_enhancement": "LRU cache with priority scoring improves retention of popular crates",
          "scoring_factors": "Download frequency, search relevance, and recency combined for intelligent eviction",
          "performance_impact": "Priority-aware caching reduces cache misses for frequently accessed crates"
        }
      },
      "tested_implementations": {
        "validation_crates": ["serde", "once_cell", "anyhow"],
        "test_scenarios": {
          "serde": "Major version transitions with breaking changes",
          "once_cell": "API evolution and deprecation patterns",
          "anyhow": "Error handling pattern changes"
        },
        "success_criteria": "Accurate breaking change detection and migration guidance"
      },
      "design_decisions": {
        "hash_vs_ast": "Hash-based detection chosen over AST comparison for performance",
        "caching_strategy": "LRU caching balances memory usage with response time",
        "semver_compliance": "Follows Rust RFC 1105 semver guidelines",
        "response_format": "JSON optimized for programmatic consumption by coding agents"
      },
      "integration_patterns": {
        "mcp_tool": "Native MCP tool endpoint with structured parameters",
        "rest_api": "Available in both MCP and REST modes",
        "error_handling": "Graceful fallback for missing versions",
        "rate_limiting": "Subject to standard API rate limits"
      }
    },
    "phase_3_optimization_research": {
      "research_date": "2025-08-23",
      "context": "Performance optimization discoveries for Phase 3 implementation",
      "overview": "Comprehensive research on search optimization, security, and performance enhancements",
      "rapidfuzz_optimization": {
        "version": "3.13.0",
        "simd_optimizations": {
          "desc": "SIMD optimizations provide significant memory reduction",
          "memory_improvement": "10x memory reduction vs previous versions",
          "performance_impact": "Maintains 4000%+ speedup over FuzzyWuzzy baseline",
          "implementation": "Built-in SIMD acceleration automatically leveraged"
        },
        "prefix_matching": {
          "desc": "Prefix matching reduces fuzzy search scope significantly",
          "scope_reduction": "60-80% reduction in search space",
          "strategy": "Filter candidates by prefix before fuzzy scoring",
          "performance_gain": "Substantial latency reduction for large datasets"
        },
        "score_cutoff": {
          "desc": "Score cutoff enables early termination in RapidFuzz",
          "benefit": "Prevents processing of low-relevance candidates",
          "implementation": "Set minimum score threshold for result inclusion",
          "optimization": "Early termination improves worst-case performance"
        }
      },
      "regex_security": {
        "google_re2": {
          "desc": "Linear-time regex guarantees but Python built-in sufficient",
          "assessment": "google-re2 offers guaranteed linear time complexity",
          "decision": "Python's built-in re with timeout is sufficient for current needs",
          "rationale": "Timeout-based protection adequate without additional dependency"
        },
        "redos_protection": {
          "desc": "ReDoS patterns must be detected before compilation",
          "strategy": "Pattern complexity analysis prevents nested quantifiers",
          "implementation": "Analyze regex patterns for dangerous constructs",
          "prevention": "Block or rewrite patterns with exponential complexity"
        },
        "signal_timeouts": {
          "desc": "Signal-based timeouts effective for regex protection",
          "mechanism": "Unix signal interruption for long-running regex operations",
          "reliability": "Prevents regex DoS attacks through timeout enforcement",
          "fallback": "Graceful handling of interrupted operations"
        }
      },
      "sqlite_vec_advances": {
        "version": "0.1.0",
        "stability": "Stable release enables hybrid search capabilities",
        "hybrid_search": {
          "desc": "Combination of vector similarity and traditional text search",
          "capability": "Cross-crate result aggregation using RRF algorithm",
          "performance": "Maintains <100ms query time for 1M+ vectors",
          "scalability": "SIMD acceleration supports large-scale deployments"
        },
        "rrf_algorithm": {
          "desc": "Reciprocal Rank Fusion effective for cross-crate result aggregation",
          "formula": "RRF score = sum(1/(k + rank_i)) for all ranking lists",
          "benefit": "Combines multiple ranking signals without score normalization",
          "implementation": "Aggregates vector and metadata rankings effectively"
        },
        "database_optimization": {
          "partial_indices": {
            "desc": "Partial database indices optimize stability filtering",
            "strategy": "Create indices on filtered subsets of data",
            "performance": "Improves WHERE clause performance on large datasets",
            "maintenance": "Reduced index maintenance overhead"
          },
          "connection_pooling": {
            "desc": "Connection pooling improves cross-crate search performance",
            "benefit": "Reduces connection overhead for multiple queries",
            "implementation": "Persistent connection pool for database operations",
            "scaling": "Better resource utilization under load"
          }
        }
      },
      "performance_benchmarks": {
        "prefix_optimization": "60-80% search scope reduction",
        "memory_efficiency": "10x improvement with RapidFuzz 3.13.0 SIMD",
        "early_termination": "Score cutoff enables performance guarantees",
        "hybrid_search_latency": "<100ms with sqlite-vec 0.1.0 stable",
        "rrf_overhead": "Minimal additional latency for result fusion",
        "connection_pooling": "Improved throughput for concurrent operations"
      },
      "security_findings": {
        "regex_timeout": "Signal-based protection sufficient for ReDoS prevention",
        "pattern_analysis": "Pre-compilation validation prevents dangerous constructs",
        "linear_guarantees": "Built-in timeout mechanism adequate vs google-re2 dependency"
      },
      "implementation_priorities": {
        "high": ["RapidFuzz 3.13.0 SIMD optimization", "Prefix matching optimization", "Score cutoff implementation"],
        "medium": ["RRF algorithm for hybrid search", "Partial database indices", "Connection pooling"],
        "low": ["Advanced ReDoS protection", "google-re2 evaluation for future needs"]
      }
    },
    "critical_bugs": {
      "crate_name_unwind_bug": {
        "desc": "getCrateSummary tool missing from tools_to_fix dictionary causes parameter processing failures",
        "problem": "All crates appear named 'unwind' in MCP mode due to missing schema override",
        "root_cause": "getCrateSummary tool not included in FastMCP schema override dictionary",
        "solution": "Add getCrateSummary to schema override dictionary with string-only parameters",
        "impact": "Incorrect crate identification in MCP client interactions",
        "frequency": "100% of getCrateSummary calls in MCP mode",
        "resolution_status": "Fixed by adding tool to tools_to_fix dictionary"
      },
      "version_comparison_nonetype": {
        "desc": "AttributeError when semantic_changes contains None values during string operations",
        "problem": "semantic_changes.join().lower() fails with NoneType in list",
        "root_cause": "Version comparison function receives None values from upstream processing",
        "solution": "Defensive programming with None checks before string operations",
        "pattern": "(value or '').lower() for safe string operations",
        "impact": "Runtime crashes during version diff generation",
        "frequency": "Occurs with specific crate version combinations"
      },
      "pre_ingestion_validation": {
        "desc": "MCP client validation failures despite correct anyOf patterns in schemas", 
        "problem": "Real MCP clients reject valid requests that pass unit tests",
        "root_cause": "Discrepancy between FastMCP validation and actual MCP client implementation",
        "manifestation": "422 Unprocessable Entity responses from MCP protocol layer",
        "testing_gap": "Unit tests insufficient - require actual MCP client testing",
        "solution": "Test with real MCP clients, not just synthetic test suites",
        "validation_patterns": "Double validation creates inconsistent behavior"
      },
      "standard_library_support": {
        "desc": "Incomplete path resolution for Rust standard library functions and types",
        "problem": "Some std library items not found in documentation searches",
        "manifestation": "Empty results for valid std library queries",
        "root_cause": "Path resolution algorithm incomplete for stdlib edge cases",
        "impact": "Reduced search coverage for fundamental Rust concepts",
        "workaround": "Manual fallback to latest version resolution"
      },
      "mcp_manifest_validation": {
        "desc": "Validation error patterns in MCP manifest generation and processing",
        "problem": "Inconsistent validation behavior between development and production",
        "error_patterns": [
          "Parameter type coercion failures",
          "anyOf schema validation mismatches",
          "Field validator exceptions not properly handled"
        ],
        "debugging_challenges": "Error messages lack specificity for troubleshooting",
        "solution": "Enhanced error reporting with field-specific context"
      },
      "pre_ingestion_mcp_control": {
        "desc": "Health endpoints misleadingly show 'not_initialized' when disabled by default",
        "problem": "CLI flag dependency conflicts with MCP-first approach causing incorrect status messages",
        "root_cause": "Default disable_pre_ingestion=True conflicts with health endpoint status reporting",
        "manifestation": "Users receive 'not_initialized' status even when system is functioning correctly",
        "impact": "Confusing user experience and incorrect system status reporting",
        "solution": "Remove CLI dependency and fix status message logic for MCP mode"
      },
      "ingestion_completion_tracking": {
        "desc": "System only checks file existence, not actual completion status",
        "problem": "Incomplete ingestion reported as complete leading to partial failure scenarios",
        "partial_failure_points": [
          "rustdoc download interruption",
          "JSON parsing errors", 
          "embedding generation failures",
          "cross-reference processing incomplete"
        ],
        "root_cause": "Binary existence check insufficient for multi-stage ingestion process",
        "solution": "Multi-level tracking with atomic state management and completion verification",
        "impact": "Silent failures and inconsistent search results"
      },
      "fallback_ingestion_schema": {
        "desc": "Tier 2/3 ingestion produces degraded schema missing critical fields",
        "problem": "Version comparison fails with 'insufficient documentation' due to schema gaps",
        "missing_fields": ["generic_params", "trait_bounds", "parent_id"],
        "root_cause": "Simplified AST parsing for fallback sources omits complex type information",
        "impact": "Reduced comparison accuracy and incomplete version diff analysis",
        "solution": "Enhanced AST parsing and schema standardization across all ingestion tiers"
      }
    },
    "configuration_as_data": {
      "overview": "Critical architectural pattern discovered during FastAPI refactoring - separating configuration data from business logic",
      "research_date": "2025-08-23",
      "context": "Investigation during massive code size reduction in MCP server refactoring",
      "key_findings": {
        "inline_configuration_bloat": {
          "description": "Large inline JSON/dictionary structures cause massive code bloat in function implementations",
          "evidence": "get_mcp_manifest function was 273 lines primarily due to hardcoded MCP tool definitions",
          "impact": "Single function contained 9 tools × 30 lines = 270 lines of configuration data",
          "solution": "Extract configuration to dedicated modules"
        },
        "file_size_analysis_insights": {
          "original_problem": "app.py was 981 lines, refactored endpoints.py grew to 1070 lines",
          "root_cause": "Inline configuration bloat, not logic complexity - tool schemas dominated line count",
          "post_extraction": "endpoints.py reduced to 516 lines after configuration extraction",
          "lesson": "Large data structures count toward line limits just as much as complex logic"
        },
        "fastapi_schema_management": {
          "tool_definition_size": "MCP tool definitions average 20-50 lines each",
          "calculation": "9 tools × 30 lines = 270 lines of pure configuration",
          "recommendation": "Keep schemas in separate configuration modules",
          "implementation": "Use list/dict comprehensions to convert config to Pydantic models"
        }
      },
      "module_balancing_best_practices": {
        "consider_both_logic_and_data": "When splitting modules, consider both business logic complexity AND data volume",
        "configuration_counts_toward_limits": "Large data structures like JSON schemas count toward maintainability line limits",
        "related_function_grouping": "Move logically related functions together (search_items + search_examples pattern)",
        "file_size_targets": "<500 LOC files for maintainability across modules",
        "balance_principle": "Balance file sizes across modules rather than creating single large configuration dumps"
      },
      "configuration_extraction_patterns": {
        "dedicated_config_modules": {
          "purpose": "Separate configuration data from business logic implementation",
          "structure": "config/mcp_tools.py, config/api_schemas.py, config/validation_patterns.py",
          "benefits": ["Cleaner function implementations", "Easier configuration management", "Better separation of concerns"]
        },
        "data_to_model_conversion": {
          "pattern": "Use list/dict comprehensions to convert configuration to Pydantic models at runtime",
          "example": "tools = [MCPTool(**tool_config) for tool_config in MCP_TOOL_DEFINITIONS]",
          "performance": "Configuration parsed once at startup, not per request"
        },
        "configuration_organization": {
          "by_domain": "Group related configurations (search tools, ingestion tools, etc.)",
          "versioning": "Version configuration files for backward compatibility",
          "validation": "Apply Pydantic validation to configuration data itself"
        }
      },
      "refactoring_outcomes": {
        "before_extraction": {
          "get_mcp_manifest": "273 lines (mostly configuration)",
          "endpoints_py": "1070 lines (bloated with inline data)",
          "maintainability": "Poor - business logic buried in configuration"
        },
        "after_extraction": {
          "get_mcp_manifest": "~30 lines (pure logic)",
          "endpoints_py": "516 lines (clean business logic)",
          "maintainability": "Excellent - clear separation of concerns"
        },
        "line_reduction": "554 lines (52% reduction) through configuration extraction alone"
      },
      "applicability": {
        "json_api_definitions": "OpenAPI schemas, tool definitions, validation rules",
        "database_schemas": "Table definitions, migration scripts, seed data",
        "ui_configurations": "Form definitions, menu structures, component configurations", 
        "integration_mappings": "API endpoint mappings, data transformation rules, external service configurations"
      },
      "implementation_guidelines": {
        "detection_criteria": ["Functions >100 lines with >50% static data", "Repeated dictionary/list structures", "Hard-to-maintain schema definitions"],
        "extraction_process": ["Identify configuration blocks", "Extract to dedicated modules", "Create runtime conversion logic", "Validate extracted configuration"],
        "maintenance_benefits": ["Easier schema updates", "Better version control", "Cleaner code reviews", "Improved testability"]
      }
    },
    "python_dependencies_phase2": {
      "pybloomfiltermmap3_issue": {
        "version": "0.6.0",
        "python_313_incompatibility": "p15 - C extension compilation fails with Python 3.13+",
        "compilation_error": "Build tools cannot compile C extensions with newer Python versions",
        "impact": "Bloom filter-based duplicate detection unavailable",
        "alternative_implementation": {
          "approach": "Set-based duplicate detection",
          "performance": "O(1) lookup complexity maintained",
          "memory_usage": "Reasonable for moderate dependency sets",
          "serialization": "JSON format for persistence"
        },
        "future_migration_path": "Monitor library updates for Python 3.13+ compatibility"
      },
      "mmh3_hashing": {
        "version": "4.1.0",
        "purpose": "Fast hashing for bloom filter implementations",
        "compatibility": "Works with Python 3.13+",
        "performance": "Optimized hash functions for large datasets",
        "use_case": "Memory-mapped file hashing and bloom filter operations"
      },
      "priority_queue_implementation": {
        "heapq_limitations": "Min-heap only - requires negative values for max-heap",
        "asyncio_integration": "asyncio.PriorityQueue handles infinity values correctly",
        "infinity_support": "float('-inf') works for highest priority items",
        "performance_characteristics": "O(log n) insertion and O(log n) removal",
        "implementation_pattern": "Use negative priorities for max-heap behavior"
      }
    },
    "defensive_programming": {
      "null_safety": {
        "principle": "Always check for None before string operations",
        "patterns": {
          "safe_string_ops": "(value or '').lower() instead of value.lower()",
          "safe_join": "[x for x in items if x is not None] before join()",
          "safe_attribute": "getattr(obj, 'attr', default) pattern"
        },
        "examples": {
          "version_comparison": "semantic_changes = [x for x in changes if x] before join",
          "string_processing": "text = (input_text or '').strip()",
          "list_operations": "filtered = [item for item in items if item is not None]"
        }
      },
      "none_handling_best_practices": {
        "comparison_operators": {
          "pep8_requirement": "Always use 'is None' instead of '== None' for None comparisons",
          "performance": "'is None' is faster than '== None' - identity vs equality",
          "reliability": "'is None' prevents unexpected behavior with custom __eq__ methods"
        },
        "type_hints": {
          "nullable_params": "Use Optional[T] or T | None type hints to indicate nullable parameters",
          "documentation": "Type hints serve as inline documentation for None expectations",
          "static_analysis": "Enables mypy and other tools to catch None-related errors"
        },
        "error_logging": {
          "context_importance": "Log None-related errors with context using appropriate levels",
          "warning_level": "Use logging.warning() for recoverable None scenarios with fallback handling",
          "error_level": "Use logging.error() for critical None scenarios that prevent operation completion",
          "structured_logging": "Include variable names, expected types, and operation context in log messages"
        },
        "dict_operations": {
          "get_method_risk": "dict.get() can return None unexpectedly when keys are missing",
          "safe_pattern": "value = data.get('key', default_value) instead of assuming key exists",
          "validation": "Always validate dict.get() return values before use in operations"
        },
        "attribute_prevention": {
          "common_error": "Defensive programming prevents AttributeError: 'NoneType' object has no attribute",
          "guard_clauses": "Use early return patterns: if obj is None: return default_value",
          "safe_chaining": "Use getattr(obj, 'attr', None) for safe attribute access chains"
        }
      },
      "none_handling_performance": {
        "key_finding": "List comprehensions with 'is not None' checks are 40% faster than filter() for None filtering",
        "pep8_compliance": "Always use 'is None' and 'is not None' for None comparisons (PEP 8 requirement)",
        "safe_patterns": {
          "string_joins": "' '.join(x for x in items if x is not None)",
          "safe_iterations": "any(condition for x in items if x is not None)",
          "generator_efficiency": "Generator expressions inside list comprehensions avoid intermediate storage"
        },
        "performance_data": {
          "list_comprehension_speedup": "40% faster than filter() for large datasets",
          "overhead": "Minimal overhead for None filtering (negligible in sub-500ms operations)",
          "python_38_optimization": "Walrus operator can optimize repeated None checks"
        },
        "codebase_consistency": {
          "existing_pattern": "[x for x in items if x] pattern already used in validation.py and fuzzy_resolver.py",
          "applied_pattern": "Applied same defensive pattern consistently across version_diff.py and change_analyzer.py",
          "maintainability": "Consistent None handling improves code reliability and debugging"
        }
      },
      "validation_best_practices": {
        "pydantic_v2": {
          "field_validators": "Use mode='before' for defensive type coercion",
          "error_handling": "Raise ValueError, not ValidationError in validators",
          "anyof_patterns": "MANDATORY for MCP compatibility - handle client type inconsistencies",
          "testing": "Test with actual MCP clients, not just unit tests"
        },
        "mcp_protocol": {
          "parameter_flexibility": "Accept Union[str, int, bool] for all parameters",
          "client_variations": "Different MCP clients send different type formats",
          "double_validation": "Handle both FastMCP and client-side validation",
          "error_context": "Include parameter path and expected formats in errors"
        }
      },
      "sources": {
        "pydantic_v2_docs": "https://docs.pydantic.dev/latest/concepts/validators/",
        "mcp_protocol": "https://spec.modelcontextprotocol.io/specification/",
        "defensive_programming": "Code Complete, 2nd Edition - Steve McConnell",
        "rust_error_handling": "The Rust Programming Language - Error Handling Chapter"
      }
    }
  },
  "recommendations": {
    "critical": [
      "p2: Use FastMCP #{fastmcp} for MCP setup with automatic schema generation from type hints",
      "p2: Route logging to stderr for STDIO transport",
      "p2: Use #{sqlitevec} (sqlite-vss deprecated)",
      "p2: Pin aiohttp to #{aiohttp} (memory leak mitigation)",
      "p2: Monitor FastEmbed #{fastembed} memory leaks 1.5GB→16GB",
      "p2: Use anyOf patterns for MCP numeric/boolean params",
      "p2: Adding UNIQUE constraints requires 12-step rebuild",
      "p2: Use ijson #{ijson} with yajl2_c backend for #{ijson_speedup}",
      "p2: Use tree-sitter for #{treesitter_speedup} code extraction",
      "p2: Maintain strong asyncio task references",
      "p2: Truncate text inputs before tiktoken processing to prevent stack overflow",
      "p2: Monitor MCP manifest token usage to prevent 23K-93K token overflow",
      "p2: Always check for None before string operations - use (value or '').lower() pattern",
      "p2: Test MCP validation with actual clients, not just unit tests",
      "p2: Implement defensive programming patterns for NoneType handling",
      "p2: Use field validators with mode='before' for MCP client compatibility",
      "p2: Use isinstance(v, bool) fast path in Pydantic boolean validators for MCP parameter compatibility",
      "p2: Implement lookup tables for boolean validation - 10x performance improvement over string parsing",
      "p2: Support comprehensive boolean string representations: true/false, 1/0, yes/no, on/off, enabled/disabled",
      "p2: Use FastMCP 2.11.3 automatic schema generation with Pydantic integration for type safety",
      "p2: Address Claude Code parameter serialization bug that causes failures after first MCP call",
      "p2: Standard library rustdoc JSON unavailable on docs.rs - implement fallback for std/core/alloc crates",
      "p2: Inform users to install rust-docs-json component via rustup for complete stdlib documentation",
      "p15: Use set-based implementation as alternative to pybloomfiltermmap3 for Python 3.13+ compatibility",
      "p16: Implement cross-platform rustup detection for Windows, macOS, Linux, and WSL environments",
      "p17: No JSON API available from rust-lang.org - local rustup is only reliable stdlib JSON source",
      "p18: Use negative values in Python heapq for max-heap priority queue behavior",
      "p19: Apply memory-mapped files and mmh3 hashing for efficient bloom filter operations",
      "p2: Claude Code has NO anyOf schema support - use string-only parameters for maximum compatibility",
      "p2: Avoid anyOf patterns in MCP schemas due to inconsistent client support",
      "p2: Provide examples arrays and format hints in all MCP parameter schemas",
      "p2: FastMCP double validation (JSON Schema → Pydantic) requires optimized field validators",
      "p2: Use FastMCP schema override pattern to bypass client validation limitations while preserving type safety",
      "p2: Add getCrateSummary to schema override dictionary to fix crate name 'unwind' bug in MCP mode",
      "p2: Implement universal auto-ingestion audit to ensure 100% tool coverage",
      "p2: Replace binary existence checks with multi-level ingestion completion tracking",
      "p2: Remove CLI flag dependency from health endpoint status reporting in MCP mode",
      "p2: Enhance Tier 2/3 fallback ingestion with complete schema standardization including generic_params and trait_bounds",
      "p11: Extract large configuration data (JSON schemas, tool definitions) to dedicated modules to prevent code bloat",
      "p11: Consider both logic AND data volume when splitting modules - configuration counts toward line limits",
      "p13: Use APIRouter for FastAPI modularization to avoid circular import issues",
      "p11: Maintain <500 LOC files and group related endpoints in separate router modules",
      "p14: Apply facade pattern with re-exports for backward compatibility during refactoring",
      "p12: Use TYPE_CHECKING pattern and lazy imports to optimize application startup time",
      "p2: Use ijson with yajl2_c backend for optimal streaming JSON parsing performance (1329K objects/sec)",
      "p2: Apply sqlite_vec.serialize_float32() for proper embedding storage in SQLite vector tables",
      "p2: Implement LRU cache with priority scoring to improve retention of popular crates",
      "p2: Configure ONNX runtime with arena settings to optimize memory usage during embedding generation",
      "p2: Use dependency injection patterns with TYPE_CHECKING to prevent circular imports in modular Python architectures",
      "p2: Implement adaptive batch processing with memory pressure monitoring for stable large dataset ingestion",
      "p2: Enforce snake_case field naming in Pydantic models for FastAPI integration compatibility"
    ],
    "performance": [
      "#{sqlite_vec_query} with sqlite-vec",
      "4000%+ speedup with RapidFuzz 3.13.0 over FuzzyWuzzy alternatives", 
      "#{memory_efficiency} with generator patterns",
      "Semantic chunking 50-200 tokens",
      "FastEmbed batch sizes: CPU=16, GPU=256, general=32",
      "#{batch_size_optimal} records per database transaction",
      "Use exact→case-insensitive→fuzzy matching hierarchy",
      "60% similarity threshold optimal for fuzzy matching",
      "Sub-500ms search response targets with MMR diversification",
      "Implement hybrid LRU+priority caching",
      "Use SIMD optimizations in RapidFuzz and sqlite-vec",
      "MMR λ=0.6 provides optimal relevance-diversity balance",
      "Dynamic fetch_k adjustment based on filter selectivity improves performance",
      "Fuzzy normalization handles British/American spellings with <1ms overhead",
      "RapidFuzz 3.13.0 SIMD provides 10x memory reduction over previous versions",
      "Prefix matching reduces fuzzy search scope by 60-80% for better performance",
      "Score cutoff enables early termination in RapidFuzz for optimal worst-case performance",
      "Reciprocal Rank Fusion (RRF) effective for cross-crate result aggregation with minimal overhead",
      "Partial database indices optimize stability filtering on large datasets",
      "Connection pooling improves cross-crate search performance under concurrent load",
      "sqlite-vec 0.1.0 stable release enables hybrid search with <100ms query times",
      "Signal-based timeouts provide adequate ReDoS protection without google-re2 dependency",
      "List comprehensions with None filtering provide 40% speedup over filter() function",
      "Generator expressions avoid intermediate storage for memory-efficient None handling",
      "ijson with yajl2_c backend delivers 1329K objects/sec streaming JSON parsing performance",
      "LRU cache with priority scoring reduces cache misses for frequently accessed crates",
      "Adaptive batch sizing prevents memory exhaustion during large dataset processing",
      "ONNX arena configuration optimizes memory footprint for batch embedding operations"
    ],
    "implementation": [
      "Pydantic mode='before' validators for type coercion",
      "Union types for flexible parameter acceptance",
      "Streaming JSON parsing for large rustdoc files",
      "Connection pooling from project start",
      "SlowAPI decorator-based rate limiting",
      "Per-crate locking for ingestion",
      "Recursive CTEs for tree traversal",
      "Hash-based deduplication strategies",
      "Background task separation for resource isolation",
      "Configuration extraction to dedicated modules for large data structures (MCP tool definitions, API schemas)",
      "List/dict comprehensions for runtime configuration-to-Pydantic model conversion",
      "APIRouter-based modularization to prevent circular imports",
      "Router separation for logical endpoint grouping and independent middleware",
      "Facade pattern with re-exports for backward compatibility during refactoring",
      "TYPE_CHECKING imports for reduced runtime overhead with heavy dependencies",
      "Lazy imports for ONNX models and database operations to improve startup time",
      "Strategic __all__ usage for clean public API control in modules",
      "Snake_case field naming in Pydantic models for FastAPI compatibility",
      "<500 LOC file size limits for maintainable FastAPI application structure",
      "Cross-cutting concern extraction to dedicated middleware modules",
      "ConfigDict(extra='forbid') for strict validation",
      "ValueError exceptions in field validators, not ValidationError",
      "FastAPI RequestValidationError handlers for custom error formatting",
      "Precompile error templates and regex patterns for performance",
      "Include field path, message, type, and context in error responses",
      "Use structured outputs for 100% format consistency in MCP tools",
      "Embed tutorials directly in JSON schemas as additive metadata",
      "Apply 200-token limit per tutorial to prevent context window exhaustion",
      "Use BAAI/bge-small-en-v1.5 embeddings for <50ms semantic search performance",
      "Implement MMR diversification with λ=0.6 and diversity_weight=0.1 for balanced results",
      "Apply fuzzy normalization in Pydantic field validators for query preprocessing",
      "Use regex-based word boundary matching for spelling normalization",
      "Configure dynamic fetch_k with 1.5x multiplier when MMR is enabled",
      "Maintain <500ms P95 latency with all ranking optimizations enabled",
      "Use tiktoken 0.11.0 with cl100k_base encoding for accurate GPT-4 token counting",
      "Apply 1 token ≈ 4 characters estimation as fallback for quick calculations", 
      "Implement text truncation before tiktoken processing to prevent performance issues",
      "Use bullet points and imperative voice for token-efficient documentation",
      "Cache token counts for frequently processed content to improve performance",
      "Filter None values from lists before join operations: [x for x in items if x]",
      "Use (value or '').method() pattern for safe string operations",
      "Implement getattr(obj, 'attr', default) for safe attribute access",
      "Prefer list comprehensions over filter() for None filtering (40% performance improvement)",
      "Use 'is None' and 'is not None' for None comparisons per PEP 8 requirements",
      "Apply generator expressions inside list comprehensions to avoid intermediate storage",
      "Use ' '.join(x for x in items if x is not None) pattern for safe string joins",
      "Implement any(condition for x in items if x is not None) for safe iterations",
      "Test Pydantic validators with actual MCP client data, not synthetic tests",
      "Use Union[str, int, bool] parameters for MCP client type flexibility",
      "Include parameter path and expected formats in validation error messages",
      "Use isinstance(v, bool) fast path followed by string validation in Pydantic boolean validators",
      "Accept standard truthy strings ('true', '1', 'yes', 'on') case-insensitively for MCP compatibility",
      "Return False as default for invalid/None inputs in boolean validators for consistency",
      "Use 'is None' instead of '== None' for PEP 8 compliant None comparisons (faster, more reliable)",
      "Add Optional[T] or T | None type hints to indicate nullable parameters for better documentation",
      "Log None-related errors with appropriate levels: warning for recoverable, error for critical scenarios",
      "Validate dict.get() return values before operations as keys may be missing unexpectedly",
      "Use guard clauses and getattr() patterns to prevent AttributeError: 'NoneType' object has no attribute",
      "Use string-only MCP parameters with Pydantic field validators for maximum client compatibility",
      "Implement isinstance() fast paths in field validators to optimize FastMCP's double validation",
      "Include concrete examples in JSON Schema parameter definitions for better client understanding",
      "Test MCP tools with actual clients (Claude Code, Claude Desktop) not just unit tests",
      "Handle MCP Inspector UI null values gracefully in parameter validation logic",
      "Apply FastMCP schema override technique: modify _tool_manager schemas to string-only types post-generation",
      "Leverage FastMCP's lenient JSON Schema validation that accepts type mismatches for better client compatibility",
      "Include all MCP tools in schema override dictionary to prevent parameter processing failures",
      "Implement systematic tool audit with ingest_crate() verification across all MCP endpoints",
      "Use atomic state management for ingestion completion tracking beyond simple file existence",
      "Standardize schema across all ingestion tiers to maintain version comparison accuracy",
      "Implement completion verification at each ingestion stage: download, parse, embed, cross-reference",
      "Use Ajv with compiled schemas for high-performance JSON Schema validation",
      "Implement application-layer validation separate from JSON Schema structure validation",
      "Use cargo-modules for workspace-aware Rust module dependency analysis",
      "Apply petgraph algorithms for efficient module relationship traversal",
      "Integrate HIR-based semantic analysis for type system navigation",
      "Use tower-lsp async handlers with proper capability negotiation",
      "Implement CancellationToken patterns for cooperative LSP operation cancellation",
      "Apply progressive timeout strategies for complex LSP analysis operations",
      "Use rustup rust-docs-json component for complete standard library JSON access",
      "Implement structured error responses with field-level context for validation failures",
      "Use ijson streaming parser with yajl2_c backend for optimal large file processing performance",
      "Apply sqlite_vec.serialize_float32() native serialization for embedding storage integrity",
      "Implement LRU caching with priority scoring based on download frequency and search relevance",
      "Configure ONNX runtime environment variables for memory-efficient embedding generation",
      "Use TYPE_CHECKING imports to enable dependency injection without circular import issues",
      "Apply adaptive batch processing with dynamic sizing based on real-time memory pressure monitoring",
      "Implement memory threshold-based batch size reduction to prevent OOM conditions during ingestion"
    ],
    "production": [
      "Distributed rate limiting with Redis for multi-worker",
      "Health checks with <10ms response times",
      "Prometheus monitoring with <5% overhead",
      "Error masking in production environments",
      "Schema allowlisting for security",
      "Volume mounts for cache persistence",
      "Signal-based regex timeouts for ReDoS protection",
      "Pattern complexity analysis prevents dangerous regex constructs",
      "Built-in timeout mechanism adequate vs google-re2 dependency overhead"
    ],
    "monitoring": {
      "prometheus": {
        "lib": "prometheus-fastapi-instrumentator 6.1.0",
        "feat": ["Auto HTTP metrics", "Memory/CPU usage", "Custom metrics", "/metrics endpoint"],
        "overhead": {"baseline": "2-5MB", "per_endpoint": "100KB", "per_metric": "50KB"},
        "setup": "Instrumentator().instrument(app).expose(app)",
        "best_practices": ["Low cardinality labels", "Appropriate histogram buckets", "Monitor /metrics performance", "Sample high-throughput apps"]
      },
      "health_checks": {
        "endpoints": {"/health": "basic alive/dead", "/health/detailed": "comprehensive", "/ready": "traffic ready", "/live": "k8s liveness"},
        "practices": ["<10ms response", "Separate from rate limiting", "Include downstream status", "Cache for high frequency"],
        "codes": {"200": "healthy", "503": "unhealthy", "429": "degraded", "timeout": "2-5s"}
      }
    }
  },
  "stats": {
    "original_tokens": 56800,
    "compressed_tokens_estimate": 21500,
    "compression_ratio": "62.1%",
    "token_reduction": 35300,
    "preservation": {
      "technical_details": "100%",
      "library_versions": "100%", 
      "performance_metrics": "100%",
      "security_vulnerabilities": "100%",
      "implementation_patterns": "100%"
    }
  }
}