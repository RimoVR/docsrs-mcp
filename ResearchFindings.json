{
  "meta": {
    "projectName": "docsrs-mcp",
    "lastUpdated": "2025-08-10",
    "compressionVersion": "1.0",
    "originalTokens": 45200,
    "legend": {
      "keys": {
        "desc": "description",
        "impl": "implementation", 
        "perf": "performance",
        "cfg": "configuration",
        "opt": "optimization",
        "compat": "compatibility",
        "reqs": "requirements",
        "vulns": "vulnerabilities",
        "thresh": "thresholds",
        "strat": "strategies",
        "proc": "processing",
        "mem": "memory",
        "lib": "library",
        "ver": "version",
        "feat": "features",
        "vals": "validators",
        "sched": "scheduling",
        "mgmt": "management"
      },
      "phrases": {
        "p1": "Use for optimal performance",
        "p2": "CRITICAL implementation requirement",
        "p3": "Memory efficiency optimization",
        "p4": "Backward compatibility maintenance",
        "p5": "Security vulnerability mitigation",
        "p6": "Performance bottleneck resolution",
        "p7": "Production readiness requirement",
        "p8": "Token usage optimization",
        "p9": "Error handling best practice",
        "p10": "Database operation optimization"
      }
    },
    "globals": {
      "versions": {
        "fastmcp": "2.11.1",
        "sqlitevec": "0.1.0+",
        "aiohttp": "3.9.5",
        "fastembed": "0.7.1",
        "rapidfuzz": "3.13.0",
        "pydantic": "2.11.7",
        "uvicorn": "0.27.1",
        "ijson": "3.4.0",
        "pygments": "2.19.2",
        "slowapi": "0.1.10"
      },
      "perf_metrics": {
        "sqlite_vec_query": "<100ms for 1M+ vectors",
        "rapidfuzz_speedup": "4000%+ vs FuzzyWuzzy (16x baseline)", 
        "fastembed_speedup": "2-10x vs HuggingFace",
        "ijson_speedup": "656x with yajl2_c backend",
        "treesitter_speedup": "36x vs regex",
        "memory_efficiency": "7-25x with generators",
        "mmr_diversification_overhead": "<5ms additional latency",
        "fuzzy_normalization_overhead": "<1ms per query"
      },
      "memory_limits": {
        "embeddings_10k": "1GB",
        "warning_threshold": "80%",
        "critical_threshold": "90%",
        "sqlite_param_limit": "999",
        "batch_size_optimal": "1000"
      }
    }
  },
  "research": {
    "mcp": {
      "overview": "Open standard by Anthropic for LLM-tool communication",
      "spec_ver": "2025-06-18",
      "fastapi": {
        "lib": "FastMCP",
        "ver": "#{fastmcp}",
        "method": "FastMCP.from_fastapi()",
        "feat": ["Auto REST→MCP conversion", "Tool auto-discovery", "Dual mode operation"],
        "transport": "STDIO required for Claude Desktop - all logging to stderr",
        "modes": {
          "mcp": {"default": true, "purpose": "Claude Desktop integration"},
          "rest": {"purpose": "Debug/direct API", "flag": "--mode rest"}
        },
        "issues": {
          "vulns": {"cve": "N/A", "type": "Protocol corruption via stdout"},
          "type_coercion": {
            "problem": "Client sends strings for numeric/boolean params",
            "solution": "Use anyOf patterns + Pydantic mode='before' vals"
          },
          "validation": "Double validation: FastMCP + MCP client inconsistencies"
        },
        "manifest": {
          "structure": "MCPManifest with MCPTool objects",
          "critical_fields": ["tutorial", "examples", "desc"],
          "patterns": "MANDATORY anyOf for numeric/boolean params"
        }
      }
    },
    "vector_search": {
      "sqlite_vss": "DEPRECATED - unmaintained",
      "sqlite_vec": {
        "ver": "#{sqlitevec}",
        "perf": "#{sqlite_vec_query}",
        "feat": ["Brute force <1M vectors", "SIMD acceleration", "Binary quantization 8x reduction"],
        "syntax": "MATCH operator required",
        "opt": {
          "quantization": "75% mem reduction float32→uint8",
          "chunking": "O(NM)→O(N) complexity",
          "wal_mode": "Improved write perf"
        }
      },
      "embedding": {
        "models": {
          "all_minilm_l6_v2": {"mem_reduction": "85%", "perf": "good"},
          "baai_bge_small_en_v1_5": {"mteb_score": 62.17, "skip_instructions": true}
        },
        "fastembed": {
          "ver": "#{fastembed}",
          "issue": "Memory leak 1.5GB→16GB",
          "opt": ["Session caching", "Generator pattern", "ONNX Runtime"],
          "batch_sizes": {"cpu": 16, "gpu": 256, "general": 32}
        },
        "onnx_env": ["ORT_DISABLE_CPU_ARENA_ALLOCATOR=1", "ORT_DISABLE_MEMORY_PATTERN=1"]
      },
      "sync": {
        "libs": {"sqlite_vec": "#{sqlitevec}", "aiosqlite": "3.0.0", "embedding_model": "fastembed"},
        "findings": {
          "trigger_limits": "Manual sync required for virtual tables",
          "insert_replace_issues": "Use DELETE+INSERT pattern",
          "autoincrement": "Solves lastrowid issues"
        },
        "patterns": {
          "manual_sync": "Explicit sync calls required",
          "hash_dedup": "SHA256-based deduplication",
          "batch_proc": "#{batch_size_optimal} records per transaction"
        }
      }
    },
    "implementation": {
      "hierarchy": {"adjacency_list": "Parent-child relationships", "recursive_ctes": "Tree traversal"},
      "async_db": {"lib": "aiosqlite", "ver": "3.0.0"},
      "pytest": {
        "compat": {
          "stable": "pytest-asyncio-mode=auto",
          "problematic": "pytest-asyncio 0.21.0 + Python 3.11"
        },
        "cfg": "asyncio_mode=auto in pytest.ini"
      },
      "batch_insert": {
        "sqlite_limit": "#{sqlite_param_limit} parameters max",
        "virtual_tables": "No lastrowid support - use SELECT last_insert_rowid()",
        "optimal_size": "#{batch_size_optimal}",
        "opts": {
          "pre_serialize": "Vectors to bytes before batch",
          "transaction_per_batch": "One transaction per #{batch_size_optimal}",
          "adaptive": {"mem_thresh": "#{warning_threshold}%/#{critical_threshold}%"}
        }
      },
      "search_opt": {
        "semantic_chunk": "50-200 tokens optimal",
        "brute_force_thresh": "<1M vectors",
        "binary_quant": "32x mem reduction minimal accuracy loss",
        "simd": "Built-in acceleration",
        "filters": {
          "partial_idx": "WHERE clause optimization", 
          "progressive": "Multi-stage filtering",
          "selectivity": "Analyze filter effectiveness"
        }
      }
    },
    "ranking": {
      "hybrid": "Vector + metadata signals",
      "similarity_norm": "(1 + cosine_similarity) / 2",
      "perf_target": "<500ms latency",
      "scoring": "Multi-factor approach",
      "mmr_diversification": {
        "desc": "Maximum Marginal Relevance algorithm for result diversification",
        "formula": "MMR = λ * relevance + (1-λ) * diversity",
        "default_lambda": "0.6 (balances relevance vs diversity)",
        "diversity_weight": "0.1 (enables/disables MMR globally)",
        "perf": "Minimal overhead with intelligent over-fetching",
        "diversity_factors": {
          "type_penalty": "0.2 per duplicate item type",
          "path_similarity": "Module-based path comparison",
          "max_type_penalty": "0.6 (prevents excessive penalization)"
        },
        "dynamic_fetch": {
          "base_strategy": "k + 10 over-fetch",
          "mmr_boost": "1.5x multiplier when enabled",
          "performance_cap": "Maximum 50 candidates for latency"
        }
      },
      "multi_factor_scoring": {
        "weights": {
          "vector": "0.6 (reduced from 0.7)",
          "type": "0.15 (enhanced type-specific boosts)",
          "quality": "0.1 (documentation quality heuristics)",
          "examples": "0.15 (increased from 0.05)"
        },
        "type_weights": {
          "function": "1.2x boost",
          "trait": "1.15x boost",
          "struct": "1.1x boost",
          "trait_impl": "1.1x boost",
          "module": "0.9x penalty"
        }
      },
      "code_extraction": {
        "lib": "Pygments #{pygments}",
        "impl": "Language detection + syntax highlighting",
        "storage": "JSON format in TEXT columns",
        "backward_compat": "Support legacy list format",
        "search_opt": "Vector similarity search",
        "dedup": "Hash-based prevention",
        "embedding_storage": "sqlite-vec integration"
      }
    },
    "see_also": {
      "constraints": {"k_param": "Required for sqlite-vec queries"},
      "embedding": {"similarity_thresh": "0.7-0.8 with BAAI/bge-small-en-v1.5"},
      "cognitive": {"suggestion_count": "3-5 items optimal"},
      "impl": {"caching": "TTL LRU 60s"},
      "thresh_validation": "Empirical testing required"
    },
    "fallback_extraction": {
      "three_tier_system": {
        "description": "Multi-source extraction system for comprehensive documentation coverage",
        "tier1": {
          "source": "Rustdoc JSON from docs.rs",
          "coverage": "~10-15% of crates",
          "quality": "highest", 
          "format": "Structured JSON with complete metadata"
        },
        "tier2": {
          "source": "Source code extraction from crates.io CDN",
          "coverage": "80%+ of crates",
          "quality": "medium-high",
          "cdn_url": "https://static.crates.io/crates/{name}/{name}-{version}.crate",
          "rate_limits": "None - CDN has no rate limiting",
          "format": "Tar.gz archives with .rs files",
          "extraction_method": "Regex-based documentation parsing"
        },
        "tier3": {
          "source": "Latest version fallback",
          "coverage": "100% guaranteed",
          "quality": "basic",
          "purpose": "Ensure no crate is left without documentation"
        },
        "decision_logic": {
          "tier1_to_tier2": "RustdocVersionNotFoundError or parsing failure",
          "tier2_to_tier3": "CDN unavailable or extraction timeout",
          "performance": "Sub-500ms search maintained across all tiers"
        }
      }
    },
    "docs_rs": {
      "rustdoc_json": {
        "compression": {
          "zstd": {"magic_bytes": "[0x28, 0xb5, 0x2f, 0xfd]", "preferred": true},
          "gzip": {"fallback": true}
        },
        "delivery": "static.docs.rs CDN",
        "sizes": {"stdlib": "100MB+", "avg_crate": "1-10MB"},
        "parsing": "High complexity - nested JSON",
        "mem": "Stream processing required",
        "best_practices": {
          "streaming": "ijson with yajl2_c",
          "symbol_intern": "String deduplication", 
          "on_demand": "Parse sections as needed",
          "format_ver": "Always validate FORMAT_VERSION"
        },
        "findings": {
          "ver_tracking": "Format compatibility checks",
          "json_structure": {
            "module_hierarchy": "From paths section",
            "perf_opts": {
              "ijson_streaming": "#{ijson_speedup}",
              "adjacency_list": "Hierarchical storage",
              "recursive_ctes": "Tree queries",
              "batch_insert": "#{batch_size_optimal} per transaction",
              "re_export_opts": {
                "ijson_optimized": "Stream processing",
                "batch_inserts": "Transaction batching", 
                "sqlite_idx": "Query optimization",
                "lru_cache": "Result caching"
              }
            }
          },
          "lib_vers": {
            "ijson": "#{ijson}",
            "zstandard": "0.23.0",
            "aiosqlite": "3.0.0"
          },
          "structural": {
            "item_types": "Function, struct, trait, module, etc",
            "signature_extract": "From inner.function.decl",
            "parent_resolution": "Via paths section mapping",
            "trait_impls": {
              "impl_block": "trait + for fields",
              "type_objects": "Multiple formats (resolved_path, path, generic, primitive)",
              "type_extraction": "Recursive processing"
            },
            "code_examples": {
              "pygments": "#{pygments}",
              "lang_detect": "30% confidence threshold",
              "storage": "JSON in TEXT columns",
              "search": "Vector similarity",
              "patterns": "Hash deduplication"
            },
            "re_export_discovery": {
              "format": {"kind": "import", "path": "source info", "target": "destination"},
              "patterns": {
                "trait_re_exports": "pub use trait::*",
                "function_re_exports": "pub use module::function",
                "module_flattening": "pub use module::*",
                "glob_imports": "Wildcard re-exports"
              }
            }
          },
          "db_opts": {
            "sqlite_limit": "#{sqlite_param_limit} params",
            "backward_compat": "NULL defaults for new columns"
          }
        }
      },
      "api": "/crate/{name}/{ver}/json",
      "ingestion": {
        "concurrency": "Per-crate locking",
        "size_mgmt": "Download limits + monitoring",
        "cache_evict": "LRU by modification time",
        "error_handling": "Tenacity retry logic",
        "module_tree": {
          "rustdoc_paths": "kind=module entries",
          "cargo_modules": "Workspace handling",
          "workspace": "Multi-crate scenarios"
        }
      },
      "rust_stdlib": {
        "source": "rust-docs-json component via rustup",
        "format_compat": "Same as crate docs",
        "chars": "100MB+ files",
        "mirror": "docs.rs unified API",
        "ver_mgmt": {"manifest": "https://static.rust-lang.org/version"},
        "best_practices": {
          "streaming": "ijson for large files",
          "mem_mgmt": "Chunk processing",
          "caching": "Aggressive - expensive parsing"
        }
      },
      "cross_reference_support": {
        "rustdoc_links_field": {
          "native_field": "links: FxHashMap<String, Id>",
          "desc": "Pre-resolved intra-doc link mappings in rustdoc JSON",
          "format": "link_text -> item_id mapping",
          "advantage": "No regex parsing needed - rustdoc provides resolved links"
        },
        "docs_rs_availability": {
          "json_start_date": "May 23, 2025",
          "compatibility": "Older crate versions may not have rustdoc JSON available",
          "fallback": "HTML-only documentation for pre-JSON era crates"
        },
        "api_endpoints": {
          "pattern": "https://docs.rs/crate/{name}/{version}/json",
          "version_specific": "Each crate version has dedicated JSON endpoint",
          "cdn_delivery": "Served via static.docs.rs CDN"
        },
        "compression_formats": {
          "primary": ".json.zst (Zstandard compression)",
          "fallback": ".json.gz (Gzip compression)", 
          "uncompressed": ".json (raw JSON)",
          "preference": "zstd for optimal size/speed balance"
        },
        "extraction_strategy": {
          "no_regex": "Native rustdoc links field eliminates parsing complexity",
          "pre_resolved": "Links already resolved to target item IDs",
          "implementation": "Direct JSON field access via ijson streaming",
          "performance": "Significant speedup vs HTML parsing + regex extraction"
        }
      }
    },
    "validation": {
      "pydantic": {
        "ver": "#{pydantic}",
        "perf": "17x improvement v1→v2",
        "field_vals": {
          "mcp_compat": "mode='before' for type coercion",
          "cross_field": "ValidationInfo.data access",
          "best_practices": "Specific error messages"
        },
        "extensions": {
          "json_schema_extra": {"examples": "Usage demonstrations"},
          "optional_pattern": "default=None explicit",
          "strict_validation": "Prevent type coercion",
          "annotated": "Field(description=...) pattern",
          "constraints": {
            "string": "min_length, max_length, pattern",
            "array": "min_items, max_items",
            "numeric": "ge, gt, le, lt"
          }
        },
        "mcp_params": {
          "client_inconsistency": "String params for numeric/boolean",
          "double_validation": "FastMCP + client side",
          "anyof_schema": "MANDATORY pattern for flexibility"
        },
        "error_handling": {
          "field_validators": {
            "decorator": "@field_validator(mode='before')",
            "type_coercion": "Handle string→numeric/boolean conversion",
            "error_type": "Must raise ValueError, not ValidationError",
            "business_logic": "Use PydanticCustomError for domain-specific validation"
          },
          "config": {
            "strict_validation": "ConfigDict(extra='forbid') prevents unknown fields",
            "validation_alias": "Support multiple input formats",
            "json_schema_extra": "Include examples and descriptions"
          },
          "fastapi_integration": {
            "request_validation": "RequestValidationError inherits from Pydantic ValidationError",
            "exception_handler": "@app.exception_handler(RequestValidationError)",
            "http_status": "422 Unprocessable Entity for validation errors",
            "response_format": "Include field path, message, type, context"
          },
          "message_patterns": {
            "structure": "What went wrong + why + how to fix",
            "examples": "Provide concrete valid value examples", 
            "consistency": "Use uniform formatting across all errors",
            "specificity": "Avoid vague messages like 'Invalid input'",
            "proximity": "Place error messages near relevant field"
          },
          "performance": {
            "template_precompile": "Compile error templates at module level",
            "regex_precompile": "Pre-compile validation patterns",
            "fail_fast": "Use FailFast mode when completeness not required",
            "response_cache": "Cache error responses with appropriate TTL",
            "json_parsing": "model_validate_json() faster than model_validate(json.loads())"
          }
        }
      },
      "semver": {
        "lib": "semantic-version",
        "regex": "Standard SemVer 2.0.0 pattern",
        "special": {"latest": "Special case handling"},
        "integration": "Pydantic field validators",
        "perf": "Precompiled regex patterns"
      },
      "best_practices": {
        "boundaries": "Service layer only",
        "errors": "Specific actionable messages",
        "defaults": {"none_vals": "Application level", "empty_strings": "Context dependent"},
        "perf": {"regex_precompile": "Module level", "validation_cache": "TTL-based", "lazy": "On-demand validation"},
        "error_messages": {
          "structure": "What + Why + How to fix pattern",
          "examples": "Concrete valid values",
          "consistency": "Uniform formatting",
          "avoid": "Vague messages like 'Invalid input'",
          "http_422": "Standard code for validation errors"
        }
      }
    },
    "memory_mgmt": {
      "monitoring": "psutil with #{warning_threshold}%/#{critical_threshold}% thresh",
      "opts": {
        "generators": "#{memory_efficiency} vs lists",
        "adaptive_batch": "Threshold-based sizing",
        "streaming": "ijson for large files"
      }
    },
    "server_infra": {
      "fastapi": {
        "ver": "0.104.1",
        "auto_docs": {"openapi": "Swagger UI", "redoc": "ReDoc", "enhance": "Pydantic field descriptions"},
        "error_handling": {
          "http_exceptions": {"codes": "400, 401, 403, 404, 422, 500, 503"},
          "logging": {"stderr": "p2 - STDIO transport", "validation": "Structured error logs"}
        }
      },
      "uvicorn": {"ver": "#{uvicorn}", "workers": "Production scaling"},
      "http_client": {
        "aiohttp": {"ver": "#{aiohttp}", "issue": "Memory leak in later versions"},
        "mem_leak": "p5 - Pin to 3.9.5"
      },
      "rate_limiting": {
        "lib": "SlowAPI #{slowapi}",
        "backend": {"memory": "Single worker", "redis": "Multi-worker"},
        "algorithm": {"token_bucket": "p1 - burst handling"},
        "impl": {
          "request_param": "Explicit Request parameter",
          "limiter_state": "app.state.limiter required",
          "decorator": "@limiter.limit() pattern",
          "headers": {"retry_after": "Rate limit guidance", "rate_limit": "X-RateLimit-* headers"},
          "exceptions": "Custom handler for consistent format"
        },
        "avoid": "BaseHTTPMiddleware (70-80% perf penalty)",
        "production": {"single_worker": "In-memory OK", "multi_worker": "Redis required", "monitoring": "Response time tracking"}
      },
      "compression": "gzip middleware for API responses",
      "json_parsing": {
        "ijson": "#{ijson_speedup}",
        "opts": {"module_hierarchy": "Stream extraction", "mem_opt": {"stream_proc": "Constant memory", "progressive": "Batch processing"}}
      },
      "retry": "Tenacity with exponential backoff",
      "db_security": "Parameterized queries only",
      "input_validation": "All entry points"
    },
    "security": {
      "mcp": {
        "schema_poisoning": "p5 - Validate all schema fields",
        "param_extraction": "p5 - Allowlist vetted schemas",
        "production": {"error_masking": "mask_error_details=True", "allowlisting": "Tool schema validation"}
      }
    },
    "deployment": {
      "zero_install": "uvx --from git+URL docsrs-mcp",
      "container": "Multi-stage Docker builds",
      "cicd": {
        "github": {
          "uv_setup": "hynek/setup-uv@v2",
          "perf": {"cache_opt": "~/.cache/uv caching", "cache_key": "uv.lock hash"},
          "publishing": "PyPI via trusted publishing",
          "platforms": {"windows": "Separate workflow branch"}
        }
      }
    },
    "tooling": {
      "uv": {
        "ver": "0.3.0+",
        "commands": {
          "dev_setup": "uv sync --dev",
          "run_module": "uv run python -m module", 
          "test": "uv run pytest",
          "add_dep": "uv add package",
          "add_dev": "uv add --dev package"
        },
        "project": "pyproject.toml-based",
        "deploy": {
          "uvx": {"test_local": "uvx --from . docsrs-mcp", "test_git": "uvx --from git+URL"}
        }
      },
      "ruff": {
        "ver": "0.5.0+",
        "replaces": ["black", "flake8", "pylint", "isort", "autopep8"],
        "commands": {"lint": "uv run ruff check", "format": "uv run ruff format", "fix": "uv run ruff check --fix"},
        "cfg": "pyproject.toml [tool.ruff]",
        "consolidation": "Single Rust-based tool"
      },
      "best_practices": {
        "string_iter": {
          "type_check": "isinstance(obj, str) - 88% adoption",
          "perf": {"python312": "2-20x isinstance() speedup", "word_level": "7x vs char-level"},
          "pitfalls": {"string_iter": "Wrap single strings in lists", "char_fragment": "p6 - Prevent unintended iteration"}
        },
        "cache_mgmt": {
          "priority_queues": "heapq [priority, counter, item]",
          "eviction": {"lru": "functools.lru_cache", "hybrid_lru": "LRU + priority", "log_scale": "Prevent extreme differences"},
          "python_opts": {"os_walk": "Python 3.5+ scandir integration", "size_limits": "Prevent unbounded growth", "functools_limits": "Avoid for complex eviction"}
        }
      }
    },
    "query_preprocessing": {
      "unicode_norm": {
        "method": "unicodedata.normalize('NFKC')",
        "perf": "<1ms overhead C-optimized",
        "cases": {"accented": "Café → Cafe", "compat": "Compatibility chars", "composed": "Multi-char normalization", "ligatures": "ﬁ → fi"},
        "alternatives": {"nfc": "Canonical composition", "nfd": "Canonical decomposition", "nfkd": "Compatibility decomposition"},
        "guideline": "First step in preprocessing pipeline"
      },
      "pydantic_val": {
        "field_vals": "@field_validator mode='before'",
        "pipeline": "Unicode norm → length check → content validation",
        "best_practices": {
          "type_flex": "Accept str/bytes input",
          "errors": "Specific actionable messages",
          "defaults": "None handling",
          "perf": "Precompiled patterns"
        },
        "integration": "Preprocessing + validation single step"
      },
      "perf_chars": {
        "norm_overhead": "<1ms per query",
        "validation": "<0.1ms typical",
        "memory": "Minimal impact",
        "concurrency": "Thread-safe operations"
      },
      "best_practices": {
        "query_val": {"length": "1-500 chars", "char_val": "Unicode categories", "sanitization": "XSS prevention"},
        "error_handling": {"validation": "Field-specific errors", "graceful": "Fallback processing"},
        "testing": "Unicode edge cases + international chars",
        "monitoring": "Preprocessing latency + success rates"
      },
      "findings": {
        "optimal": "NFKC normalization + Pydantic integration",
        "real_world": "Handles international queries effectively",
        "production": "Sub-millisecond processing reliable"
      },
      "rapidfuzz": {
        "ver": "#{rapidfuzz}",
        "perf": "4000%+ speedup over FuzzyWuzzy (#{rapidfuzz_speedup})",
        "breaking": "v3.0 API changes",
        "fuzzy_thresh": "60% optimal threshold",
        "algorithms": {
          "token_set_ratio": "Best for handling subsets in path matching",
          "token_sort_ratio": "Handles word order variations effectively", 
          "partial_ratio": "Excellent for substring matching"
        },
        "v3_requirements": {
          "preprocessing": "Explicit preprocessing with utils.default_process required",
          "unicode_norm": "No built-in Unicode normalization - must use unicodedata.normalize('NFC')"
        },
        "fuzzy_normalization": {
          "purpose": "Handle British/American English spelling variations",
          "patterns": {
            "ise_to_ize": "serialise → serialize, realise → realize",
            "our_to_or": "colour → color, honour → honor",
            "re_to_er": "centre → center, theatre → theater"
          },
          "implementation": {
            "regex_based": "Word boundary matching only",
            "case_preservation": "Maintains original case patterns",
            "performance": "<1ms overhead per query",
            "integration": "Pydantic field validator with mode='before'"
          },
          "benefits": {
            "search_consistency": "Unified American spelling for embedding consistency",
            "user_experience": "Accepts both British and American spellings",
            "no_database_changes": "Applied at query preprocessing only"
          }
        },
        "best_practices": {
          "thresh_select": "Dataset-specific optimization",
          "suggestion_count": "3-5 cognitive limit",
          "edit_distance": "Levenshtein + variants",
          "scoring": "Normalized 0-100 scale",
          "caching": "TTL-based for performance",
          "composite_scoring": "Multiple algorithms improve accuracy",
          "position_aware": "Word boundary bonuses enhance relevance",
          "adaptive_thresholds": "Query length-based reduces false positives"
        },
        "insights": {
          "multiproc": "Avoid - overhead outweighs benefits",
          "explicit": "Direct processing preferred",
          "score_norm": "Consistent 0-100 scaling",
          "performance_finding": "RapidFuzz 3.13.0 delivers exceptional performance gains without NumPy dependency since sqlite-vec handles vector operations efficiently"
        }
      },
      "mcp_manifest": {
        "boolean_params": {
          "anyof": "MANDATORY pattern",
          "pydantic_val": "mode='before' coercion",
          "string_to_bool": "Handle client inconsistencies"
        },
        "param_flex": {"union_types": "Union[str, int] patterns", "anyof": "JSON Schema generation"}
      },
      "path_resolution": {
        "fuzzy_integration": {"thresh": "60% similarity", "strategy": "Exact → case-insensitive → fuzzy"},
        "doc_systems": {"norm": "Path standardization", "hierarchical": "Tree structure matching", "contextual": "Relevance scoring"},
        "alias_resolution": {
          "perf": "Sub-second response times",
          "dependency": "Module relationship optimization",
          "rust_patterns": "pub use, mod declarations",
          "impl_strategy": "Discovery source prioritization",
          "rust_aliases": {
            "patterns": "std::collections::HashMap vs HashMap",
            "impl": "Path alias database",
            "discovery": "rustdoc JSON + manifest analysis"
          }
        }
      },
      "rapidfuzz_opt": {"bulk_thresh": "60% optimal", "strategies": "SIMD acceleration"},
      "structure_preservation": {
        "markitdown": "Microsoft text extraction",
        "pdf_convert": "Structured content preservation", 
        "terminal": "ANSI code handling"
      },
      "cross_refs": {"sphinx": "Domain-specific references", "mkdocstrings": "API documentation links"}
    },
    "code_extraction": {
      "current": "Regex-based with performance issues",
      "recommended": {
        "tree_sitter": "#{treesitter_speedup} + language awareness"
      },
      "macro_extraction": {
        "enhanced_extractor": {
          "class": "EnhancedMacroExtractor",
          "purpose": "Advanced macro extraction from Rust source code",
          "patterns": {
            "declarative": "macro_rules! with fragment specifiers",
            "procedural": "#[proc_macro] attribute macros",
            "derive": "#[proc_macro_derive] custom derive macros", 
            "attribute": "#[proc_macro_attribute] function-like macros"
          },
          "fragment_specifiers": ["expr", "ident", "pat", "ty", "stmt", "block", "item", "meta", "tt", "vis", "literal", "path"],
          "validation": {
            "lazy_static": "4 macros extracted successfully",
            "serde_derive": "5 macros extracted successfully",
            "anyhow": "15 macros extracted successfully"
          },
          "implementation": "Python-based regex extraction with comprehensive pattern matching"
        }
      }
    },
    "memory_mgmt_detailed": {
      "streaming": {"ijson": "#{ijson_speedup}"},
      "generators": "#{memory_efficiency} improvement",
      "batch_proc": "#{batch_size_optimal} optimal size",
      "sqlite_constraints": {
        "unique_add": "p2 - Requires 12-step rebuild procedure"
      },
      "monitoring": {"thresh": "#{warning_threshold}%/#{critical_threshold}%"}
    },
    "mcp_best_practices": {
      "tool_desc": "p8 - Token efficiency",
      "parameter_handling": "MANDATORY anyOf patterns",
      "transport_reqs": "STDIO for Claude Desktop"
    },
    "best_practices": {
      "project_cfg": {
        "pyproject": "Modern Python packaging",
        "semver": "Strict version management"
      },
      "operational_docs": {"perf": "Sub-500ms targets"}
    },
    "known_issues": {
      "pkg_dist": {"pypi_readme": "Markdown rendering limitations"}
    },
    "crate_pre_ingestion": {
      "reactive_caching": "Demand-driven approach",
      "selective_loading": "Priority-based",
      "background": {"priority_queues": "Download count ordering"},
      "non_blocking": "Startup optimization",
      "rate_limiting": {"upstream": "Respect API limits"},
      "cdn_edge": "Geographic optimization",
      "cratesio_api": {
        "rate_limit": "30 req/burst",
        "response": "JSON metadata",
        "client": "aiohttp connection pooling"
      },
      "binary_serial": {
        "format": "msgpack vs pickle",
        "perf": "25x faster loads (50ms→2ms)",
        "compat": "Version handling"
      },
      "connection_pool": {
        "optimal": {"limit": 100, "limit_per_host": 10},
        "perf": "Connection reuse efficiency",
        "comparison": "aiohttp vs httpx"
      },
      "cache_patterns": {
        "ttl": "24h popular crates",
        "stale_revalidate": "75% threshold",
        "atomic_writes": "temp + rename pattern",
        "concurrency": "filelock coordination"
      },
      "memory_mgmt": {
        "monitoring": "psutil integration",
        "adaptive": "900MB threshold",
        "priority": "Download count ordering"
      }
    },
    "asyncio_task_mgmt": {
      "task_refs": {
        "weak_refs": "Prevent GC issues",
        "task_group": "Python 3.11+ structured concurrency",
        "eager_tasks": "Python 3.12 perf improvement"
      },
      "memory_mgmt": {"monitoring": "psutil integration", "thresh": "#{warning_threshold}%"},
      "sched_patterns": {
        "interval": {"jitter": "±10% thundering herd prevention", "simple": "asyncio.sleep()"},
        "complex": "APScheduler for cron patterns"
      },
      "fastapi": {
        "background": {
          "resource_sep": "Avoid contention",
          "non_blocking": "Server responsiveness",
          "duplicate_prevent": {"force_param": "Override existing tasks"},
          "error_isolation": "Prevent startup failures"
        }
      },
      "best_practices": [
        "Strong task references with background_tasks.add()",
        "Cleanup with task.add_done_callback()",
        "Separate resource instances for background tasks",
        "Python 3.12+ for eager task performance"
      ]
    },
    "mcp_tool_opt": {
      "token_efficient": {"desc": "50-125 chars", "examples": "Concrete usage demonstrations"},
      "action_oriented": "Verb-noun combinations",
      "json_schema": {
        "guidelines": ["Minimize nested depth", "additionalProperties: false", "Provide defaults", "Use examples"],
        "opt": ["format for semantic validation", "Minimize object nesting", "Parameter drift prevention"]
      },
      "three_tier": {
        "tier1": "Tool name 2-4 words",
        "tier2": "Description 50-125 chars",
        "tier3": "Parameters 20-80 chars each"
      },
      "naming": {
        "params": ["Semantic names", "Type hints in naming", "Consistent patterns", "Avoid abbreviations"],
        "tools": ["Verb-noun combos", "Namespace prefixes", "Consistent families"]
      },
      "tutorial": {
        "quickstart": ["Purpose statement", "Required params only", "Expected output", "Concrete example"],
        "patterns": {"org": "Group related patterns", "progression": "Simple→advanced", "errors": "Common conditions", "practices": "Optimal usage"}
      }
    },
    "mcp_documentation": {
      "protocol_principles": {
        "api_design": "Token-efficient, self-documenting APIs with JSON schemas",
        "structured_outputs": "100% format consistency best practice",
        "token_optimization": "60% usage reduction through concise, focused content",
        "tutorial_embedding": "Industry standard: tutorials in tool schemas as additive metadata"
      },
      "semantic_search": {
        "embedding_model": "BAAI/bge-small-en-v1.5",
        "performance": "<50ms warm searches",
        "optimization": "Token context window exhaustion mitigation"
      },
      "common_issues": {
        "token_limits": "200-token limit per tutorial prevents context window exhaustion",
        "type_coercion": "JSON Schema anyOf patterns handle MCP client type coercion requirements"
      },
      "sources": {
        "primary": ["Model Context Protocol specification", "OpenAI Platform Documentation on Structured Outputs"],
        "industry": "AI agent documentation best practices"
      }
    }
  },
  "recommendations": {
    "critical": [
      "p2: Use #{fastmcp} for MCP setup",
      "p2: Route logging to stderr for STDIO transport",
      "p2: Use #{sqlitevec} (sqlite-vss deprecated)",
      "p2: Pin aiohttp to #{aiohttp} (memory leak mitigation)",
      "p2: Monitor FastEmbed #{fastembed} memory leaks 1.5GB→16GB",
      "p2: Use anyOf patterns for MCP numeric/boolean params",
      "p2: Adding UNIQUE constraints requires 12-step rebuild",
      "p2: Use ijson #{ijson} with yajl2_c backend for #{ijson_speedup}",
      "p2: Use tree-sitter for #{treesitter_speedup} code extraction",
      "p2: Maintain strong asyncio task references"
    ],
    "performance": [
      "#{sqlite_vec_query} with sqlite-vec",
      "4000%+ speedup with RapidFuzz 3.13.0 over FuzzyWuzzy alternatives", 
      "#{memory_efficiency} with generator patterns",
      "Semantic chunking 50-200 tokens",
      "FastEmbed batch sizes: CPU=16, GPU=256, general=32",
      "#{batch_size_optimal} records per database transaction",
      "Use exact→case-insensitive→fuzzy matching hierarchy",
      "60% similarity threshold optimal for fuzzy matching",
      "Sub-500ms search response targets with MMR diversification",
      "Implement hybrid LRU+priority caching",
      "Use SIMD optimizations in RapidFuzz and sqlite-vec",
      "MMR λ=0.6 provides optimal relevance-diversity balance",
      "Dynamic fetch_k adjustment based on filter selectivity improves performance",
      "Fuzzy normalization handles British/American spellings with <1ms overhead"
    ],
    "implementation": [
      "Pydantic mode='before' validators for type coercion",
      "Union types for flexible parameter acceptance",
      "Streaming JSON parsing for large rustdoc files",
      "Connection pooling from project start",
      "SlowAPI decorator-based rate limiting",
      "Per-crate locking for ingestion",
      "Recursive CTEs for tree traversal",
      "Hash-based deduplication strategies",
      "Background task separation for resource isolation",
      "ConfigDict(extra='forbid') for strict validation",
      "ValueError exceptions in field validators, not ValidationError",
      "FastAPI RequestValidationError handlers for custom error formatting",
      "Precompile error templates and regex patterns for performance",
      "Include field path, message, type, and context in error responses",
      "Use structured outputs for 100% format consistency in MCP tools",
      "Embed tutorials directly in JSON schemas as additive metadata",
      "Apply 200-token limit per tutorial to prevent context window exhaustion",
      "Use BAAI/bge-small-en-v1.5 embeddings for <50ms semantic search performance",
      "Implement MMR diversification with λ=0.6 and diversity_weight=0.1 for balanced results",
      "Apply fuzzy normalization in Pydantic field validators for query preprocessing",
      "Use regex-based word boundary matching for spelling normalization",
      "Configure dynamic fetch_k with 1.5x multiplier when MMR is enabled",
      "Maintain <500ms P95 latency with all ranking optimizations enabled"
    ],
    "production": [
      "Distributed rate limiting with Redis for multi-worker",
      "Health checks with <10ms response times",
      "Prometheus monitoring with <5% overhead",
      "Error masking in production environments",
      "Schema allowlisting for security",
      "Volume mounts for cache persistence"
    ],
    "monitoring": {
      "prometheus": {
        "lib": "prometheus-fastapi-instrumentator 6.1.0",
        "feat": ["Auto HTTP metrics", "Memory/CPU usage", "Custom metrics", "/metrics endpoint"],
        "overhead": {"baseline": "2-5MB", "per_endpoint": "100KB", "per_metric": "50KB"},
        "setup": "Instrumentator().instrument(app).expose(app)",
        "best_practices": ["Low cardinality labels", "Appropriate histogram buckets", "Monitor /metrics performance", "Sample high-throughput apps"]
      },
      "health_checks": {
        "endpoints": {"/health": "basic alive/dead", "/health/detailed": "comprehensive", "/ready": "traffic ready", "/live": "k8s liveness"},
        "practices": ["<10ms response", "Separate from rate limiting", "Include downstream status", "Cache for high frequency"],
        "codes": {"200": "healthy", "503": "unhealthy", "429": "degraded", "timeout": "2-5s"}
      }
    }
  },
  "stats": {
    "original_tokens": 45200,
    "compressed_tokens_estimate": 15100,
    "compression_ratio": "66.6%",
    "token_reduction": 30100,
    "preservation": {
      "technical_details": "100%",
      "library_versions": "100%", 
      "performance_metrics": "100%",
      "security_vulnerabilities": "100%",
      "implementation_patterns": "100%"
    }
  }
}