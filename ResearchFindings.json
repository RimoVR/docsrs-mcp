{
  "projectName": "docsrs-mcp",
  "lastUpdated": "2025-08-06",
  "research": {
    "modelContextProtocol": {
      "overview": "Open standard by Anthropic for LLM-tool communication",
      "version": "2025-06-18 specification",
      "pythonSupport": {
        "officialSDK": "Available via MCP Python SDK",
        "fastAPIIntegration": {
          "library": "FastMCP",
          "version": "2.11.1",
          "method": "FastMCP.from_fastapi()",
          "features": "Automatic REST to MCP conversion",
          "integrationStatus": "Successfully integrated",
          "transport": {
            "required": "STDIO transport for Claude Desktop integration",
            "critical": "All logging must go to stderr to avoid STDIO corruption",
            "reason": "Claude Desktop communicates via STDIN/STDOUT - any stdout pollution breaks MCP protocol"
          },
          "operationalModes": {
            "mcp": {
              "purpose": "Claude Desktop integration",
              "protocol": "Model Context Protocol over STDIO",
              "activation": "Default mode when running the server",
              "isDefault": true
            },
            "rest": {
              "purpose": "Debugging and direct API access",
              "endpoint": "Standard FastAPI HTTP endpoints",
              "activation": "Requires explicit --mode rest flag"
            }
          },
          "compatibility": {
            "pydanticModels": "No modifications needed to existing Pydantic models",
            "businessLogic": "No changes required to existing FastAPI business logic",
            "conversionProcess": "Seamless automatic conversion from REST to MCP"
          },
          "documentation": {
            "official": "https://gofastmcp.com",
            "description": "Comprehensive FastMCP documentation and integration guides"
          },
          "knownIssues": {
            "typeCoercion": {
              "issue": "FastMCP has known issues with automatic string-to-int conversion",
              "cause": "MCP clients (Claude Code) serialize numeric parameters as strings in protocol communication",
              "symptoms": [
                "Pydantic validation errors for integer fields receiving string values",
                "Type mismatch errors in tool parameter validation",
                "Failed tool invocations due to parameter type conversion failures"
              ],
              "solution": {
                "approach": "Pydantic field validators with mode='before'",
                "implementation": "@field_validator('field_name', mode='before') with custom type conversion logic",
                "reason": "Field validators run before Pydantic's type validation, allowing custom coercion",
                "example": "Convert string representations of numbers to appropriate numeric types before validation"
              },
              "sources": [
                "GitHub Issue #381 - modelcontextprotocol/python-sdk",
                "Pydantic v2 documentation on field validators",
                "FastMCP documentation limitations"
              ],
              "workaround": {
                "description": "Use Pydantic v2 field validators to handle string-to-numeric conversion",
                "pattern": "@field_validator('numeric_field', mode='before') decorator with type conversion",
                "timing": "Validators with mode='before' execute before Pydantic's built-in type validation",
                "benefit": "Allows seamless conversion of MCP string parameters to expected Python types"
              }
            },
            "parameterValidation": {
              "issue": "MCP clients inconsistently send parameters - sometimes as proper JSON objects, sometimes as stringified values",
              "findings": {
                "fastMCPUnionSupport": {
                  "description": "FastMCP supports Union types (str | int) which automatically generates anyOf schemas",
                  "benefit": "Provides flexible parameter type definitions in MCP manifest",
                  "implementation": "Use Union[str, int] in Pydantic models for flexible parameter acceptance"
                },
                "doubleValidation": {
                  "description": "FastMCP has double validation - MCP manifest JSON Schema validates before Pydantic models",
                  "process": [
                    "1. MCP manifest JSON Schema validation occurs first",
                    "2. Pydantic model validation occurs second",
                    "3. Field validators with mode='before' can handle type coercion between these steps"
                  ],
                  "implication": "Need to handle type mismatches at both validation layers"
                },
                "clientInconsistency": {
                  "description": "MCP clients inconsistently send parameters",
                  "patterns": [
                    "Sometimes send proper JSON objects with correct types",
                    "Sometimes send stringified values for numeric parameters",
                    "Behavior may vary by client implementation or parameter context"
                  ],
                  "impact": "Requires defensive programming for parameter handling"
                }
              },
              "bestPractices": {
                "manifestDesign": {
                  "approach": "Use anyOf patterns in MCP manifest for flexible parameter types",
                  "example": "anyOf: [{type: 'string'}, {type: 'integer'}] for flexible numeric parameters",
                  "reason": "Accommodates client inconsistencies in parameter serialization"
                },
                "pydanticValidation": {
                  "approach": "Pydantic field validators with mode='before' handle type coercion after schema validation",
                  "timing": "Validators execute after MCP manifest validation but before Pydantic type checking",
                  "pattern": "@field_validator('field_name', mode='before') with Union type support",
                  "benefit": "Seamless handling of both string and native type parameters"
                },
                "robustImplementation": {
                  "principle": "Design for parameter type flexibility from the start",
                  "techniques": [
                    "Use Union types in Pydantic models",
                    "Implement field validators for type coercion",
                    "Design MCP manifest with anyOf schemas",
                    "Test with both string and native parameter types"
                  ]
                }
              },
              "sources": [
                "FastMCP searchItems k parameter validation fix",
                "MCP protocol specification analysis",
                "Claude Code client behavior observation",
                "FastMCP library source code review"
              ]
            }
          }
        }
      },
      "documentationRequirements": {
        "specification": "MCP specification mandates comprehensive tool and resource documentation",
        "importance": "Critical for LLM understanding and proper tool invocation",
        "components": [
          "Tool descriptions with clear purpose",
          "Parameter specifications with types and constraints",
          "Resource descriptions and access patterns",
          "Error conditions and responses"
        ]
      },
      "bestPractices": [
        "Use descriptive operation_ids",
        "Provide comprehensive docstrings",
        "Implement proper error handling",
        "Follow MCP manifest structure",
        "Document all tools and resources comprehensively per MCP spec"
      ]
    },
    "vectorSearch": {
      "sqliteVss": {
        "status": "DEPRECATED - DO NOT USE",
        "backend": "FAISS",
        "limitations": [
          "1GB index size limit",
          "No GPU support",
          "CPU-only operations",
          "No longer maintained",
          "Incompatible with modern SQLite versions"
        ],
        "replacement": "sqlite-vec (REQUIRED for new projects)"
      },
      "sqliteVec": {
        "status": "Current standard for SQLite vector search",
        "version": "0.1.6",
        "backend": "Native SQLite extension",
        "features": [
          "Production-ready vector search",
          "MATCH operator for vector queries",
          "KNN search with k constraint",
          "Better performance than sqlite-vss",
          "Active maintenance and development"
        ],
        "syntax": {
          "searchOperator": "MATCH (not vec_distance)",
          "knnConstraint": "Requires 'k = ?' parameter for KNN queries",
          "example": "SELECT * FROM embeddings WHERE vec MATCH ? AND k = 10"
        },
        "installation": "pip install sqlite-vec"
      },
      "embedding": {
        "library": "FastEmbed",
        "version": "<0.7.0",
        "versionConstraint": "Required for onnxruntime compatibility",
        "model": "BAAI/bge-small-en-v1.5",
        "dimensions": 384,
        "optimization": "ONNX for CPU inference",
        "performance": "2-4x faster than PyTorch",
        "fastEmbedOptimization": {
          "runtime": "FastEmbed with ONNX runtime provides 3x speedup over PyTorch",
          "backend": "ONNX runtime optimized for CPU inference",
          "batchProcessing": "Optimal batch size of 32 for embedding generation",
          "memoryEfficiency": "Keep memory under 1GB for 10k embeddings",
          "implementation": "Use FastEmbed with ONNX backend for production workloads"
        },
        "streamProcessing": {
          "technique": "Stream large JSON files to avoid OOM",
          "benefit": "Handle files larger than available RAM",
          "implementation": "Process documents in chunks rather than loading entirely",
          "memoryTarget": "Maintain constant memory usage regardless of file size"
        },
        "modelDownload": "Automatic on first use - no manual download needed",
        "onnxruntimeCompatibility": {
          "issue": "FastEmbed newer versions incompatible with onnxruntime >=1.20",
          "solution": "Pin onnxruntime <1.20 OR use FastEmbed <0.7.0",
          "recommendation": "Use FastEmbed <0.7.0 for better stability"
        },
        "requirements": [
          "libgomp1",
          "libatlas-base-dev",
          "liblapack-dev"
        ]
      },
      "implementation": {
        "batchSize": 32,
        "insertBatchSize": 1000,
        "indexCommand": "CREATE INDEX (for sqlite-vec)",
        "searchMethod": "k-NN cosine similarity with MATCH operator",
        "asyncDatabase": {
          "library": "aiosqlite",
          "purpose": "Async SQLite operations for better performance",
          "installation": "pip install aiosqlite"
        },
        "batchInsertion": {
          "sqliteParameterLimit": {
            "constant": "SQLITE_MAX_VARIABLE_NUMBER",
            "value": 999,
            "description": "Maximum parameters per SQL statement",
            "implication": "Limits maximum batch size for single INSERT statement"
          },
          "virtualTableHandling": {
            "library": "sqlite-vec",
            "tableType": "vec0 virtual table",
            "indexing": "Automatic - no explicit vss_index! call needed",
            "note": "sqlite-vss is deprecated and required explicit indexing calls"
          },
          "lastrowIdBehavior": {
            "method": "aiosqlite.executemany()",
            "returnValue": "None",
            "solution": "Use SELECT last_insert_rowid() after batch insert",
            "reason": "executemany() does not return lastrowid for batch operations"
          },
          "optimalBatchSize": {
            "research": "10,000 rows per transaction showed best performance",
            "prdRequirement": 1000,
            "rationale": "PRD requirement takes precedence over optimal performance",
            "note": "Balance between performance and memory usage"
          },
          "performanceOptimizations": {
            "vectorPreSerialization": {
              "technique": "Serialize vectors before batch processing",
              "benefit": "Reduces per-batch overhead significantly",
              "implementation": "Convert numpy arrays to bytes before INSERT"
            },
            "transactionPerBatch": {
              "approach": "One transaction per batch of 1000 records",
              "benefit": "Prevents memory accumulation during large ingestion",
              "rationale": "Balances performance with memory efficiency"
            }
          },
          "sqliteVecPerformance": {
            "version": "v0.1.0",
            "vectorDimensions": 384,
            "performance": "Excellent for 384-dimensional vectors",
            "benchmarkResult": "Significant improvement over sqlite-vss"
          },
          "vectorSearchOptimization": {
            "semanticChunking": {
              "optimalRange": "50-200 token chunks for optimal granularity",
              "rationale": "Balance between context preservation and search precision",
              "implementation": "Split documentation into semantic units rather than arbitrary sizes",
              "benefit": "Improved relevance and context in search results"
            },
            "bruteForceThreshold": {
              "library": "sqlite-vec",
              "capacity": "Works well up to 1M vectors with brute-force search",
              "performance": "Acceptable latency for most use cases up to 1M scale",
              "recommendation": "Use brute-force for initial implementation, evaluate ANN later"
            },
            "binaryQuantization": {
              "storageReduction": "8x reduction in storage requirements",
              "accuracyLoss": "Minimal accuracy loss with binary quantization",
              "implementation": "Available in sqlite-vec for production use",
              "benefit": "Significant storage savings with negligible quality impact"
            },
            "annIndexes": {
              "availability": "ANN indexes coming in sqlite-vec 2025",
              "capacity": "Designed for 10M+ vector collections",
              "currentStatus": "Use brute-force until ANN indexes available",
              "futureProofing": "Architecture should support migration to ANN when available"
            },
            "simdAcceleration": {
              "feature": "SIMD-accelerated distance calculations",
              "library": "Built into sqlite-vec for performance",
              "benefit": "Hardware acceleration for vector operations",
              "platform": "Automatic detection and utilization of SIMD instructions"
            }
          }
        }
      }
    },
    "docsRsIntegration": {
      "rustdocJson": {
        "availability": "Started 2025-05-23",
        "formats": [".json", ".json.zst", ".json.gz"],
        "urlPattern": "https://docs.rs/{crate}/{version}/{crate_name}.json[.zst|.gz]",
        "compressionPreference": ".zst (zstandard) - better compression than gzip",
        "fileSizes": {
          "compressed": "Varies significantly by crate",
          "uncompressed": "Can exceed 100MB for large crates",
          "efficiency": "Zstandard compression preferred for size reduction"
        },
        "parsingLibrary": "rustdoc-types crate",
        "parsingComplexity": {
          "status": "Complex nested JSON structure",
          "mvpApproach": "Use only crate descriptions for initial implementation",
          "fullParsing": "Requires significant effort for complete documentation extraction",
          "recommendation": "Start simple, expand incrementally based on user needs"
        },
        "memoryConsiderations": {
          "issue": "Large JSON files can cause memory spikes",
          "solution": "Use streaming decompression and parsing",
          "library": "ijson for memory-efficient streaming JSON parsing",
          "bestPractice": "Avoid loading entire JSON into memory at once"
        },
        "parsingBestPractices": {
          "streamingParser": {
            "technique": "Use streaming JSON parser with zero-copy deserialization",
            "benefit": "Handles large files without memory spikes",
            "library": "ijson with streaming approach",
            "implementation": "Process JSON incrementally rather than loading entire structure"
          },
          "symbolInterning": {
            "purpose": "Optimize repeated string lookups in rustdoc JSON",
            "technique": "Intern frequently used strings like type names and module paths",
            "benefit": "Reduces memory usage and improves lookup performance",
            "implementation": "Use string interning library or custom dictionary"
          },
          "onDemandParsing": {
            "strategy": "Parse on-demand rather than loading entire AST",
            "rationale": "Most queries only need specific sections of documentation",
            "implementation": "Use streaming parser to extract relevant sections only",
            "memoryBenefit": "Significant reduction in memory footprint for large crates"
          },
          "formatVersion": {
            "current": "Version 1 format is stable",
            "validation": "Always check format_version field before parsing",
            "compatibility": "Version 1 format guaranteed stable by rustdoc team",
            "futureProofing": "Handle unknown versions gracefully"
          }
        },
        "implementationFindings": {
          "formatVersionTracking": {
            "field": "FORMAT_VERSION",
            "purpose": "rustdoc JSON uses FORMAT_VERSION field for tracking schema changes",
            "importance": "Essential for maintaining parsing compatibility across rustdoc versions",
            "implementation": "Check FORMAT_VERSION before processing any rustdoc JSON file"
          },
          "structuralPatterns": {
            "itemTypes": {
              "variability": "Item types can be strings or nested objects",
              "examples": [
                "Simple string types for basic items",
                "Complex nested objects like {'struct': {...}} for detailed definitions"
              ],
              "parsing": "Must handle both string and object type representations dynamically"
            },
            "signatureExtraction": {
              "functionSignatures": "Available in inner.function.decl path",
              "methodSignatures": "Available in inner.method.decl path",
              "importance": "Critical for generating accurate API documentation and examples",
              "implementation": "Extract signature information from decl fields for comprehensive documentation"
            },
            "parentResolution": {
              "mechanism": "Parent ID resolution through paths section mapping",
              "benefit": "Enables construction of complete hierarchical documentation structure",
              "implementation": "Use paths section to map item IDs to their parent containers and module hierarchy"
            },
            "codeExampleExtraction": {
              "pattern": "r'```(?:rust)?\\s*\\n(.*?)```'",
              "purpose": "Extract Rust code examples from documentation strings",
              "effectiveness": "Proven effective for isolating code blocks from markdown documentation",
              "implementation": "Use regex pattern to extract code examples for syntax highlighting and validation"
            }
          },
          "databaseOptimizations": {
            "sqliteParameterLimit": {
              "constant": 999,
              "description": "SQLite has maximum 999 parameters per SQL statement",
              "impact": "Limits batch operation size in database insertions",
              "implementation": "Respect 999 parameter limit when designing batch operations to avoid SQL errors"
            },
            "backwardCompatibility": {
              "approach": "NULL defaults for new columns",
              "benefit": "Maintains database schema compatibility during enhancements",
              "implementation": "Use NULL defaults when adding new columns to support progressive schema evolution"
            }
          }
        }
      },
      "apiEndpoints": {
        "latestVersion": "/crate/{crate}/latest/json",
        "specificVersion": "/crate/{crate}/{version}/json",
        "versionList": "/crate/{crate}/versions.json"
      },
      "limitations": [
        "Not all crates have rustdoc JSON",
        "Older crates may lack JSON docs",
        "Format varies by rustdoc version"
      ],
      "ingestionBestPractices": {
        "concurrency": {
          "approach": "Per-crate locking to prevent duplicate ingestion",
          "mechanism": "File-based or database-based locks",
          "rationale": "Avoid race conditions when multiple processes ingest same crate"
        },
        "sizeManagement": {
          "downloadLimits": "Set reasonable size limits for HTTP downloads",
          "decompressionLimits": "Limit decompressed size to prevent memory exhaustion",
          "monitoring": "Track file sizes and memory usage during processing"
        },
        "cacheEviction": {
          "strategy": "LRU eviction based on file modification time",
          "rationale": "Keep recently accessed crates while freeing space for new ones",
          "implementation": "Use filesystem timestamps for eviction decisions"
        },
        "errorHandling": {
          "retryMechanism": "Use tenacity library for robust HTTP request retries",
          "backoffStrategy": "Exponential backoff with jitter",
          "maxRetries": "Configure reasonable retry limits to avoid infinite loops"
        },
        "moduleTreeExtraction": {
          "rustdocPaths": {
            "source": "Use rustdoc 'paths' section for module hierarchy",
            "structure": "Contains complete module tree information",
            "benefit": "Provides navigable crate structure for documentation",
            "implementation": "Extract paths section to build module navigation"
          },
          "cargoModules": {
            "tool": "cargo-modules for module visualization",
            "purpose": "Generate visual representations of module structure",
            "integration": "Complement rustdoc paths with visual module maps",
            "useCase": "Help users understand crate organization"
          },
          "workspaceHandling": {
            "challenge": "Handle workspace vs single-crate scenarios",
            "workspaces": "Multiple crates in single workspace require different parsing",
            "singleCrate": "Simpler structure for standalone crates",
            "implementation": "Detect workspace structure and adapt parsing accordingly"
          }
        }
      }
    },
    "serverInfrastructure": {
      "fastAPI": {
        "version": ">=0.111",
        "features": [
          "Async support",
          "Pydantic validation",
          "OpenAPI generation",
          "Middleware support"
        ],
        "automaticDocumentation": {
          "openAPI": {
            "endpoint": "/docs",
            "description": "Interactive Swagger UI for API exploration and testing",
            "generation": "Automatic based on FastAPI route definitions and Pydantic models"
          },
          "redoc": {
            "endpoint": "/redoc",
            "description": "Alternative documentation interface with clean, three-panel layout",
            "advantages": "Better for reference documentation and complex APIs"
          },
          "enhancementTechniques": {
            "pydanticFields": {
              "descriptions": "Use Field(description='...') to document model fields",
              "examples": "Use Field(example='...') to provide usage examples",
              "benefit": "Enhances automatic API documentation quality significantly"
            },
            "routeDocstrings": "FastAPI extracts route function docstrings for operation descriptions",
            "responseModels": "Define response_model parameter for complete API documentation"
          }
        }
      },
      "uvicorn": {
        "version": ">=0.30",
        "eventLoop": "uvloop",
        "httpParser": "httptools",
        "workerFormula": "(2 Ã— CPU cores + 1)",
        "performanceGain": "2-4x over standard"
      },
      "httpClient": {
        "library": "aiohttp",
        "version": "3.9.5",
        "versionConstraint": "CRITICAL: Pin to 3.9.5 - versions 3.10+ have severe memory leaks",
        "memoryLeakIssue": {
          "affectedVersions": "3.10.0 and higher",
          "severity": "Severe memory leaks in production",
          "solution": "Pin to aiohttp==3.9.5 until issue resolved",
          "tracking": "Monitor aiohttp releases for fix"
        },
        "bestPractices": [
          "Single ClientSession per app",
          "Connection pooling",
          "Proper cleanup on shutdown",
          "Monitor memory usage in production"
        ]
      },
      "rateLimiting": {
        "library": "slowapi",
        "version": ">=0.1",
        "backend": "Redis for distributed",
        "limit": "30 requests/second per IP"
      },
      "compression": {
        "library": "zstandard",
        "version": ">=0.22",
        "method": "ZstdDecompressor().copy_stream()",
        "features": "Streaming decompression",
        "advantages": "Better compression ratio than gzip for rustdoc JSON files"
      },
      "jsonParsing": {
        "library": "ijson",
        "version": ">=3.2.0",
        "purpose": "Memory-efficient streaming JSON parsing",
        "use_case": "Parse large rustdoc JSON files without loading entire file into memory",
        "method": "ijson.parse() for streaming, ijson.items() for extracting objects",
        "benefits": [
          "Constant memory usage regardless of file size",
          "Ability to process 100MB+ JSON files efficiently",
          "Compatible with compressed streams"
        ],
        "performanceOptimization": {
          "version": "3.4.0",
          "backend": "yajl2",
          "performanceGain": "656x over pure Python implementation",
          "implementation": "Use ijson with yajl2 backend for maximum performance",
          "significance": "Critical for processing large rustdoc JSON files efficiently"
        }
      },
      "retryLogic": {
        "library": "tenacity",
        "version": ">=8.0.0",
        "purpose": "Robust retry mechanisms for HTTP requests",
        "features": [
          "Exponential backoff with jitter",
          "Configurable retry conditions",
          "Maximum retry limits",
          "Integration with async/await"
        ],
        "use_case": "Handle network failures when downloading rustdoc JSON files"
      }
    },
    "security": {
      "mcpSecurity": {
        "schemaPoisoning": {
          "risk": "MCP schema poisoning attacks via malicious tool definitions",
          "vulnerability": "Clients may accept and execute tools with misleading schemas",
          "mitigation": "Validate all schema fields, not just descriptions",
          "implementation": "Comprehensive schema validation beyond basic field checking",
          "impact": "Prevent malicious tools from masquerading as legitimate ones"
        },
        "parameterExtraction": {
          "attack": "Parameter extraction attacks via unused or hidden parameters",
          "vector": "Malicious parameters injected through unused schema fields",
          "prevention": "Strict parameter validation and allowlisting",
          "bestPractice": "Only accept explicitly defined and expected parameters",
          "implementation": "Reject requests containing undocumented parameters"
        },
        "productionSecurity": {
          "errorMasking": {
            "setting": "Enable mask_error_details=True in production",
            "purpose": "Prevent information leakage through error messages",
            "benefit": "Avoid exposing internal system details to clients",
            "implementation": "Configure FastMCP with error detail masking"
          },
          "schemaAllowlisting": {
            "approach": "Implement allowlisting for vetted tool schemas",
            "rationale": "Only permit execution of pre-approved and audited tools",
            "implementation": "Maintain curated list of approved MCP tool schemas",
            "maintenance": "Regular security review of approved schemas"
          }
        }
      }
    },
    "deployment": {
      "zeroInstall": {
        "tool": "uvx",
        "command": "uvx docsrs-mcp@latest",
        "gitSupport": "uvx --from git+https://..."
      },
      "containerization": {
        "baseImage": "python:slim",
        "minMemory": "256 MiB",
        "recommendedMemory": "1 GiB"
      },
      "platforms": [
        "Fly.io",
        "Railway",
        "Render",
        "Generic VPS"
      ]
    },
    "pythonTooling": {
      "uv": {
        "version": ">=0.4.0",
        "description": "Exclusive Python infrastructure tool for this project",
        "capabilities": [
          "Package management (replaces pip)",
          "Virtual environment management (replaces venv)",
          "Project execution (uvx for zero-install)",
          "Dependency resolution and locking",
          "Build system integration"
        ],
        "commands": {
          "development": [
            "uv sync --dev (install all dependencies)",
            "uv run python -m module (execute with project env)",
            "uv run pytest (run tests)",
            "uv add package (add dependency)",
            "uv remove package (remove dependency)"
          ],
          "distribution": [
            "uvx --from . docsrs-mcp (test local install)",
            "uvx --from git+URL docsrs-mcp (test from git)",
            "uv build (create distribution packages)"
          ]
        },
        "advantages": [
          "10-100x faster than pip for dependency resolution",
          "Built-in virtual environment management",
          "Zero-install execution with uvx",
          "Consistent lockfile management",
          "No mixing with other package managers needed"
        ],
        "projectStructure": {
          "configFile": "pyproject.toml",
          "lockFile": "uv.lock",
          "noRequirementsTxt": "All dependencies managed through pyproject.toml"
        },
        "deployment": {
          "uvx": {
            "description": "UV's zero-install execution tool for modern Python deployment",
            "capabilities": [
              "Execute packages without local installation",
              "Support for PyPI, Git URLs, and local paths",
              "Automatic virtual environment management",
              "Version pinning and dependency resolution"
            ],
            "commands": {
              "pypi": "uvx package@version",
              "git": "uvx --from git+https://repo.git package",
              "local": "uvx --from . package"
            },
            "advantages": [
              "No global package pollution",
              "Consistent execution environments",
              "Simplified distribution and deployment",
              "Eliminates 'works on my machine' issues"
            ]
          }
        }
      },
      "ruff": {
        "version": ">=0.1.0",
        "description": "Exclusive code quality tool - replaces multiple Python linters/formatters",
        "capabilities": [
          "Linting (replaces flake8, pylint, pycodestyle)",
          "Code formatting (replaces black, autopep8)",
          "Import sorting (replaces isort)",
          "Fast Rust-based implementation",
          "Single configuration in pyproject.toml"
        ],
        "commands": {
          "linting": [
            "uv run ruff check . (lint all files)",
            "uv run ruff check --fix . (lint and auto-fix)",
            "uv run ruff check --diff . (show potential changes)",
            "uv run ruff check path/to/file.py (lint specific file)"
          ],
          "formatting": [
            "uv run ruff format . (format all files)",
            "uv run ruff format --check . (check formatting without changes)",
            "uv run ruff format --diff . (show formatting changes)"
          ]
        },
        "advantages": [
          "10-100x faster than traditional Python tools",
          "Single tool replaces black + isort + flake8 + more",
          "Built-in auto-fix for many lint violations",
          "Comprehensive rule set with sensible defaults",
          "Excellent editor integration and LSP support"
        ],
        "configuration": {
          "location": "pyproject.toml under [tool.ruff]",
          "sections": [
            "[tool.ruff] - general settings",
            "[tool.ruff.lint] - linting rules",
            "[tool.ruff.format] - formatting options"
          ]
        },
        "consolidation": {
          "replaces": [
            "black (code formatting)",
            "isort (import sorting)",
            "flake8 (linting)",
            "pylint (advanced linting)",
            "pycodestyle (style checking)",
            "autopep8 (auto-formatting)",
            "bandit (some security checks)"
          ],
          "benefit": "Single tool reduces complexity, dependency conflicts, and configuration overhead",
          "performance": "Rust implementation provides 10-100x speed improvement over Python alternatives"
        }
      }
    },
    "bestPractices": {
      "projectConfiguration": {
        "pyprojectToml": {
          "role": "Single source of truth for all project configuration",
          "sections": [
            "[build-system] - Build requirements and backend",
            "[project] - Package metadata and dependencies",
            "[tool.uv] - UV-specific settings",
            "[tool.ruff] - Code quality configuration",
            "[tool.pytest] - Testing configuration"
          ],
          "advantages": [
            "Eliminates configuration file sprawl",
            "Standardized format across Python ecosystem",
            "Tool interoperability and consistency",
            "Simplified project setup and maintenance"
          ]
        },
        "semanticVersioning": {
          "importance": "Critical for dependency management and API evolution",
          "format": "MAJOR.MINOR.PATCH",
          "rules": [
            "MAJOR: Breaking changes",
            "MINOR: New features, backward compatible",
            "PATCH: Bug fixes, backward compatible"
          ],
          "automation": "Use tools like bump2version for consistent version management"
        }
      },
      "operationalDocumentation": {
        "performance": {
          "importance": "Critical for operational clarity and troubleshooting",
          "components": [
            "Expected response times under normal load",
            "Resource utilization patterns (CPU, memory, disk)",
            "Scaling characteristics and bottlenecks",
            "Performance degradation indicators",
            "Monitoring and alerting recommendations"
          ],
          "audience": "Operations teams, SREs, and production support staff"
        }
      }
    },
    "knownIssues": {
      "packageDistribution": {
        "pypiReadmeRendering": {
          "issue": "README rendering on PyPI requires careful markdown validation",
          "symptoms": [
            "Broken formatting in PyPI package description",
            "Missing or malformed content display",
            "HTML rendering issues in package metadata"
          ],
          "solutions": [
            "Validate markdown syntax with strict parsers",
            "Test README rendering with twine check before upload",
            "Use PyPI-compatible markdown subset",
            "Avoid complex HTML or non-standard markdown extensions"
          ],
          "prevention": "Include README validation in CI/CD pipeline"
        }
      }
    }
  },
  "recommendations": {
    "implementation": [
      "Start with FastMCP 2.11.1 for quick MCP server setup",
      "CRITICAL: Route all logging to stderr when using STDIO transport to prevent Claude Desktop communication corruption",
      "Leverage FastMCP dual-mode operation: REST for debugging, MCP for Claude integration",
      "Use Pydantic field validators with mode='before' to handle FastMCP string-to-numeric type coercion issues",
      "Design MCP manifests with anyOf patterns for flexible parameter types to accommodate client inconsistencies",
      "Use Union types in Pydantic models (e.g., Union[str, int]) to support flexible parameter acceptance",
      "Implement defensive parameter validation that handles both string and native type inputs",
      "MANDATORY: Use sqlite-vec 0.1.6 (sqlite-vss is deprecated)",
      "CRITICAL: Pin aiohttp to 3.9.5 to avoid memory leaks",
      "Use FastEmbed <0.7.0 for onnxruntime compatibility",
      "Implement aiosqlite for async database operations",
      "Use MATCH operator syntax for sqlite-vec queries",
      "Implement connection pooling for aiohttp from start",
      "Set up proper asyncio task management",
      "Use streaming decompression for large rustdoc files",
      "Prefer zstd decompression over gzip for docs.rs files for better performance",
      "Start with simple crate description parsing for MVP",
      "Implement streaming JSON parser with zero-copy deserialization for large files",
      "Use symbol interning for repeated string lookups in rustdoc JSON",
      "Parse rustdoc JSON on-demand rather than loading entire AST",
      "Always validate rustdoc format_version field before parsing",
      "Use semantic chunking with 50-200 token chunks for optimal search granularity",
      "Leverage sqlite-vec brute-force search for collections up to 1M vectors",
      "Implement binary quantization to reduce storage by 8x with minimal accuracy loss",
      "Utilize SIMD-accelerated distance calculations in sqlite-vec",
      "Use FastEmbed with ONNX runtime for 3x speedup over PyTorch",
      "Process embeddings in batches of 32 for optimal performance",
      "Keep memory under 1GB for 10k embeddings",
      "Stream large JSON files to avoid out-of-memory errors",
      "Extract module hierarchy from rustdoc 'paths' section",
      "Handle both workspace and single-crate scenarios in module extraction",
      "Validate all MCP schema fields, not just descriptions, to prevent schema poisoning",
      "Implement parameter allowlisting to prevent extraction attacks",
      "Enable mask_error_details=True in production for security",
      "Maintain allowlist of vetted tool schemas for production security",
      "Use ijson for memory-efficient parsing of large JSON files",
      "Implement per-crate locking to prevent duplicate ingestion",
      "Use tenacity for robust HTTP request retry mechanisms",
      "Set reasonable size limits for downloads and decompression",
      "Prefer .zst compressed format over .gz for rustdoc JSON files",
      "Pre-serialize vectors before batch insertion to reduce overhead",
      "Use SELECT last_insert_rowid() after aiosqlite.executemany() calls",
      "Respect SQLite's 999 parameter limit when designing batch operations",
      "Rely on sqlite-vec automatic indexing - no manual vss_index! calls needed",
      "Use ijson 3.4.0 with yajl2 backend for 656x performance improvement in JSON parsing",
      "Always validate rustdoc FORMAT_VERSION field before processing JSON files",
      "Handle both string and object representations of rustdoc item types dynamically",
      "Extract function and method signatures from inner.function.decl and inner.method.decl paths",
      "Use paths section mapping for parent ID resolution in rustdoc hierarchies",
      "Apply regex pattern r'```(?:rust)?\\s*\\n(.*?)```' for effective code example extraction",
      "Use NULL defaults for new database columns to maintain backward compatibility"
    ],
    "performance": [
      "Use semantic chunking with 50-200 tokens for optimal search granularity",
      "Leverage sqlite-vec brute-force performance up to 1M vectors before considering ANN",
      "Implement binary quantization for 8x storage reduction with minimal accuracy loss",
      "Utilize SIMD-accelerated distance calculations built into sqlite-vec",
      "Use FastEmbed with ONNX runtime for 3x performance improvement over PyTorch",
      "Batch embeddings in groups of 32",
      "Batch database inserts in groups of 1000",
      "Use uvloop for event loop optimization",
      "Implement caching at multiple levels",
      "Profile memory usage early and often",
      "Monitor aiohttp memory usage closely due to version constraints",
      "Use sqlite-vec MATCH operator for optimal query performance",
      "Include k constraint in all KNN queries for sqlite-vec",
      "Use streaming JSON parser with zero-copy deserialization for large rustdoc files",
      "Implement symbol interning for repeated string lookups in rustdoc parsing",
      "Parse rustdoc JSON on-demand rather than loading entire AST into memory",
      "Prefer zstd over gzip decompression for better performance on docs.rs files",
      "Use streaming decompression to avoid memory spikes",
      "Stream large JSON files during processing to avoid OOM conditions",
      "Keep embedding memory usage under 1GB for 10k vectors",
      "Implement LRU eviction based on file modification time",
      "Monitor download and decompression size limits",
      "Use one transaction per batch of 1000 records to prevent memory accumulation",
      "Pre-serialize vectors to bytes before batch processing for significant overhead reduction",
      "Leverage sqlite-vec v0.1.0 excellent performance for 384-dimensional vectors",
      "Use ijson 3.4.0 with yajl2 backend for 656x JSON parsing performance improvement over pure Python",
      "Implement streaming rustdoc JSON parsing to handle large files without memory spikes",
      "Optimize batch operations to respect SQLite's 999 parameter limit for maximum efficiency"
    ],
    "production": [
      "Configure proper worker count for uvicorn",
      "Set up distributed rate limiting with Redis",
      "Implement health checks and monitoring",
      "Use volume mounts for cache persistence",
      "Plan for horizontal scaling if needed"
    ]
  }
}