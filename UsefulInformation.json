{
  "projectName": "docsrs-mcp",
  "lastUpdated": "2025-08-05",
  "purpose": "Track errors, solutions, and lessons learned during development",
  "categories": {
    "commonErrors": {
      "description": "Frequently encountered errors and their solutions",
      "entries": [
        {
          "error": "SQLite threading error with aiosqlite",
          "context": "Database operations in async context",
          "solution": "Use aiosqlite properly with await db.execute() instead of synchronous calls",
          "prevention": "Always use await with aiosqlite operations, never mix sync/async database calls",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "no such function: vec_distance",
          "context": "Vector similarity search queries in SQLite with vss extension",
          "solution": "Use MATCH operator instead of vec_distance() function for vector searches",
          "prevention": "Reference sqlite-vss documentation for correct query syntax",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "LIMIT or 'k = ?' constraint required",
          "context": "Vector similarity search queries without proper constraints",
          "solution": "Add 'AND k = ?' parameter to MATCH queries to specify result count",
          "prevention": "Always include k parameter in vector search queries",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "ijson expects binary input but sometimes receives string",
          "context": "JSON streaming during ingestion pipeline processing",
          "solution": "Use io.BytesIO(json_content.encode()) instead of io.StringIO for binary input",
          "prevention": "Always ensure ijson receives bytes input by encoding strings first",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "AsyncMock context managers require proper setup",
          "context": "Testing async context managers with unittest.mock",
          "solution": "Set up __aenter__ and __aexit__ methods explicitly on AsyncMock objects",
          "prevention": "Use MagicMock for session objects or properly configure AsyncMock context manager methods",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "error": "Variable scope in exception handlers",
          "context": "Referencing variables in exception blocks that may not be defined",
          "solution": "Avoid referencing variables that may not be defined in exception scope",
          "prevention": "Initialize variables before try blocks or check existence in except blocks",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        }
      ]
    },
    "performanceIssues": {
      "description": "Performance bottlenecks and optimization strategies",
      "entries": [
        {
          "error": "Model loading delay on first request",
          "context": "Embedding model initialization causes slow first response",
          "solution": "Model loading happens on first embedding generation - expected behavior",
          "prevention": "Consider warming up models during server startup for production",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Large download and decompression memory usage",
          "context": "Ingesting large crates with streaming downloads and decompression",
          "solution": "Use streaming with reasonable limits: DOWNLOAD_CHUNK_SIZE=8KB, MAX_DOWNLOAD_SIZE=100MB, MAX_DECOMPRESSED_SIZE=100MB",
          "prevention": "Set appropriate memory limits and use chunked processing for large files",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        }
      ]
    },
    "integrationChallenges": {
      "description": "Issues with third-party services and libraries",
      "entries": [
        {
          "error": "SQLite extension loading issues",
          "context": "Loading sqlite-vss extension for vector operations",
          "solution": "Use SELECT load_extension() SQL command instead of direct Python extension loading",
          "prevention": "Always use SQL-based extension loading for better compatibility",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        }
      ]
    },
    "deploymentIssues": {
      "description": "Problems encountered during deployment",
      "entries": [
        {
          "error": "Server startup hanging terminal",
          "context": "Running development server blocks terminal session",
          "solution": "Use nohup and background process with PID tracking: 'nohup uv run docsrs-mcp > server.log 2>&1 & echo $!'",
          "prevention": "Always run servers in background for development, save PID for cleanup",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        }
      ]
    },
    "lessonsLearned": {
      "description": "Important insights gained during development",
      "entries": [
        {
          "lesson": "SQLite WAL mode improves concurrency",
          "context": "Database performance with concurrent access",
          "details": "WAL mode enabled for better concurrency in multi-user scenarios",
          "impact": "Reduced database lock contention",
          "dateLearned": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Embeddings caching strategy",
          "context": "Vector storage and reuse patterns",
          "details": "Embeddings cached in SQLite for reuse across sessions",
          "impact": "Significant performance improvement for repeated queries",
          "dateLearned": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Batch processing for embeddings",
          "context": "Optimizing embedding generation performance",
          "details": "Use EMBEDDING_BATCH_SIZE=32 for optimal balance between memory usage and processing speed",
          "impact": "Improved throughput while keeping memory usage reasonable",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Test isolation with cache directories",
          "context": "Integration testing with shared cache state",
          "details": "Always patch both ingest.CACHE_DIR and database.CACHE_DIR for integration tests to avoid state pollution",
          "impact": "Prevents test failures due to shared state between test runs",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["tests/test_ingest.py", "tests/test_app.py"]
        }
      ]
    }
  },
  "errorTemplate": {
    "error": "Error message or description",
    "context": "When/where the error occurred",
    "solution": "How the error was resolved",
    "prevention": "How to avoid this error in the future",
    "dateEncountered": "YYYY-MM-DD",
    "relatedFiles": ["file1.py", "file2.py"]
  },
  "knownLimitations": {
    "sqliteVss": {
      "issue": "1GB index size limit",
      "impact": "Cannot index very large crates",
      "workaround": "Implement chunking or use alternative vector DB for large crates"
    },
    "rustdocJson": {
      "issue": "Not all crates have rustdoc JSON available",
      "impact": "Cannot provide documentation for older crates",
      "workaround": "Return graceful error message without attempting local build"
    },
    "windowsCompatibility": {
      "issue": "uvloop not compatible with Windows",
      "impact": "Performance degradation on Windows",
      "workaround": "Fallback to standard asyncio event loop on Windows"
    }
  },
  "debuggingTips": {
    "vectorSearch": [
      "Check embedding dimensions match (384 for BAAI/bge-small-en-v1.5)",
      "Verify FAISS index is properly initialized with vss_index!",
      "Monitor memory usage during batch operations",
      "Use MATCH operator instead of vec_distance() for queries",
      "Always include 'AND k = ?' parameter in vector search queries"
    ],
    "ingestion": [
      "Check asyncio.Lock is properly acquired/released",
      "Verify URL construction for docs.rs API",
      "Monitor decompression memory usage for large files",
      "Use await with all aiosqlite database operations",
      "Ensure ijson receives bytes input using io.BytesIO(content.encode())",
      "Set reasonable limits: MAX_DOWNLOAD_SIZE=100MB, MAX_DECOMPRESSED_SIZE=100MB",
      "Use DOWNLOAD_CHUNK_SIZE=8KB for streaming downloads",
      "Clean up test databases between runs to avoid state pollution"
    ],
    "rateLimiting": [
      "Ensure Redis is running for distributed limiting",
      "Check IP extraction middleware ordering",
      "Verify rate limit headers in responses"
    ],
    "serverManagement": [
      "Start server: nohup uv run docsrs-mcp > server.log 2>&1 & echo $!",
      "Kill server: kill <PID>",
      "Test endpoints: curl -s http://localhost:8000/endpoint | jq .",
      "Check embeddings: sqlite3 cache/crate/version.db \"SELECT * FROM embeddings;\""
    ]
  },
  "performanceMetrics": {
    "targets": {
      "warmSearchLatency": "< 500ms P95",
      "coldIngestTime": "< 3s for 10MB crates",
      "memoryUsage": "< 1GB RSS",
      "cacheSize": "< 2GB total"
    },
    "optimizationStrategies": {
      "embedding": "Batch size 32 (EMBEDDING_BATCH_SIZE) for optimal CPU utilization",
      "database": "Insert batches of 1000 rows",
      "caching": "LRU eviction when > 2GB",
      "asyncio": "Use asyncio.gather for concurrent operations"
    }
  },
  "codeQuality": {
    "ruff": {
      "description": "Exclusive linting and formatting tool for this project",
      "replacesTools": ["black", "flake8", "isort", "pylint", "pycodestyle", "autopep8"],
      "commonCommands": {
        "lint": "uv run ruff check .",
        "lintFix": "uv run ruff check --fix .",
        "format": "uv run ruff format .",
        "formatCheck": "uv run ruff format --check .",
        "showDiff": "uv run ruff check --diff ."
      },
      "configurationTips": {
        "location": "pyproject.toml under [tool.ruff]",
        "basicSetup": {
          "lineLength": 88,
          "target-version": "py310",
          "selectRules": "Most rules enabled by default",
          "ignorePatterns": "Use 'exclude' for directories"
        },
        "commonRules": {
          "E": "pycodestyle errors",
          "W": "pycodestyle warnings", 
          "F": "Pyflakes",
          "I": "isort import sorting",
          "N": "pep8-naming",
          "UP": "pyupgrade"
        }
      },
      "integrationTips": [
        "Add ruff extension to VS Code for real-time feedback",
        "Configure pre-commit hook: 'uv run ruff check --fix && uv run ruff format'",
        "CI should run both 'ruff check' and 'ruff format --check'",
        "Use --fix flag in development, never in CI",
        "Ruff auto-fixes are safe and preserve code semantics"
      ],
      "performanceNotes": [
        "10-100x faster than traditional Python tools",
        "Processes entire codebase in milliseconds",
        "No need for separate tools or complex configuration"
      ]
    }
  }
}