{
  "projectName": "docsrs-mcp",
  "lastUpdated": "2025-08-07",
  "purpose": "Track errors, solutions, and lessons learned during development",
  "categories": {
    "commonErrors": {
      "description": "Frequently encountered errors and their solutions",
      "entries": [
        {
          "error": "SQLite threading error with aiosqlite",
          "context": "Database operations in async context",
          "solution": "Use aiosqlite properly with await db.execute() instead of synchronous calls",
          "prevention": "Always use await with aiosqlite operations, never mix sync/async database calls",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "no such function: vec_distance",
          "context": "Vector similarity search queries in SQLite with vss extension",
          "solution": "Use MATCH operator instead of vec_distance() function for vector searches",
          "prevention": "Reference sqlite-vss documentation for correct query syntax",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "LIMIT or 'k = ?' constraint required",
          "context": "Vector similarity search queries without proper constraints",
          "solution": "Add 'AND k = ?' parameter to MATCH queries to specify result count",
          "prevention": "Always include k parameter in vector search queries",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "ijson expects binary input but sometimes receives string",
          "context": "JSON streaming during ingestion pipeline processing",
          "solution": "Use io.BytesIO(json_content.encode()) instead of io.StringIO for binary input",
          "prevention": "Always ensure ijson receives bytes input by encoding strings first",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "AsyncMock context managers require proper setup",
          "context": "Testing async context managers with unittest.mock",
          "solution": "Set up __aenter__ and __aexit__ methods explicitly on AsyncMock objects",
          "prevention": "Use MagicMock for session objects or properly configure AsyncMock context manager methods",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "error": "Variable scope in exception handlers",
          "context": "Referencing variables in exception blocks that may not be defined",
          "solution": "Avoid referencing variables that may not be defined in exception scope",
          "prevention": "Initialize variables before try blocks or check existence in except blocks",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "cursor.lastrowid returns None when using executemany() in aiosqlite",
          "context": "Batch insert operations needing to track inserted row IDs",
          "solution": "Use 'SELECT last_insert_rowid()' after executemany() to get the last inserted rowid",
          "prevention": "Never rely on cursor.lastrowid with executemany(), always use SQL query for rowid",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "SQLite parameter limit exceeded in batch operations",
          "context": "Inserting large batches with multiple parameters per row",
          "solution": "SQLite parameter limit is 999, not 1000 - calculate batch size as 999 // params_per_row",
          "prevention": "Always account for SQLite's 999 parameter limit when batching operations",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Loop variable overwriting in extract_code_examples",
          "context": "Variable name collision causing data loss in rustdoc parsing",
          "solution": "Use different variable names (cleaned_example vs example) to avoid overwriting loop variables",
          "prevention": "Always use distinct variable names in nested loops and data processing to prevent accidental overwrites",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Type matching too broad in rustdoc parsing",
          "context": "String matching 'type' in 'unknown_type' causing incorrect type categorization",
          "solution": "Use exact key matching in type_map dictionary instead of substring matching",
          "prevention": "Use precise key matching instead of substring matching for dictionary lookups to avoid false positives",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Path resolution not finding items without explicit path mapping",
          "context": "Items without path mappings in rustdoc JSON causing lookup failures",
          "solution": "Implement fallback to item name when no path mapping exists in rustdoc data",
          "prevention": "Always provide fallback mechanisms when working with optional or incomplete data structures",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Mock aiohttp sessions need proper async context manager setup",
          "context": "Testing async HTTP operations with unittest.mock.AsyncMock",
          "solution": "Mock aiohttp sessions need __aenter__ and __aexit__ methods configured for async context manager usage",
          "prevention": "Always configure AsyncMock context manager methods when testing async sessions or use MagicMock for session objects",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "error": "Rust version fetch failures break stdlib detection",
          "context": "Network issues or API failures when fetching current Rust version for stdlib crate filtering",
          "solution": "Always provide fallback version when fetching Rust version fails, use hardcoded recent version as default",
          "prevention": "Implement graceful degradation with fallback values for external API dependencies",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Rustdoc JSON URL pattern redirecting unexpectedly",
          "context": "Initial URL pattern /crate/{crate}/latest was redirecting to different endpoints",
          "solution": "Use new docs.rs API pattern /crate/{crate-name}/{version}/json for direct access",
          "prevention": "Always use version-specific URLs for docs.rs API to avoid redirect overhead",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Zstd compression not detected in HTTP responses",
          "context": "JSON responses were compressed but compression detection was failing",
          "solution": "Check magic bytes (0x28, 0xb5, 0x2f, 0xfd) to detect zstd compression instead of relying on headers",
          "prevention": "Always check magic bytes for compression detection as headers may be unreliable",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Module extraction receiving strings instead of dictionaries",
          "context": "build_module_hierarchy was receiving string paths instead of full path_info dictionaries",
          "solution": "Store full path_info dict in paths_data for hierarchy building instead of just path strings",
          "prevention": "Always preserve full data structures when building hierarchies to maintain context information",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Item kind field not directly available in rustdoc index",
          "context": "Kind field was not found directly in rustdoc JSON index items",
          "solution": "Extract kind from inner field as single-key dictionary instead of direct access",
          "prevention": "Always inspect rustdoc JSON structure carefully as fields may be nested unexpectedly",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Module names empty in hierarchy extraction",
          "context": "Module names were showing as empty in the extracted hierarchy structure",
          "solution": "Module name is last element of path array, not a separate name field",
          "prevention": "Understand rustdoc JSON path structure where item names are derived from path arrays",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        }
      ]
    },
    "performanceIssues": {
      "description": "Performance bottlenecks and optimization strategies",
      "entries": [
        {
          "error": "Model loading delay on first request",
          "context": "Embedding model initialization causes slow first response",
          "solution": "Model loading happens on first embedding generation - expected behavior",
          "prevention": "Consider warming up models during server startup for production",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Large download and decompression memory usage",
          "context": "Ingesting large crates with streaming downloads and decompression",
          "solution": "Use streaming with reasonable limits: DOWNLOAD_CHUNK_SIZE=8KB, MAX_DOWNLOAD_SIZE=100MB, MAX_DECOMPRESSED_SIZE=100MB",
          "prevention": "Set appropriate memory limits and use chunked processing for large files",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        }
      ]
    },
    "integrationChallenges": {
      "description": "Issues with third-party services and libraries",
      "entries": [
        {
          "error": "SQLite extension loading issues",
          "context": "Loading sqlite-vss extension for vector operations",
          "solution": "Use SELECT load_extension() SQL command instead of direct Python extension loading",
          "prevention": "Always use SQL-based extension loading for better compatibility",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        }
      ]
    },
    "deploymentIssues": {
      "description": "Problems encountered during deployment",
      "entries": [
        {
          "error": "Server startup hanging terminal",
          "context": "Running development server blocks terminal session",
          "solution": "Use nohup and background process with PID tracking: 'nohup uv run docsrs-mcp > server.log 2>&1 & echo $!'",
          "prevention": "Always run servers in background for development, save PID for cleanup",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        }
      ]
    },
    "mcpImplementation": {
      "description": "MCP server implementation patterns and solutions",
      "entries": [
        {
          "error": "STDIO corruption in MCP mode",
          "context": "Logging output interferes with MCP protocol communication",
          "solution": "Configure logging to stderr only in MCP mode to prevent STDIO corruption",
          "prevention": "Always configure logging handlers appropriately for MCP vs REST modes",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "FastAPI to MCP protocol conversion",
          "context": "Converting REST endpoints to MCP protocol automatically",
          "solution": "Use FastMCP.from_fastapi() to automatically convert REST endpoints to MCP protocol",
          "prevention": "Leverage FastMCP for seamless protocol conversion instead of manual implementation",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "MCP server testing difficulties",
          "context": "Testing MCP server requires background process management",
          "solution": "MCP server can be tested in background with nohup, kill with captured PID",
          "prevention": "Use proper background process management for MCP server testing",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "Claude Desktop MCP configuration",
          "context": "Configuring MCP server in Claude Desktop client",
          "solution": "Use simplified args: [\"docsrs-mcp\"] since MCP is now the default mode",
          "prevention": "MCP mode is default, no need for explicit --mode mcp flag in Claude Desktop config",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["claude_desktop_config.json"]
        },
        {
          "error": "MCP server debugging challenges",
          "context": "Debugging issues with MCP protocol communication",
          "solution": "Check server logs in stderr, use --mode rest flag for easier debugging",
          "prevention": "Use REST mode (--mode rest) for development debugging since MCP is now default",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "MCP parameter type coercion: string numerics not converted to integers",
          "context": "MCP clients (Claude Code) send k parameter as string \"3\" instead of integer 3, causing Pydantic validation error",
          "solution": "Add Pydantic field validator with mode='before' to convert string numbers to integers: @field_validator('k', mode='before')",
          "prevention": "FastMCP's automatic type conversion has known issues with string-to-int conversion. Always use Pydantic field validators with mode='before' for numeric parameters that MCP clients might send as strings",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "error": "MCP tool schema validation preventing field validator execution",
          "context": "searchItems tool fails with validation error when k parameter provided as string '5' by MCP clients. Error: \"'5' is not valid under any of the given schemas\"",
          "solution": "Update MCP manifest schema to use anyOf pattern accepting both string and integer types: 'anyOf': [{'type': 'integer'}, {'type': 'string'}]. This allows JSON Schema validation to pass so Pydantic field validator can perform type coercion",
          "prevention": "When FastMCP tools need to accept parameters that might come as different types, use anyOf schema pattern to handle double validation. MCP JSON Schema validates before Pydantic field validators can run, creating conflicts between type constraints and coercion logic",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"],
          "resolutionStatus": "Fixed and tested on 2025-08-05. Solution confirmed working with both integer and string k parameters"
        }
      ]
    },
    "lessonsLearned": {
      "description": "Important insights gained during development",
      "entries": [
        {
          "lesson": "SQLite WAL mode improves concurrency",
          "context": "Database performance with concurrent access",
          "details": "WAL mode enabled for better concurrency in multi-user scenarios",
          "impact": "Reduced database lock contention",
          "dateLearned": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Embeddings caching strategy",
          "context": "Vector storage and reuse patterns",
          "details": "Embeddings cached in SQLite for reuse across sessions",
          "impact": "Significant performance improvement for repeated queries",
          "dateLearned": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Batch processing for embeddings",
          "context": "Optimizing embedding generation performance",
          "details": "Use EMBEDDING_BATCH_SIZE=32 for optimal balance between memory usage and processing speed",
          "impact": "Improved throughput while keeping memory usage reasonable",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Test isolation with cache directories",
          "context": "Integration testing with shared cache state",
          "details": "Always patch both ingest.CACHE_DIR and database.CACHE_DIR for integration tests to avoid state pollution",
          "impact": "Prevents test failures due to shared state between test runs",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["tests/test_ingest.py", "tests/test_app.py"]
        },
        {
          "lesson": "Batch insert rowid relationship management",
          "context": "Maintaining foreign key relationships in batch database operations",
          "details": "When batch inserting related data, calculate rowid range using last_rowid - batch_size + 1 to map parent-child relationships",
          "impact": "Enables efficient batch processing while maintaining referential integrity",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Pre-serialize data before batch processing",
          "context": "Optimizing batch insert performance with repeated serialization",
          "details": "Pre-serialize vectors and other complex data structures before batching to avoid repeated serialization overhead",
          "impact": "Reduces CPU usage and improves batch processing performance",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Batch processing maintains constant memory usage",
          "context": "Memory optimization for large dataset processing",
          "details": "Proper batch processing keeps memory usage constant regardless of total dataset size, preventing OOM errors",
          "impact": "Enables processing of arbitrarily large datasets within memory constraints",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Test with >2x batch size for comprehensive validation",
          "context": "Ensuring batch processing logic handles multiple batches correctly",
          "details": "Create tests with datasets larger than 2x batch size to verify multiple batch handling and edge cases",
          "impact": "Catches off-by-one errors and batch boundary issues during development",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "lesson": "Ruff formatting automatically fixes whitespace issues in docstrings",
          "context": "Code quality and documentation formatting",
          "details": "Ruff's formatting automatically handles whitespace and indentation issues in docstrings, maintaining consistent documentation format",
          "impact": "Reduces manual formatting work and ensures consistent documentation style",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["pyproject.toml"]
        },
        {
          "lesson": "FastAPI metadata supports markdown in description field",
          "context": "API documentation and OpenAPI schema generation",
          "details": "FastAPI's app description field supports full markdown syntax for rich API documentation that appears in OpenAPI schema",
          "impact": "Enables better API documentation with formatted text, links, and examples",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Pydantic examples parameter provides inline examples in OpenAPI schema",
          "context": "API request/response documentation",
          "details": "Using 'examples' parameter in Pydantic models automatically generates example data in OpenAPI schema for better API documentation",
          "impact": "Improves API usability by providing clear examples in generated documentation",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Rate limiting documentation prevents user confusion with 429 errors",
          "context": "API error handling and user experience",
          "details": "Clear documentation of rate limits and proper HTTP 429 responses with retry headers helps users understand and handle rate limiting gracefully",
          "impact": "Reduces support requests and improves API adoption by making rate limits transparent",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "MCP manifest schemas need anyOf pattern for mixed-type parameters",
          "context": "MCP clients send parameters with inconsistent types (strings vs integers)",
          "details": "FastMCP has double validation - JSON Schema validation occurs before Pydantic field validators. Use anyOf: [{type: 'integer'}, {type: 'string'}] in MCP manifest to allow both types through schema validation, then handle type conversion in Pydantic with mode='before' field validators",
          "impact": "Enables robust parameter handling that works across different MCP client implementations",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Database schema changes need backward compatibility",
          "context": "Adding new columns to existing database tables during development",
          "details": "Use NULL defaults for new columns in ALTER TABLE statements to ensure backward compatibility with existing databases",
          "impact": "Prevents database migration issues and allows incremental schema updates",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Clear cache directory before testing enhanced parsing",
          "context": "Testing database schema changes and parsing improvements",
          "details": "Clear cache directory before testing enhanced parsing to ensure fresh database creation with new schema and updated parsing logic",
          "impact": "Prevents test failures caused by stale database schemas or cached parsing results",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "tests/"]
        },
        {
          "lesson": "Always run Ruff formatting before committing",
          "context": "Code quality and consistency maintenance",
          "details": "Use 'uv run ruff format .' before committing to ensure consistent code formatting across the project",
          "impact": "Maintains code quality and prevents formatting-related merge conflicts",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["pyproject.toml"]
        },
        {
          "lesson": "Use docs.rs as primary source for stdlib documentation",
          "context": "Rust standard library documentation integration",
          "details": "docs.rs provides comprehensive stdlib documentation access, simpler than attempting to use rust-docs-json component directly",
          "impact": "Simplifies stdlib documentation access and reduces complexity compared to local JSON parsing",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Set lookup for O(1) stdlib crate detection",
          "context": "Performance optimization for standard library crate identification",
          "details": "Use Python set data structure for stdlib crate names to achieve O(1) lookup performance instead of list iteration",
          "impact": "Significantly improves performance when processing many crates by eliminating linear search overhead",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Provide helpful error messages for stdlib download failures",
          "context": "User experience when stdlib documentation is unavailable",
          "details": "When stdlib documentation download fails, provide clear instructions explaining the limitation and suggesting alternatives",
          "impact": "Improves user experience by explaining limitations rather than showing cryptic errors",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Async generator compatibility patterns",
          "context": "Memory optimization implementation with streaming data processing",
          "details": "parse_rustdoc_items must be async generator but generate_embeddings should be sync generator. Mixing async and sync generators requires careful handling - use wrapper functions for backwards compatibility",
          "impact": "Enables streaming data processing while maintaining compatibility with existing sync code and tests",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Test compatibility with generators vs lists",
          "context": "Maintaining backwards compatibility during streaming implementation",
          "details": "Tests expect list-returning functions, not generators. Wrapper functions maintain backwards compatibility while enabling streaming optimizations. Integration tests are critical for streaming pipelines",
          "impact": "Allows incremental migration to streaming while preserving existing test suite",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "lesson": "Memory monitoring implementation patterns",
          "context": "Tracking memory usage during streaming operations",
          "details": "psutil.virtual_memory().percent gives system-wide usage, process.memory_info().rss for process-specific monitoring. Trigger GC after processing chunks of 100+ items for optimal memory management",
          "impact": "Enables proactive memory management preventing OOM errors during large dataset processing",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "MemoryMonitor context manager pattern",
          "context": "Operation-level memory tracking and reporting",
          "details": "Use MemoryMonitor context manager for operation tracking - pre-serialize vectors before batch processing, clear buffers and trigger GC between batches",
          "impact": "Provides structured memory management with clear operation boundaries and automatic cleanup",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Streaming error recovery strategies",
          "context": "Error handling in streaming data processing pipelines",
          "details": "Streaming requires different error recovery strategies than batch processing. Maintain per-batch transactions for database resilience, log memory status at key points for debugging",
          "impact": "Improves system resilience by enabling partial recovery from processing errors without losing all work",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Score normalization for ranking consistency",
          "context": "Implementing scoring algorithms for search ranking",
          "details": "Always normalize scores to [0, 1] range for consistency. Use max(0.0, min(1.0, score)) clamping to ensure valid score ranges across different ranking factors",
          "impact": "Prevents ranking inconsistencies and enables reliable score aggregation across multiple ranking factors",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Lazy imports for circular dependency resolution",
          "context": "Avoiding circular dependency issues in module imports",
          "details": "Lazy imports can resolve circular dependencies but may trigger linting warnings. Move imports to module level and use aliases (e.g., app_config) to avoid conflicts while maintaining clean code",
          "impact": "Resolves circular dependency issues while maintaining code quality and IDE support",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "SQLite connection pooling alternatives",
          "context": "Database performance optimization strategies",
          "details": "SQLite connections are lightweight; traditional connection pooling provides less benefit than query optimization. Focus on prepared statement caching and query optimization instead of connection pooling",
          "impact": "Optimizes development effort toward more impactful performance improvements for SQLite-based systems",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Over-fetching for re-ranking flexibility",
          "context": "Search result ranking and retrieval optimization",
          "details": "Over-fetch results (k+10) to allow for re-ranking without constraining initial retrieval. Fetch more results than needed, apply ranking algorithms, then return top k to user",
          "impact": "Enables sophisticated ranking algorithms without being constrained by initial retrieval limitations",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "LRU cache with TTL for search performance",
          "context": "Search result caching strategy for frequent queries",
          "details": "Cache search results with LRU eviction and TTL to improve response times for frequent queries. Balances memory usage with performance gains for repeated searches",
          "impact": "Significantly improves response times for repeated queries while managing memory usage effectively",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Always load sqlite-vec extension when testing database operations",
          "context": "Vector similarity search and database testing",
          "details": "The sqlite-vec extension must be loaded before performing any vector operations or database schema creation that depends on vector functionality. Failure to load the extension results in 'no such function' errors",
          "impact": "Prevents vector operation failures and ensures consistent database functionality across testing and production environments",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/database.py", "tests/"]
        },
        {
          "lesson": "Use Pydantic field_validator with mode='before' for flexible MCP parameter handling",
          "context": "MCP protocol parameter type conversion and validation",
          "details": "MCP clients may send parameters as different types (e.g., string '5' instead of integer 5). Using Pydantic field_validator with mode='before' allows flexible type conversion before validation. Combine with anyOf schema patterns in MCP manifests to pass JSON Schema validation",
          "impact": "Enables robust parameter handling across different MCP client implementations while maintaining type safety",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/models.py", "src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Partial indexes significantly improve performance for common filter patterns",
          "context": "Database query optimization for filtered searches",
          "details": "Creating partial indexes on commonly filtered columns (e.g., WHERE item_type = 'function') dramatically improves query performance for specific filter patterns. Partial indexes are smaller and more targeted than full column indexes",
          "impact": "Reduces query execution time for filtered searches by orders of magnitude, especially for common filter patterns",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Progressive filtering should only be used when result set is small (<10K items)",
          "context": "Search result filtering and performance optimization",
          "details": "Progressive filtering (applying filters after vector search) is only efficient when the initial result set is small. For large result sets, database-level filtering with proper indexes is more performant than in-memory filtering",
          "impact": "Prevents performance degradation when dealing with large datasets by choosing appropriate filtering strategies",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Use anyOf schema pattern in MCP manifests for parameters that may arrive as strings",
          "context": "MCP protocol schema validation and client compatibility",
          "details": "MCP clients may send numeric parameters as strings due to JSON serialization. Use anyOf: [{'type': 'integer'}, {'type': 'string'}] in MCP manifest schemas to handle this variability. This allows JSON Schema validation to pass so Pydantic field validators can perform type coercion",
          "impact": "Ensures compatibility with various MCP client implementations that may serialize parameters differently",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Check whitespace-only queries before stripping for proper error messages",
          "context": "Query preprocessing and user input validation",
          "details": "When validating user queries, check for whitespace-only content before stripping whitespace. This allows providing a specific error message for whitespace-only inputs instead of a generic 'empty query' message after stripping",
          "impact": "Provides more helpful and accurate error messages to users, improving user experience",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "NFKC normalization is irreversible but ideal for search and indexing",
          "context": "Unicode text normalization for search queries",
          "details": "Unicode NFKC (Normalization Form Compatibility Composition) is irreversible but excellent for search/indexing use cases. It handles ligatures (ﬀ → ff), fractions (½ → 1⁄2), superscripts/subscripts, and other compatibility characters. While information is lost, it creates consistent searchable text",
          "impact": "Improves search accuracy and consistency by normalizing varied Unicode representations to canonical forms",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Preserve special technical characters during Unicode normalization",
          "context": "Technical query processing with programming symbols",
          "details": "Technical queries often contain important special characters like :: (scope resolution), <> (generics), # (doc comments). Unicode NFKC normalization preserves these characters while still handling compatibility issues with ligatures and fractions",
          "impact": "Ensures technical search queries remain accurate while benefiting from Unicode normalization",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Provide helpful error messages with examples in Pydantic validators",
          "context": "User input validation and error reporting",
          "details": "Pydantic validators should include specific examples in error messages to help users understand what input is expected. For example, 'Query cannot be empty or contain only whitespace. Example: \"Vec::new\"' is more helpful than just 'Invalid query'",
          "impact": "Reduces user confusion and support requests by providing clear guidance on correct input format",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        }
      ]
    }
  },
  "errorTemplate": {
    "error": "Error message or description",
    "context": "When/where the error occurred",
    "solution": "How the error was resolved",
    "prevention": "How to avoid this error in the future",
    "dateEncountered": "YYYY-MM-DD",
    "relatedFiles": ["file1.py", "file2.py"]
  },
  "knownLimitations": {
    "sqliteVss": {
      "issue": "1GB index size limit",
      "impact": "Cannot index very large crates",
      "workaround": "Implement chunking or use alternative vector DB for large crates"
    },
    "rustdocJson": {
      "issue": "Not all crates have rustdoc JSON available",
      "impact": "Cannot provide documentation for older crates",
      "workaround": "Return graceful error message without attempting local build"
    },
    "windowsCompatibility": {
      "issue": "uvloop not compatible with Windows",
      "impact": "Performance degradation on Windows",
      "workaround": "Fallback to standard asyncio event loop on Windows"
    }
  },
  "debuggingTips": {
    "vectorSearch": [
      "Check embedding dimensions match (384 for BAAI/bge-small-en-v1.5)",
      "Verify FAISS index is properly initialized with vss_index!",
      "Monitor memory usage during batch operations",
      "Use MATCH operator instead of vec_distance() for queries",
      "Always include 'AND k = ?' parameter in vector search queries"
    ],
    "ingestion": [
      "Check asyncio.Lock is properly acquired/released",
      "Verify URL construction for docs.rs API",
      "Monitor decompression memory usage for large files",
      "Use await with all aiosqlite database operations",
      "Ensure ijson receives bytes input using io.BytesIO(content.encode())",
      "Set reasonable limits: MAX_DOWNLOAD_SIZE=100MB, MAX_DECOMPRESSED_SIZE=100MB",
      "Use DOWNLOAD_CHUNK_SIZE=8KB for streaming downloads",
      "Clean up test databases between runs to avoid state pollution",
      "Use 'SELECT last_insert_rowid()' after executemany() to get last inserted ID",
      "Calculate batch sizes as 999 // params_per_row to respect SQLite parameter limits",
      "Pre-serialize complex data before batching to avoid repeated serialization overhead",
      "Test batch logic with datasets >2x batch size to verify multiple batch handling",
      "Clear cache directory before testing enhanced parsing to ensure fresh database creation",
      "Use exact key matching in type dictionaries to avoid false positive substring matches",
      "Implement fallback mechanisms for optional data structures in rustdoc JSON",
      "Use distinct variable names in nested loops to prevent accidental overwrites",
      "Use docs.rs as primary source for stdlib docs instead of local rust-docs-json component",
      "Implement stdlib crate detection using set lookup for O(1) performance",
      "Configure AsyncMock context manager methods (__aenter__, __aexit__) when testing async sessions",
      "Always provide fallback version when external API calls (like Rust version fetch) fail",
      "Provide clear error messages with helpful instructions when stdlib download fails",
      "Use async generators for streaming data processing, sync generators for embedding batches",
      "Implement wrapper functions to maintain backwards compatibility between generators and lists",
      "Use MemoryMonitor context manager to track operation-level memory usage and cleanup",
      "Monitor both system-wide (psutil.virtual_memory().percent) and process-specific (process.memory_info().rss) memory usage",
      "Trigger garbage collection after processing 100+ items to maintain optimal memory usage",
      "Pre-serialize vectors and complex data structures before batch processing",
      "Clear buffers and trigger GC between batches in streaming operations",
      "Implement per-batch transactions for database resilience in streaming pipelines",
      "Log memory status at key processing points for debugging streaming operations",
      "Use integration tests to validate streaming pipeline error recovery",
      "Always load sqlite-vec extension before testing vector operations to prevent 'no such function' errors",
      "Create partial indexes for common filter patterns to dramatically improve query performance",
      "Use progressive filtering only for small result sets (<10K items) - prefer database-level filtering for large datasets",
      "Use version-specific docs.rs URLs (/crate/{name}/{version}/json) to avoid redirect overhead",
      "Check magic bytes (0x28, 0xb5, 0x2f, 0xfd) for zstd compression detection instead of relying on headers",
      "Store full path_info dictionaries instead of just path strings when building module hierarchies",
      "Extract item kind from inner field as single-key dictionary in rustdoc JSON parsing",
      "Module names are derived from last element of path arrays, not separate name fields",
      "Preserve full data structures when building hierarchies to maintain context information"
    ],
    "rateLimiting": [
      "Ensure Redis is running for distributed limiting",
      "Check IP extraction middleware ordering",
      "Verify rate limit headers in responses"
    ],
    "serverManagement": [
      "Start MCP server (default): nohup uv run docsrs-mcp > server.log 2>&1 & echo $!",
      "Start REST server: nohup uv run docsrs-mcp --mode rest > server.log 2>&1 & echo $!",
      "Alternative MCP: nohup uvx docsrs-mcp > server.log 2>&1 & echo $!",
      "Alternative REST: nohup uvx docsrs-mcp --mode rest > server.log 2>&1 & echo $!",
      "Kill server: kill <PID>",
      "Test REST endpoints: curl -s http://localhost:8000/endpoint | jq .",
      "Check embeddings: sqlite3 cache/crate/version.db \"SELECT * FROM embeddings;\""
    ],
    "mcpServer": [
      "Run MCP mode (default): uvx docsrs-mcp",
      "Test MCP server: nohup uvx docsrs-mcp > mcp.log 2>&1 & echo $!",
      "Debug with REST mode: uvx docsrs-mcp --mode rest (easier debugging)",
      "Check MCP logs: tail -f mcp.log (logs go to stderr in MCP mode)",
      "Claude Desktop config: Use simplified args: [\"docsrs-mcp\"]",
      "Kill MCP server: kill <PID> (use captured PID from nohup)",
      "Verify MCP protocol: Check that STDIO is clean, no stdout pollution",
      "FastMCP conversion: Use FastMCP.from_fastapi() for automatic REST-to-MCP conversion",
      "Parameter type issues: MCP clients may send numeric parameters as strings - use Pydantic field validators with mode='before' for type coercion",
      "Double validation conflicts: When MCP manifest schema is too restrictive, it prevents Pydantic field validators from running - use anyOf schema patterns for flexible type acceptance",
      "Schema flexibility: Use anyOf: [{'type': 'integer'}, {'type': 'string'}] in MCP manifests for parameters that may arrive as strings from different clients"
    ],
    "queryPreprocessing": [
      "Check for whitespace-only queries before stripping to provide specific error messages",
      "Use Unicode NFKC normalization for consistent search text while preserving technical characters",
      "Technical symbols (::, <>, #) are preserved during NFKC normalization",
      "NFKC handles ligatures (ﬀ → ff), fractions (½ → 1⁄2), and compatibility characters",
      "Include specific examples in Pydantic validator error messages for better user experience",
      "Test normalization with various Unicode inputs including mathematical symbols and ligatures",
      "Verify that programming syntax elements remain intact after normalization"
    ]
  },
  "performanceMetrics": {
    "targets": {
      "warmSearchLatency": "< 500ms P95",
      "coldIngestTime": "< 3s for 10MB crates",
      "memoryUsage": "< 1GB RSS",
      "cacheSize": "< 2GB total"
    },
    "optimizationStrategies": {
      "embedding": "Batch size 32 (EMBEDDING_BATCH_SIZE) for optimal CPU utilization",
      "database": "Insert batches respecting SQLite's 999 parameter limit, pre-serialize data",
      "caching": "LRU eviction when > 2GB",
      "asyncio": "Use asyncio.gather for concurrent operations",
      "batchProcessing": "Maintains constant memory usage regardless of dataset size",
      "memoryManagement": "Use MemoryMonitor context manager, trigger GC after 100+ items, pre-serialize before batching",
      "streaming": "Async generators for data processing, wrapper functions for backwards compatibility",
      "errorRecovery": "Per-batch transactions, memory status logging, streaming-aware error handling",
      "databaseOptimization": "Create partial indexes for common filter patterns, use progressive filtering only for small result sets (<10K items)",
      "extensionManagement": "Always load sqlite-vec extension before vector operations, especially in testing environments"
    }
  },
  "codeQuality": {
    "ruff": {
      "description": "Exclusive linting and formatting tool for this project",
      "replacesTools": ["black", "flake8", "isort", "pylint", "pycodestyle", "autopep8"],
      "commonCommands": {
        "lint": "uv run ruff check .",
        "lintFix": "uv run ruff check --fix .",
        "format": "uv run ruff format .",
        "formatCheck": "uv run ruff format --check .",
        "showDiff": "uv run ruff check --diff ."
      },
      "configurationTips": {
        "location": "pyproject.toml under [tool.ruff]",
        "basicSetup": {
          "lineLength": 88,
          "target-version": "py310",
          "selectRules": "Most rules enabled by default",
          "ignorePatterns": "Use 'exclude' for directories"
        },
        "commonRules": {
          "E": "pycodestyle errors",
          "W": "pycodestyle warnings", 
          "F": "Pyflakes",
          "I": "isort import sorting",
          "N": "pep8-naming",
          "UP": "pyupgrade"
        }
      },
      "integrationTips": [
        "Add ruff extension to VS Code for real-time feedback",
        "Configure pre-commit hook: 'uv run ruff check --fix && uv run ruff format'",
        "CI should run both 'ruff check' and 'ruff format --check'",
        "Use --fix flag in development, never in CI",
        "Ruff auto-fixes are safe and preserve code semantics",
        "Ruff formatting automatically fixes whitespace issues in docstrings"
      ],
      "ignorableWarnings": [
        "PLR0912 (too-many-branches): Can be ignored for documentation processing tasks",
        "PLR0915 (too-many-statements): Can be ignored for documentation processing tasks"
      ],
      "performanceNotes": [
        "10-100x faster than traditional Python tools",
        "Processes entire codebase in milliseconds",
        "No need for separate tools or complex configuration"
      ]
    }
  },
  "securityConsiderations": {
    "placeholders": {
      "securityEmail": {
        "issue": "Security contact placeholder (security@example.com) should be updated",
        "impact": "Users cannot report security issues properly",
        "action": "Replace security@example.com with actual security contact email",
        "relatedFiles": ["src/docsrs_mcp/app.py"]
      }
    }
  }
}