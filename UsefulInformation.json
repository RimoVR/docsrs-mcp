{
  "projectName": "docsrs-mcp",
  "lastUpdated": "2025-08-09",
  "purpose": "Track errors, solutions, and lessons learned during development",
  "categories": {
    "errorSolutions": {
      "description": "Solutions to specific errors encountered during development",
      "entries": [
        {
          "error": "CLI/MCP parameter synchronization issue - MCP mode checking args.pre_ingest directly instead of environment variables",
          "rootCause": "Inconsistent parameter handling between REST and MCP modes. MCP mode was checking args.pre_ingest directly instead of using environment variables",
          "solution": "Unified both modes to use config.PRE_INGEST_ENABLED environment variable. Set environment variables before module imports to ensure configuration visibility across different server modes.",
          "context": "MCP mode requires different parameter handling than CLI mode",
          "lesson": "Always use environment variables for configuration consistency across different server modes",
          "pattern": "Set environment variables before module imports to ensure configuration visibility",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["mcp_server.py", "src/docsrs_mcp/app.py"],
          "codeExample": "os.environ['PRE_INGEST_ENABLED'] = str(args.pre_ingest).lower() # Set before imports"
        },
        {
          "error": "Cold start latency of 1.4s on first embedding generation",
          "rootCause": "First embedding request triggers ONNX model loading into memory, causing significant delay",
          "solution": "Implement comprehensive embedding warmup on server startup with representative text samples and dual-mode support",
          "context": "First query loads ONNX model into memory causing delay",
          "implementation": [
            "Use 3-5 representative text samples (short, medium, long) for thorough model warmup",
            "Fire-and-forget pattern with asyncio.create_task() to avoid blocking server startup",
            "Global status tracking for health endpoint integration",
            "Dual-mode support: REST mode uses startup_event with asyncio, MCP mode uses threading with separate event loop"
          ],
          "pattern": "Fire-and-forget background warmup to eliminate cold-start latency",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/mcp_server.py"],
          "codeExample": "# REST mode\nasync def startup_event():\n    asyncio.create_task(warmup_embeddings())\n\n# MCP mode\ndef start_warmup_thread():\n    def warmup_worker():\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        loop.run_until_complete(warmup_embeddings())\n    threading.Thread(target=warmup_worker, daemon=True).start()\n\n# Shared warmup function\nasync def warmup_embeddings():\n    samples = ['short', 'medium length text sample', 'longer text sample for comprehensive model warmup']\n    await embed_model.embed(samples)"
        },
        {
          "error": "Fuzzy path matching not finding obvious matches",
          "solution": "Extend RapidFuzz scoring algorithm. Use token_sort_ratio() for unordered matches. Set preprocessing=false in RapidFuzz 3.0.0+ for case sensitivity. Implement bulk operations with process.extract().",
          "context": "Current fuzzy matching too strict for item paths",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "codeExample": "from rapidfuzz import process, fuzz; process.extract(query, choices, scorer=fuzz.token_sort_ratio, preprocessing=False)"
        },
        {
          "error": "FastEmbed memory leak with large batches",
          "solution": "Use generator pattern with explicit cleanup: process in small batches (16 for CPU), call gc.collect() between batches, and use streaming instead of loading all at once",
          "context": "FastEmbed v0.7.1 has known memory issues when processing large numbers of embeddings",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["ingest.py"],
          "references": ["https://github.com/qdrant/fastembed/issues/memory-leak"]
        },
        {
          "error": "Search returns only crate-level docs",
          "solution": "Modified module_pattern filtering to include both the module itself AND items within it using OR clause: 'WHERE (module_name = ? OR module_name LIKE ?) AND ...' instead of just exact module matching",
          "context": "Vector search was filtering too strictly and only returning crate-level documentation, missing specific module content",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "codeExample": "WHERE (embeddings.module_name = ? OR embeddings.module_name LIKE ?) AND embeddings.item_type != 'crate' AND embeddings.rowid IN (SELECT rowid FROM vss_embeddings WHERE vss_search(embeddings_vec, ?) AND k = ?)"
        },
        {
          "error": "sqlite-vec k parameter errors",
          "solution": "Added explicit 'AND k = ?' to WHERE clause as required by sqlite-vec. The k parameter must be included in the query constraints, not just as a LIMIT clause",
          "context": "sqlite-vec extension requires the k parameter to be explicitly specified in the WHERE clause for vector similarity searches",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "codeExample": "WHERE vss_search(embeddings_vec, ?) AND k = ?"
        },
        {
          "error": "Unhelpful validation error messages",
          "solution": "Enhanced validators to include valid ranges and examples in error messages. For example: 'k must be between 1-20, got 25. Use k=5 for standard results' instead of just 'invalid k value'",
          "context": "Generic validation errors made it difficult for users to understand what values were acceptable",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "codeExample": "raise ValueError(f'k must be between 1-{MAX_K}, got {k}. Use k=5 for standard results')"
        },
        {
          "error": "searchExamples returns fragmented characters",
          "solution": "Added defensive type checking and proper string wrapping to prevent character iteration. Ensure examples are treated as complete strings rather than iterables of characters",
          "context": "When examples were strings, they were being treated as iterables and returned character by character instead of as complete example strings",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "codeExample": "if isinstance(examples, str): examples = [examples]  # Wrap single string in list"
        },
        {
          "error": "NOT NULL constraint failed: embeddings.item_path",
          "context": "Ingestion pipeline crashes during rustdoc JSON parsing when items have empty paths",
          "rootCause": "The parsing logic in parse_rustdoc_items_streaming() uses 'path or name' which results in empty string when both are empty, violating the NOT NULL constraint",
          "solution": [
            "Added validate_item_path_with_fallback() function in validation.py that generates fallback paths",
            "Validation at parse time (ingest.py:1199) generates fallback paths like 'kind::item_id' when paths are empty",
            "Defensive validation in _store_batch() skips any chunks that still have invalid paths",
            "Fallback path patterns: 'item_kind::item_id' for items with IDs, 'item_kind::unknown_hash' for items without IDs"
          ],
          "prevention": "Always validate database fields that have NOT NULL constraints before insertion",
          "dateEncountered": "2025-08-09",
          "affectedVersions": "All versions prior to fix",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "src/docsrs_mcp/validation.py"],
          "codeExample": "def validate_item_path_with_fallback(path: str, name: str, item_kind: str, item_id: str) -> str:\n    if path:\n        return path\n    if name:\n        return name\n    # Generate fallback path\n    if item_id:\n        return f'{item_kind}::{item_id}'\n    return f'{item_kind}::unknown_{hash(str(item_kind))}'",
          "researchFindings": [
            "NOT NULL constraint failures are sqlite3.IntegrityError exceptions",
            "Use INSERT OR IGNORE to skip constraint violations gracefully", 
            "Validate data before database insertion to prevent constraint errors",
            "Fallback path generation ensures all items have valid identifiers"
          ]
        },
        {
          "error": "FastEmbed TextEmbedding global singleton memory leak",
          "solution": "Configure ONNX Runtime with sess_options.enable_cpu_mem_arena = False and implement explicit model lifecycle management. Use del session, gc.collect() for cleanup. Consider switching to lighter models like all-MiniLM-L6-v2.",
          "context": "Memory grows from 176MB to 1661MB after processing 3 crates due to ONNX Runtime sessions being retained indefinitely in global singleton",
          "rootCause": "FastEmbed v0.7.1 TextEmbedding global singleton retains ONNX Runtime sessions indefinitely without proper cleanup",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/ingest.py"],
          "codeExample": "# Configure ONNX Runtime environment variables:\nos.environ['ONNXRUNTIME_ENABLE_CPU_MEM_ARENA'] = '0'\nos.environ['ORT_DISABLE_ALL_OPTIMIZATION'] = '1'\n\n# Add cleanup function:\ndef cleanup_embedding_model():\n    global _embedding_model\n    if _embedding_model is not None:\n        del _embedding_model\n        _embedding_model = None\n        import gc\n        gc.collect()",
          "prevention": "Implement proper model lifecycle management and configure ONNX Runtime memory settings"
        },
        {
          "error": "MCP tool parameter validation failure - Input validation error: '50' is not valid under any of the given schemas",
          "solution": "Add anyOf patterns to MCP manifest schema like all other tools. Use anyOf: [{'type': 'integer'}, {'type': 'string'}] for numeric parameters and anyOf: [{'type': 'boolean'}, {'type': 'string'}] for boolean parameters to handle string parameters from MCP clients.",
          "context": "MCP clients often send numeric and boolean parameters as strings, causing validation failures when schemas are too restrictive. All MCP tools need anyOf patterns for parameter flexibility.",
          "rootCause": "Missing anyOf schema patterns in MCP manifest prevents JSON Schema validation from passing when MCP clients send string parameters",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "codeExample": "# In get_mcp_manifest() for all numeric/boolean parameters:\n'k': {\n    'type': 'integer',\n    'description': 'Number of results to return',\n    'anyOf': [{'type': 'integer'}, {'type': 'string'}]\n},\n'enabled': {\n    'type': 'boolean',\n    'description': 'Enable feature flag',\n    'anyOf': [{'type': 'boolean'}, {'type': 'string'}]\n}",
          "prevention": "Ensure all MCP tools with numeric or boolean parameters have anyOf patterns in manifest schema to handle string conversion"
        },
        {
          "error": "Search result duplicates from re-ingestion - Multiple entries with same item_path in results",
          "solution": "Add UNIQUE constraint/index on item_path column in embeddings table and use INSERT OR REPLACE pattern to handle duplicates gracefully.",
          "context": "embeddings table lacks UNIQUE constraint on item_path, causing duplicate entries when crates are re-ingested",
          "rootCause": "Database schema allows duplicate item_path entries without constraints",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"],
          "codeExample": "# Add UNIQUE constraint:\nCREATE UNIQUE INDEX idx_embeddings_item_path ON embeddings(item_path);\n\n# Use INSERT OR REPLACE pattern:\nINSERT OR REPLACE INTO embeddings (item_path, content, embeddings_vec, ...)\nVALUES (?, ?, ?, ...);\n\n# Alternative UPSERT pattern:\nINSERT INTO embeddings (item_path, content, embeddings_vec, ...)\nVALUES (?, ?, ?, ...)\nON CONFLICT(item_path) DO UPDATE SET\n    content = excluded.content,\n    embeddings_vec = excluded.embeddings_vec;",
          "prevention": "Design database schema with appropriate UNIQUE constraints from the beginning and use INSERT OR REPLACE for idempotent operations"
        },
        {
          "error": "UNIQUE constraint failed: embeddings.item_path",
          "solution": "Added in-batch deduplication using a seen_paths set to skip duplicates during ingestion before database insertion",
          "context": "Duplicate item_paths in rustdoc JSON data (up to 50% duplicates) caused constraint violations during batch insertion",
          "rootCause": "rustdoc JSON contains duplicate items with identical paths, causing UNIQUE constraint failures when inserting into embeddings table",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"],
          "codeExample": "seen_paths = set()\nfor item in items:\n    if item['path'] in seen_paths:\n        continue  # Skip duplicate\n    seen_paths.add(item['path'])\n    # Process item",
          "prevention": "Always deduplicate data before database insertion when UNIQUE constraints exist",
          "performanceImpact": "Deduplication reduces ingestion from 2806 to 1231 unique items for serde (~50% reduction)"
        },
        {
          "error": "no such module: vec0",
          "solution": "Removed triggers, implemented manual synchronization in _store_batch function instead of relying on SQLite triggers",
          "context": "SQLite triggers execute in a context where sqlite-vec extension isn't loaded, causing 'no such module: vec0' errors",
          "rootCause": "SQLite triggers execute in a limited context where extensions like sqlite-vec aren't available, preventing vec0 module access",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"],
          "codeExample": "# Instead of triggers, use manual sync:\nasync def _store_batch(self, items):\n    # Insert into embeddings\n    await cursor.executemany('INSERT INTO embeddings ...', items)\n    # Manual sync to vec_embeddings\n    await cursor.execute('INSERT INTO vec_embeddings SELECT rowid, embeddings_vec FROM embeddings WHERE rowid NOT IN (SELECT rowid FROM vec_embeddings)')",
          "prevention": "Avoid using database triggers with extension-dependent operations; implement synchronization in application code instead",
          "lessonLearned": "Virtual table extensions require careful session management and aren't available in all SQLite execution contexts"
        },
        {
          "error": "UNIQUE constraint failed on vec_embeddings primary key",
          "solution": "Added AUTOINCREMENT to embeddings table PRIMARY KEY to prevent rowid reuse after DELETE operations",
          "context": "Rowid reuse after DELETE operations without AUTOINCREMENT caused primary key conflicts in vec_embeddings virtual table",
          "rootCause": "SQLite reuses rowid values after DELETE operations when AUTOINCREMENT is not specified, causing conflicts with vector embeddings that reference these rowids",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/database.py"],
          "codeExample": "CREATE TABLE embeddings (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- Added AUTOINCREMENT\n    item_path TEXT NOT NULL UNIQUE,\n    -- other columns\n);",
          "prevention": "Use AUTOINCREMENT on PRIMARY KEY columns when foreign tables or virtual tables reference the rowid",
          "lessonLearned": "Virtual tables that reference rowids are sensitive to rowid reuse patterns"
        },
        {
          "error": "Pydantic RequestValidationError non-serializable fields in custom exception handlers",
          "solution": "When creating custom FastAPI exception handlers for RequestValidationError, convert error['input'] and error['ctx'] to strings before including in JSON responses. These fields may contain non-serializable objects like ValueError exceptions",
          "context": "Custom exception handlers for enhanced validation error messages",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["mcp_server.py", "src/docsrs_mcp/app.py"],
          "codeExample": "def format_error_detail(error: dict) -> str:\n    field = error.get('loc', [])[-1] if error.get('loc') else 'field'\n    value = str(error.get('input', 'unknown'))[:100]  # Convert to string\n    return f'{field} validation failed. Got: {value}'"
        },
        {
          "error": "Error message template inconsistency across validation handlers",
          "solution": "Use consistent template-based formatting with placeholders for field, value, constraints, and examples. Store templates in a dictionary for reusability and maintain consistent error message patterns across all validation functions",
          "context": "Standardizing validation error message formatting across the application",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/validation.py"],
          "codeExample": "ERROR_TEMPLATES = {\n    'invalid_type': '{field} must be {expected_type}. Got: {value}. Examples: {examples}',\n    'out_of_range': '{field} must be {constraint}. Got: {value}. Examples: {examples}'\n}",
          "prevention": "Define error message templates at module level for consistency and reusability"
        },
        {
          "error": "MCP parameter string-to-type conversion compatibility issues",
          "solution": "All numeric and boolean parameters must support string-to-type conversion for MCP clients using coercion functions with mode='before' validators. Handle None values first, then check existing type, then attempt string conversion with try/catch",
          "context": "MCP protocol compatibility requires flexible parameter type handling",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/models.py"],
          "codeExample": "@field_validator('k', mode='before')\n@classmethod\ndef validate_k(cls, v):\n    if v is None:\n        return None\n    if isinstance(v, int):\n        return v\n    if isinstance(v, str):\n        try:\n            return int(v.strip())\n        except ValueError:\n            raise ValueError(f'k must be integer. Got: {repr(v)[:100]}. Examples: 5, \"10\"')\n    raise ValueError(f'k must be integer. Got: {type(v).__name__}')"
        },
        {
          "error": "Circular import issues with validation utilities in field validators",
          "solution": "When using validation utilities in Pydantic field validators, import them inside the validator method to avoid circular imports. This is especially important when validation utilities are defined in the same module hierarchy",
          "context": "Pydantic field validator implementation patterns",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/models.py", "src/docsrs_mcp/validation.py"],
          "codeExample": "@field_validator('query', mode='before')\n@classmethod\ndef validate_query(cls, v):\n    from .validation import validate_query_string  # Import inside method\n    return validate_query_string(v)"
        },
        {
          "error": "API endpoint testing with incorrect URL patterns",
          "solution": "Use `/mcp/tools/` prefix for API endpoint tests, not just the tool name. FastAPI mounts MCP tools under this path structure for proper routing",
          "context": "Testing MCP tool endpoints through FastAPI test client",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["tests/"],
          "codeExample": "response = client.post('/mcp/tools/search_items', json={...})  # Correct\n# NOT: response = client.post('/search_items', json={...})  # Incorrect"
        },
        {
          "error": "Performance degradation from repeated template compilation",
          "solution": "Precompile error message templates and regex patterns at module level for better performance. Store compiled patterns in module-level constants rather than compiling them on each validation call",
          "context": "Optimizing validation error message generation performance",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/validation.py"],
          "codeExample": "import re\n\n# Module level - compiled once\nMODULE_PATH_PATTERN = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*(::[a-zA-Z_][a-zA-Z0-9_]*)*$')\nERROR_TEMPLATES = {\n    'invalid_path': 'Invalid module path format. Got: {value}. Examples: \"std::collections\", \"serde::de\"'\n}\n\ndef validate_module_path(value: str) -> str:\n    if not MODULE_PATH_PATTERN.match(value):\n        raise ValueError(ERROR_TEMPLATES['invalid_path'].format(value=repr(value)[:100]))\n    return value"
        }
      ]
    },
    "commonErrors": {
      "description": "Frequently encountered errors and their solutions",
      "entries": [
        {
          "error": "SQLite threading error with aiosqlite",
          "context": "Database operations in async context",
          "solution": "Use aiosqlite properly with await db.execute() instead of synchronous calls",
          "prevention": "Always use await with aiosqlite operations, never mix sync/async database calls",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "no such function: vec_distance",
          "context": "Vector similarity search queries in SQLite with vss extension",
          "solution": "Use MATCH operator instead of vec_distance() function for vector searches",
          "prevention": "Reference sqlite-vss documentation for correct query syntax",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "LIMIT or 'k = ?' constraint required",
          "context": "Vector similarity search queries without proper constraints",
          "solution": "Add 'AND k = ?' parameter to MATCH queries to specify result count",
          "prevention": "Always include k parameter in vector search queries",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "MCP parameter validation with anyOf schema pattern conflicts",
          "context": "MCP clients send strings for numeric parameters but schema validation fails",
          "solution": "Use anyOf: [{'type': 'integer'}, {'type': 'string'}] patterns in MCP manifest with Pydantic field validators using mode='before' for type coercion",
          "prevention": "Always include anyOf patterns for parameters that MCP clients might send as strings",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"]
        },
        {
          "error": "ijson expects binary input but sometimes receives string",
          "context": "JSON streaming during ingestion pipeline processing",
          "solution": "Use io.BytesIO(json_content.encode()) instead of io.StringIO for binary input",
          "prevention": "Always ensure ijson receives bytes input by encoding strings first",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "AsyncMock context managers require proper setup",
          "context": "Testing async context managers with unittest.mock",
          "solution": "Set up __aenter__ and __aexit__ methods explicitly on AsyncMock objects",
          "prevention": "Use MagicMock for session objects or properly configure AsyncMock context manager methods",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "error": "pytest-asyncio fixture compatibility issues in 0.23.x versions",
          "context": "Testing async functions and fixtures with pytest-asyncio",
          "solution": "Downgrade to pytest-asyncio==0.21.1 for stable async fixture support",
          "prevention": "Pin pytest-asyncio to 0.21.1 in development dependencies and avoid 0.23.x until issues are resolved",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["pyproject.toml", "tests/"],
          "command": "uv add --dev pytest-asyncio==0.21.1"
        },
        {
          "error": "prometheus-client memory leak warnings in high-cardinality scenarios",
          "context": "Prometheus metrics collection with many unique label combinations",
          "solution": "Monitor memory usage and implement label cardinality limits, use histogram buckets instead of individual metrics where possible",
          "prevention": "Design metric labels carefully to avoid high cardinality, regularly review metric memory footprint in production",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["monitoring/metrics.py"],
          "references": ["Prometheus best practices documentation on cardinality"]
        },
        {
          "error": "fetch_current_stable_version session parameter missing",
          "context": "HTTP session not properly passed to version fetching function",
          "solution": "Always pass aiohttp session parameter to fetch_current_stable_version function calls",
          "prevention": "Use type hints and validate session parameter in function signature",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/version_utils.py"],
          "pattern": "fetch_current_stable_version(session=session)"
        },
        {
          "error": "hypothesis module not found for property-based testing",
          "context": "Running property-based tests that require hypothesis library",
          "solution": "Install hypothesis for property-based testing support",
          "prevention": "Include hypothesis in development dependencies for comprehensive testing",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["tests/", "pyproject.toml"],
          "command": "uv add --dev hypothesis"
        },
        {
          "error": "Variable scope in exception handlers",
          "context": "Referencing variables in exception blocks that may not be defined",
          "solution": "Avoid referencing variables that may not be defined in exception scope",
          "prevention": "Initialize variables before try blocks or check existence in except blocks",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "cursor.lastrowid returns None when using executemany() in aiosqlite",
          "context": "Batch insert operations needing to track inserted row IDs",
          "solution": "Use 'SELECT last_insert_rowid()' after executemany() to get the last inserted rowid",
          "prevention": "Never rely on cursor.lastrowid with executemany(), always use SQL query for rowid",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "SQLite parameter limit exceeded in batch operations",
          "context": "Inserting large batches with multiple parameters per row",
          "solution": "SQLite parameter limit is 999, not 1000 - calculate batch size as 999 // params_per_row",
          "prevention": "Always account for SQLite's 999 parameter limit when batching operations",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Loop variable overwriting in extract_code_examples",
          "context": "Variable name collision causing data loss in rustdoc parsing",
          "solution": "Use different variable names (cleaned_example vs example) to avoid overwriting loop variables",
          "prevention": "Always use distinct variable names in nested loops and data processing to prevent accidental overwrites",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Type matching too broad in rustdoc parsing",
          "context": "String matching 'type' in 'unknown_type' causing incorrect type categorization",
          "solution": "Use exact key matching in type_map dictionary instead of substring matching",
          "prevention": "Use precise key matching instead of substring matching for dictionary lookups to avoid false positives",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Path objects in test mocks must use MagicMock with proper spec",
          "context": "Testing functions that check Path.exists() method with mocked Path objects",
          "solution": "Use MagicMock(spec=Path) and configure exists() method explicitly: mock_path = MagicMock(spec=Path); mock_path.exists.return_value = True",
          "prevention": "Always use spec parameter with MagicMock when mocking complex objects to ensure method availability",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["tests/test_ingest.py", "tests/test_app.py"]
        },
        {
          "error": "sqlite-vec MATCH operator requires explicit k parameter",
          "context": "Vector similarity search queries failing with 'A LIMIT or 'k = ?' constraint is required' error",
          "solution": "Always include explicit k parameter in MATCH queries: 'SELECT * FROM vec_table WHERE vec_column MATCH ? AND k = ?'",
          "prevention": "Never use MATCH operator without k parameter - sqlite-vec requires this constraint for all vector searches",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/database.py"]
        },
        {
          "error": "See-also suggestions showing duplicate results from original search",
          "context": "Implementing see-also functionality that excludes original search results to avoid redundancy",
          "solution": "Filter out original search results from suggestions using path exclusion: exclude_paths = {result.path for result in original_results}",
          "prevention": "Always exclude original search results when generating related suggestions to provide truly additional value",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "Similarity score calculation incorrect for sqlite-vec cosine distance",
          "context": "Converting sqlite-vec distance to similarity score for ranking purposes",
          "solution": "Use similarity = 1.0 - distance formula for cosine distance in sqlite-vec to get proper similarity scores (higher = more similar)",
          "prevention": "Remember sqlite-vec returns distance (lower = more similar), convert to similarity (higher = more similar) with 1.0 - distance",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "Test mocks for ingest_crate returning string instead of Path object",
          "context": "Testing ingest_crate function where db_path.exists() is called but mock returns string",
          "solution": "Mock ingest_crate to return Path object with exists() method: mock_result = MagicMock(spec=Path); mock_result.exists.return_value = True; return mock_result",
          "prevention": "When mocking functions that return Path objects, ensure the mock returns objects with proper Path methods configured",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["tests/test_app.py"]
        },
        {
          "error": "Path resolution not finding items without explicit path mapping",
          "context": "Items without path mappings in rustdoc JSON causing lookup failures",
          "solution": "Implement fallback to item name when no path mapping exists in rustdoc data",
          "prevention": "Always provide fallback mechanisms when working with optional or incomplete data structures",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Mock aiohttp sessions need proper async context manager setup",
          "context": "Testing async HTTP operations with unittest.mock.AsyncMock",
          "solution": "Mock aiohttp sessions need __aenter__ and __aexit__ methods configured for async context manager usage",
          "prevention": "Always configure AsyncMock context manager methods when testing async sessions or use MagicMock for session objects",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "error": "Rust version fetch failures break stdlib detection",
          "context": "Network issues or API failures when fetching current Rust version for stdlib crate filtering",
          "solution": "Always provide fallback version when fetching Rust version fails, use hardcoded recent version as default",
          "prevention": "Implement graceful degradation with fallback values for external API dependencies",
          "dateEncountered": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Rustdoc JSON URL pattern redirecting unexpectedly",
          "context": "Initial URL pattern /crate/{crate}/latest was redirecting to different endpoints",
          "solution": "Use new docs.rs API pattern /crate/{crate-name}/{version}/json for direct access",
          "prevention": "Always use version-specific URLs for docs.rs API to avoid redirect overhead",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Zstd compression not detected in HTTP responses",
          "context": "JSON responses were compressed but compression detection was failing",
          "solution": "Check magic bytes (0x28, 0xb5, 0x2f, 0xfd) to detect zstd compression instead of relying on headers",
          "prevention": "Always check magic bytes for compression detection as headers may be unreliable",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Module extraction receiving strings instead of dictionaries",
          "context": "build_module_hierarchy was receiving string paths instead of full path_info dictionaries",
          "solution": "Store full path_info dict in paths_data for hierarchy building instead of just path strings",
          "prevention": "Always preserve full data structures when building hierarchies to maintain context information",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Item kind field not directly available in rustdoc index",
          "context": "Kind field was not found directly in rustdoc JSON index items",
          "solution": "Extract kind from inner field as single-key dictionary instead of direct access",
          "prevention": "Always inspect rustdoc JSON structure carefully as fields may be nested unexpectedly",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Module names empty in hierarchy extraction",
          "context": "Module names were showing as empty in the extracted hierarchy structure",
          "solution": "Module name is last element of path array, not a separate name field",
          "prevention": "Understand rustdoc JSON path structure where item names are derived from path arrays",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "NameError: name 'Optional' is not defined",
          "context": "Code example extraction implementation missing Optional type import",
          "solution": "Added Optional to typing imports: 'from typing import Any, Optional'",
          "prevention": "Always import all required typing components when adding type hints",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "no such column: crate_version",
          "context": "Database schema missing crate_version column during code example queries",
          "solution": "Extract version from database filename pattern (e.g., '1.0.219.db' â†’ '1.0.219')",
          "prevention": "Extract crate version from database file path when schema doesn't include version column",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/app.py"]
        },
        {
          "error": "no such function: vec_distance_L2",
          "context": "sqlite-vec extension not loaded before vector similarity queries",
          "solution": "Load extension before queries: await db.enable_load_extension(True); await db.execute(f'SELECT load_extension(\'{sqlite_vec.loadable_path()}\')'); await db.enable_load_extension(False)",
          "prevention": "Always load sqlite-vec extension before performing any vector operations",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/app.py"]
        },
        {
          "error": "'str' object has no attribute 'get'",
          "context": "Backward compatibility issue with old list format vs new JSON format for code examples",
          "solution": "Handle both old list format and new JSON format: if isinstance(examples_data, list) and all(isinstance(e, str) for e in examples_data): examples_data = [{'code': e, 'language': 'rust', 'detected': False} for e in examples_data]",
          "prevention": "Always implement backward compatibility checks when changing data formats",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "searchExamples character fragmentation - returns individual characters instead of code blocks",
          "context": "ingest.py:761 and app.py:614-620 - for loop iterates over string as characters when examples_data is string type",
          "solution": "Add type check before iteration: if isinstance(examples_data, str): examples_data = [examples_data]; for example in examples_data: # Now safely iterate list. Applied in both generate_example_embeddings (ingest.py:758-762) and searchExamples (app.py:614-620)",
          "prevention": "Always validate data types before iteration, especially when data might be either string or list",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "src/docsrs_mcp/app.py"],
          "priority": "CRITICAL",
          "symptoms": [
            "Code examples unusable",
            "Each character returned as separate example",
            "Affects all crates with code examples"
          ],
          "rootCause": "String iteration returns characters when examples_data is string type instead of list",
          "testingVerification": "Verified with live MCP calls to serde crate",
          "resolutionStatus": "FIXED - Applied type guard pattern in both locations, tested and verified working",
          "fixPattern": "if isinstance(examples_data, str): examples_data = [examples_data]",
          "impact": "Fixed critical bug that rendered searchExamples unusable, now returns complete code blocks instead of individual characters"
        },
        {
          "error": "MCP parameter validation - numeric parameters like k=2 rejected",
          "context": "MCP manifest missing anyOf patterns for type flexibility with numeric values",
          "solution": "Update MCP manifest with anyOf pattern: 'k': {'anyOf': [{'type': 'integer'}, {'type': 'string'}]} in src/docsrs_mcp/app.py:151-297",
          "prevention": "Always use anyOf patterns in MCP manifests for parameters that may arrive as different types from various clients",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"],
          "note": "Models.py has coercion but manifest needs updating for JSON Schema validation"
        },
        {
          "error": "Path resolution exactness - common paths like serde::Deserialize return 404",
          "context": "Users expect common module paths to work but need exact rustdoc paths",
          "solution": "Add PATH_ALIASES dictionary in fuzzy_resolver.py with mappings like 'serde::Deserialize': 'serde::de::Deserialize', 'tokio::spawn': 'tokio::task::spawn', 'Result': 'std::result::Result'",
          "prevention": "Maintain common path aliases for frequently accessed items to improve user experience",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/fuzzy_resolver.py"],
          "currentBehavior": "Provides fuzzy suggestions but requires exact module paths"
        },
        {
          "error": "crates.io API returns different structure than expected",
          "context": "API response validation during crate data fetching",
          "solution": "Added response validation to check for required fields and anomalies (zero downloads for popular crates)",
          "prevention": "Always validate API responses for expected structure and detect data anomalies before processing",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "src/docsrs_mcp/api.py"]
        },
        {
          "error": "Concurrent cache file access can cause corruption",
          "context": "Multiple processes accessing cache files simultaneously",
          "solution": "Implemented file locking with FileLock and atomic writes (temp file + rename)",
          "prevention": "Use file locking mechanisms and atomic write operations for concurrent file access",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/cache.py"]
        },
        {
          "error": "API failures can cascade and overwhelm system",
          "context": "Multiple API failures causing system overload",
          "solution": "Circuit breaker pattern with 5-minute cooldown after 3 failures",
          "prevention": "Implement circuit breaker patterns to prevent cascading failures and system overload",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/api.py"]
        },
        {
          "error": "Search filtering excluding function-level items",
          "context": "Overly restrictive crate_pattern and module_pattern filters in database search queries",
          "solution": "Review filter logic in database.py lines 487-491 to ensure function-level items are not excluded by restrictive path pattern matching",
          "prevention": "Test search queries against diverse item types including functions, methods, and traits to ensure inclusive filtering",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "error": "sqlite-vec requires explicit k parameter in WHERE clauses",
          "context": "Vector similarity queries failing when using only LIMIT without k constraint",
          "solution": "Always use 'WHERE vector_column MATCH ? AND k = N' instead of relying on LIMIT clause for sqlite-vec queries",
          "prevention": "Remember sqlite-vec requires explicit k constraint in WHERE clause, not just LIMIT in query",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/app.py"]
        },
        {
          "error": "AttributeError: 'FixtureDef' object has no attribute 'unittest' with pytest 8.4.1 and pytest-asyncio 0.21.1",
          "context": "Running async tests during re-export auto-discovery implementation",
          "solution": "Upgrade to pytest-asyncio 1.1.0 which has Python 3.13 support and resolves compatibility issues",
          "prevention": "Always check version compatibility matrix when encountering fixture-related errors, especially after Python version upgrades",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["pyproject.toml", "tests/test_*.py"],
          "upgradeCommand": "uv add --dev pytest-asyncio>=1.1.0",
          "versionMatrix": {
            "pytest": ">=8.0.0",
            "pytest-asyncio": ">=1.1.0",
            "python": ">=3.10"
          }
        }
      ]
    },
    "performanceIssues": {
      "description": "Performance bottlenecks and optimization strategies",
      "performance_insights": [
        "ONNX Runtime offline optimization reduces startup by 60-80%",
        "Use ORT_ENABLE_EXTENDED for balanced performance without layout overhead",
        "Model quantization (fp32 to int8) reduces memory by 4x",
        "Request-scoped dependency caching in FastAPI avoids recomputation",
        "Adaptive batch sizing based on memory monitoring prevents OOM"
      ],
      "entries": [
        {
          "issue": "ONNX Runtime memory accumulation in FastEmbed",
          "impact": "Memory usage grows from 176MB to 1661MB after processing 3 crates",
          "solution": "Configure ONNX with sess_options.enable_cpu_mem_arena = False and implement explicit model lifecycle management",
          "optimizationStrategy": "Use lighter embedding models like all-MiniLM-L6-v2, implement explicit cleanup with del session and gc.collect()",
          "dateIdentified": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/ingest.py"],
          "measuredImpact": "Memory leak of ~1.5GB over 3 crate ingestions"
        },
        {
          "error": "Model loading delay on first request",
          "context": "Embedding model initialization causes slow first response",
          "solution": "Model loading happens on first embedding generation - expected behavior",
          "prevention": "Consider warming up models during server startup for production",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Large download and decompression memory usage",
          "context": "Ingesting large crates with streaming downloads and decompression",
          "solution": "Use streaming with reasonable limits: DOWNLOAD_CHUNK_SIZE=8KB, MAX_DOWNLOAD_SIZE=100MB, MAX_DECOMPRESSED_SIZE=100MB",
          "prevention": "Set appropriate memory limits and use chunked processing for large files",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "issue": "Example embeddings memory usage and search performance",
          "solution": "Implemented streaming generation with batch size 16 for CPU, hash-based deduplication to reduce storage by ~30%, and dedicated sqlite-vec tables for faster search",
          "context": "When generating embeddings for code examples, memory can accumulate quickly with FastEmbed. Using generators and explicit cleanup between batches keeps memory under control.",
          "dateDiscovered": "2025-08-07",
          "relatedFiles": ["ingest.py", "database.py"],
          "metrics": {
            "memoryUsage": "421MB for tokio crate",
            "searchLatency": "150-360ms warm, 1.4s cold (model loading)",
            "deduplicationRate": "~30% reduction in stored embeddings"
          }
        },
        {
          "issue": "Vector search performance bottlenecks",
          "solution": "Initial queries slow until vectors cached, implement cache warming for popular crates",
          "context": "First-time vector searches experience significant latency due to model loading and cache population",
          "dateDiscovered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "issue": "Memory spikes with large crates",
          "solution": "Already using streaming + generators, monitor with psutil for proactive management",
          "context": "Large crates can cause memory spikes despite streaming implementation",
          "dateDiscovered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Memory usage approaching 1GB limit during pre-ingestion",
          "context": "High memory usage during concurrent crate processing",
          "solution": "Added adaptive concurrency that reduces workers when RSS > 900MB",
          "prevention": "Monitor RSS memory usage and implement adaptive concurrency limits",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Cold start latency for popular crates",
          "context": "Initial requests for popular crates take too long to respond",
          "solution": "Pre-ingestion with priority queue ensures most-downloaded crates processed first",
          "prevention": "Implement pre-ingestion strategies with priority-based processing",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "error": "Cache staleness during high traffic",
          "context": "Cached data becomes stale during high-traffic periods",
          "solution": "Stale-while-revalidate pattern serves cached data while refreshing in background",
          "prevention": "Implement stale-while-revalidate caching patterns for high-traffic scenarios",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/cache.py"]
        },
        {
          "issue": "Fuzzy path matching performance bottleneck",
          "solution": "Consider Nucleo library for 6x faster path-specific fuzzy matching compared to current RapidFuzz implementation",
          "context": "Path resolution and fuzzy matching can be optimized for better search performance",
          "dateDiscovered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/fuzzy_resolver.py"]
        },
        {
          "issue": "Vector-only search lacking keyword relevance",
          "solution": "Implement hybrid search combining vector similarity (60%) with BM25 keyword search (40%) for better balanced results",
          "context": "Pure vector similarity may miss exact keyword matches that users expect",
          "dateDiscovered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/database.py"]
        },
        {
          "issue": "rustdoc JSON contains ~50% duplicate items",
          "impact": "Unnecessary processing and storage overhead during ingestion",
          "discovery": "Analysis of rustdoc JSON reveals up to 50% duplicate item_path entries across different crates",
          "solution": "Implemented in-batch deduplication using seen_paths set to skip duplicate processing",
          "optimization": "Deduplication reduces ingestion from 2806 to 1231 unique items for serde (~50% reduction in processing and storage)",
          "dateDiscovered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"],
          "measuredImpact": "50% reduction in database insertions and embedding calculations"
        }
      ]
    },
    "integrationChallenges": {
      "description": "Issues with third-party services and libraries",
      "entries": [
        {
          "error": "SQLite extension loading issues",
          "context": "Loading sqlite-vss extension for vector operations",
          "solution": "Use SELECT load_extension() SQL command instead of direct Python extension loading",
          "prevention": "Always use SQL-based extension loading for better compatibility",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "issue": "Cannot query vec_embeddings directly in sqlite3 CLI",
          "context": "Attempting to query vector tables from sqlite3 command line interface fails with extension errors",
          "rootCause": "sqlite-vec extension must be explicitly loaded in CLI sessions before accessing vec0 virtual tables",
          "workaround": "Load sqlite-vec extension first: .load /path/to/vec0 OR query through application that already has extension loaded",
          "lessonLearned": "Virtual table extensions require careful session management and aren't automatically available in all SQLite contexts",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/database.py"],
          "bestPractice": "Always verify extension is loaded before vec0 operations, whether in CLI or application context"
        }
      ]
    },
    "deploymentIssues": {
      "description": "Problems encountered during deployment",
      "entries": [
        {
          "error": "Server startup hanging terminal",
          "context": "Running development server blocks terminal session",
          "solution": "Use nohup and background process with PID tracking: 'nohup uv run docsrs-mcp > server.log 2>&1 & echo $!'",
          "prevention": "Always run servers in background for development, save PID for cleanup",
          "dateEncountered": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "Windows executable issues in CI/CD",
          "context": "Windows builds failing due to executable path resolution",
          "solution": "Use 'uv run' pattern consistently across all platforms instead of direct executable calls",
          "prevention": "Standardize on 'uv run' commands in CI workflows to ensure cross-platform compatibility",
          "dateEncountered": "2025-08-08",
          "relatedFiles": [".github/workflows/", "scripts/"]
        },
        {
          "error": "PyPI authentication token issues",
          "context": "Publishing to PyPI fails with authentication errors",
          "solution": "Use UV_PUBLISH_TOKEN environment variable, not UV_PUBLISH_PASSWORD for PyPI authentication",
          "prevention": "Always use UV_PUBLISH_TOKEN for PyPI publishing in CI/CD pipelines",
          "dateEncountered": "2025-08-08",
          "relatedFiles": [".github/workflows/publish.yml"]
        },
        {
          "error": "Background server testing hangs CI runners",
          "context": "CI/CD runners hang when testing servers without proper process management",
          "solution": "Use nohup with PID capture pattern: 'nohup uv run server > server.log 2>&1 & echo $!' and kill with captured PID",
          "prevention": "Never use bare background processes in CI, always capture PID for cleanup",
          "dateEncountered": "2025-08-08",
          "relatedFiles": [".github/workflows/test.yml", "scripts/test_server.sh"]
        },
        {
          "error": "UV cache deserialization errors between versions",
          "context": "Different UV versions in CI causing cache corruption and build failures",
          "solution": "Pin UV version in CI workflows or clear cache when UV version changes",
          "prevention": "Use consistent UV versions across all CI jobs and environments",
          "dateEncountered": "2025-08-08",
          "relatedFiles": [".github/workflows/", "uv.lock"]
        },
        {
          "error": "PyPI build compatibility issues",
          "context": "Package builds failing on PyPI due to source file inclusion",
          "solution": "Use 'uv build --no-sources' for PyPI-compatible builds that exclude source files",
          "prevention": "Test builds with --no-sources flag before publishing to ensure PyPI compatibility",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["pyproject.toml", ".github/workflows/publish.yml"]
        },
        {
          "error": "Self-hosted runner cache inefficiencies",
          "context": "Self-hosted runners using different cache strategies than GitHub-hosted runners",
          "solution": "Implement runner-specific cache strategies: local disk cache for self-hosted, GitHub Actions cache for hosted",
          "prevention": "Configure cache strategies based on runner type to optimize build performance",
          "dateEncountered": "2025-08-08",
          "relatedFiles": [".github/workflows/", "scripts/setup_cache.sh"]
        }
      ]
    },
    "mcpImplementation": {
      "description": "MCP server implementation patterns and solutions",
      "entries": [
        {
          "error": "STDIO corruption in MCP mode",
          "context": "Logging output interferes with MCP protocol communication",
          "solution": "Configure logging to stderr only in MCP mode to prevent STDIO corruption",
          "prevention": "Always configure logging handlers appropriately for MCP vs REST modes",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "FastAPI to MCP protocol conversion",
          "context": "Converting REST endpoints to MCP protocol automatically",
          "solution": "Use FastMCP.from_fastapi() to automatically convert REST endpoints to MCP protocol",
          "prevention": "Leverage FastMCP for seamless protocol conversion instead of manual implementation",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "MCP server testing difficulties",
          "context": "Testing MCP server requires background process management",
          "solution": "MCP server can be tested in background with nohup, kill with captured PID",
          "prevention": "Use proper background process management for MCP server testing",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "Claude Desktop MCP configuration",
          "context": "Configuring MCP server in Claude Desktop client",
          "solution": "Use simplified args: [\"docsrs-mcp\"] since MCP is now the default mode",
          "prevention": "MCP mode is default, no need for explicit --mode mcp flag in Claude Desktop config",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["claude_desktop_config.json"]
        },
        {
          "error": "MCP server debugging challenges",
          "context": "Debugging issues with MCP protocol communication",
          "solution": "Check server logs in stderr, use --mode rest flag for easier debugging",
          "prevention": "Use REST mode (--mode rest) for development debugging since MCP is now default",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "error": "MCP parameter type coercion: string numerics not converted to integers",
          "context": "MCP clients (Claude Code) send k parameter as string \"3\" instead of integer 3, causing Pydantic validation error",
          "solution": "Add Pydantic field validator with mode='before' to convert string numbers to integers: @field_validator('k', mode='before')",
          "prevention": "FastMCP's automatic type conversion has known issues with string-to-int conversion. Always use Pydantic field validators with mode='before' for numeric parameters that MCP clients might send as strings",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "error": "Pydantic field_validator decorator ordering with @classmethod",
          "context": "MCP parameter validation with custom field validators using @classmethod decorator",
          "solution": "Always use @field_validator BEFORE @classmethod decorator, not after. The correct order is: @field_validator('field_name', mode='before') followed by @classmethod",
          "prevention": "Remember decorator execution order: decorators are applied bottom-up, so @field_validator must come first to properly wrap the classmethod",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"],
          "resolutionStatus": "Critical decorator ordering pattern established for all future MCP parameter validators"
        },
        {
          "error": "MCP tool schema validation preventing field validator execution",
          "context": "searchItems tool fails with validation error when k parameter provided as string '5' by MCP clients. Error: \"'5' is not valid under any of the given schemas\"",
          "solution": "Update MCP manifest schema to use anyOf pattern accepting both string and integer types: 'anyOf': [{'type': 'integer'}, {'type': 'string'}]. This allows JSON Schema validation to pass so Pydantic field validator can perform type coercion",
          "prevention": "When FastMCP tools need to accept parameters that might come as different types, use anyOf schema pattern to handle double validation. MCP JSON Schema validates before Pydantic field validators can run, creating conflicts between type constraints and coercion logic",
          "dateEncountered": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"],
          "resolutionStatus": "Fixed and tested on 2025-08-05. Solution confirmed working with both integer and string k parameters"
        },
        {
          "error": "MCP client string parameter conversion validation patterns",
          "context": "Implementing robust parameter validation for MCP clients that send numeric values as strings",
          "solution": "Use comprehensive validation pattern: 1) Check for None first (return None or default), 2) Check if already correct type (return as-is), 3) Handle string conversion with try/catch, 4) Provide helpful error messages with examples, 5) Handle integer-to-float conversion for float fields",
          "prevention": "Always implement the full validation pattern for any numeric parameter that might arrive as a string from MCP clients. Test both native type and string conversion paths",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"],
          "resolutionStatus": "Comprehensive validation pattern established and tested with various input types"
        },
        {
          "error": "ValidationError vs ValueError in custom Pydantic validators",
          "context": "Testing MCP parameter validation with different error types from built-in vs custom validators",
          "solution": "Built-in Pydantic constraints raise ValidationError for direct type violations, while custom field_validator methods raise ValueError for string conversion failures. Test accordingly: expect ValidationError for direct types, ValueError for string conversion",
          "prevention": "Understand the distinction between Pydantic's built-in validation (ValidationError) and custom validator errors (ValueError) when writing tests",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["tests/test_app.py", "src/docsrs_mcp/models.py"],
          "resolutionStatus": "Error type patterns documented and test cases updated accordingly"
        },
        {
          "error": "Float string conversion error message patterns",
          "context": "Testing float parameter validation with invalid string inputs",
          "solution": "Use 'could not convert' in error message checks instead of 'invalid literal' for float string conversion failures. Python's float() function uses different error messages than int()",
          "prevention": "When testing string-to-float conversion errors, use appropriate error message patterns specific to float conversion",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["tests/test_app.py", "src/docsrs_mcp/models.py"],
          "resolutionStatus": "Float conversion error patterns identified and test assertions updated"
        },
        {
          "error": "MCP Manifest vs Implementation Discrepancy",
          "context": "Code review identified issues with boolean parameters that were actually handled correctly in implementation",
          "solution": "Update MCP manifest to use anyOf patterns for boolean parameters matching the approach for numeric parameters. Boolean parameters should use anyOf: [{'type': 'boolean'}, {'type': 'string'}] to handle string-to-boolean conversion",
          "prevention": "Always ensure MCP manifest schema matches the actual validation capabilities. When Pydantic validators can handle type coercion, the MCP manifest should use anyOf patterns to prevent JSON Schema validation from blocking the conversion",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"],
          "resolutionStatus": "Investigation complete - manifest schema alignment with implementation validation needed"
        },
        {
          "error": "MCP boolean parameter validation errors with string inputs",
          "context": "MCP clients sending boolean parameters as strings (e.g., 'true', 'false') caused validation errors in search_items tool",
          "solution": "Use anyOf pattern in MCP manifest schema: {'anyOf': [{'type': 'boolean'}, {'type': 'string'}]} to allow both boolean and string types through JSON Schema validation, then let Pydantic field validators handle conversion with mode='before'",
          "prevention": "FastMCP performs double validation - JSON Schema first, then Pydantic. anyOf patterns must be in the manifest schema to allow flexible types through to Pydantic validators. Follow existing numeric parameter patterns for consistency",
          "dateEncountered": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "additionalInfo": {
            "serverTesting": "Use --mode rest with docsrs-mcp to test MCP manifest endpoints at localhost:8000 (not 8080)",
            "validationFlow": "MCP manifest anyOf â†’ FastMCP JSON Schema validation â†’ Pydantic field_validator with mode='before' â†’ Boolean conversion",
            "patternConsistency": "Follow existing numeric parameter anyOf patterns for all flexible types"
          },
          "resolutionStatus": "Fixed and tested - boolean parameters now accept both native booleans and string representations"
        },
        {
          "lesson": "Critical searchExamples character fragmentation bug and testing methodology",
          "context": "searchExamples returns individual characters instead of complete code blocks due to string iteration bug",
          "solution": "Always test with direct MCP calls instead of REST to catch protocol-specific issues. Use fresh databases to avoid legacy data conflicts. Fix requires type checking before iteration in ingest.py:761",
          "prevention": "Implement comprehensive testing methodology: 1) Test searchExamples returns full code blocks not characters, 2) Test common path aliases resolve correctly, 3) Test numeric parameters accept both integer and string types, 4) Verify response times <500ms for warm queries, 5) Always use fresh databases for testing to avoid cached data issues",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "src/docsrs_mcp/app.py"],
          "testingMethodology": {
            "directMcpTesting": "Use mcp__docsrs__ tools directly instead of REST endpoints",
            "freshDatabases": "Always test with new DBs to avoid legacy data issues",
            "verificationSteps": [
              "1. Test searchExamples returns full code blocks",
              "2. Test common path aliases resolve",
              "3. Test numeric parameters accept both types",
              "4. Verify <500ms response times"
            ]
          }
        },
        {
          "error": "MCP clients sending numeric/boolean values as strings cause validation failures",
          "context": "MCP clients (including Claude Code) send parameters like k=2 as string '2' and boolean parameters as 'true'/'false' strings, causing JSON Schema validation errors before Pydantic field validators can perform type coercion",
          "solution": "Add anyOf patterns to all parameters with type coercion needs in the MCP manifest (app.py's get_mcp_manifest() function): 1) Numeric parameters: 'anyOf': [{'type': 'integer'}, {'type': 'string'}], 2) Boolean parameters: 'anyOf': [{'type': 'boolean'}, {'type': 'string'}], 3) Optional strings: 'anyOf': [{'type': 'string'}, {'type': 'null'}]. Important: anyOf patterns must be added in app.py's get_mcp_manifest() function, not in models.py",
          "prevention": "Always use anyOf patterns in MCP manifests for parameters that may arrive as different types from various clients. Test with both native types and strings using curl to ensure compatibility. All parameters with field validators in models.py need corresponding anyOf patterns in app.py",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"],
          "validationFlow": "MCP manifest anyOf â†’ FastMCP JSON Schema validation â†’ Pydantic field validators â†’ Type coercion",
          "testingNotes": "Verify with curl using both native types and strings: curl -X POST -H 'Content-Type: application/json' -d '{\"k\": \"5\"}' and curl -X POST -H 'Content-Type: application/json' -d '{\"k\": 5}'",
          "criticalDetails": {
            "manifestLocation": "app.py get_mcp_manifest() function around lines 151-297",
            "doubleValidation": "FastMCP performs JSON Schema validation before Pydantic field validators run",
            "patternRequired": "anyOf patterns are essential - restrictive schemas block field validator execution",
            "implementationNote": "Field validators handle conversion, manifest must allow types through"
          },
          "resolutionStatus": "FIXED - Applied anyOf patterns for numeric and boolean parameters, tested and verified working with both string and native type inputs"
        },
        {
          "error": "Path alias resolution for common Rust documentation paths",
          "context": "Users often use common aliases (serde::Deserialize) instead of full rustdoc paths (serde::de::Deserialize), causing 404 errors and poor user experience",
          "solution": "Implement static PATH_ALIASES dictionary with O(1) lookup before database query. Contains mappings like 'serde::Deserialize': 'serde::de::Deserialize', 'tokio::spawn': 'tokio::task::spawn', 'Result': 'std::result::Result'. Uses resolve_path_alias() function in fuzzy_resolver.py for efficient resolution",
          "prevention": "Maintain PATH_ALIASES dictionary with common path aliases for frequently accessed items. Update aliases based on user feedback and common usage patterns",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/fuzzy_resolver.py"],
          "performanceNotes": "Alias resolution adds <1ms overhead while maintaining sub-500ms response time requirement. O(1) dictionary lookup is extremely fast",
          "testingApproach": "Both unit tests for resolve_path_alias() function and integration tests for API endpoint ensure comprehensive coverage",
          "mcpTesting": "Use --mode rest flag to test with HTTP/curl instead of STDIO mode for easier debugging and verification"
        },
        {
          "lesson": "Multi-tier fallback for resilience",
          "context": "Building robust systems that handle various failure modes",
          "details": "Implementation pattern: Try API â†’ Load from disk â†’ Use expired memory cache â†’ Hardcoded fallback list",
          "impact": "System remains functional even during complete API outages",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/api.py", "src/docsrs_mcp/cache.py"]
        },
        {
          "lesson": "Binary serialization performance benefits",
          "context": "Cache loading performance optimization",
          "details": "msgpack reduces cache load time from 50ms (JSON) to 2ms for 100 crates",
          "impact": "25x improvement in cache loading performance",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/cache.py"]
        }
      ]
    },
    "lessonsLearned": {
      "description": "Important insights gained during development",
      "entries": [
        {
          "lesson": "SQLite WAL mode improves concurrency",
          "context": "Database performance with concurrent access",
          "details": "WAL mode enabled for better concurrency in multi-user scenarios",
          "impact": "Reduced database lock contention",
          "dateLearned": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Embeddings caching strategy",
          "context": "Vector storage and reuse patterns",
          "details": "Embeddings cached in SQLite for reuse across sessions",
          "impact": "Significant performance improvement for repeated queries",
          "dateLearned": "2025-08-04",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Batch processing for embeddings",
          "context": "Optimizing embedding generation performance",
          "details": "Use EMBEDDING_BATCH_SIZE=32 for optimal balance between memory usage and processing speed",
          "impact": "Improved throughput while keeping memory usage reasonable",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Test isolation with cache directories",
          "context": "Integration testing with shared cache state",
          "details": "Always patch both ingest.CACHE_DIR and database.CACHE_DIR for integration tests to avoid state pollution",
          "impact": "Prevents test failures due to shared state between test runs",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["tests/test_ingest.py", "tests/test_app.py"]
        },
        {
          "lesson": "Batch insert rowid relationship management",
          "context": "Maintaining foreign key relationships in batch database operations",
          "details": "When batch inserting related data, calculate rowid range using last_rowid - batch_size + 1 to map parent-child relationships",
          "impact": "Enables efficient batch processing while maintaining referential integrity",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Pre-serialize data before batch processing",
          "context": "Optimizing batch insert performance with repeated serialization",
          "details": "Pre-serialize vectors and other complex data structures before batching to avoid repeated serialization overhead",
          "impact": "Reduces CPU usage and improves batch processing performance",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Batch processing maintains constant memory usage",
          "context": "Memory optimization for large dataset processing",
          "details": "Proper batch processing keeps memory usage constant regardless of total dataset size, preventing OOM errors",
          "impact": "Enables processing of arbitrarily large datasets within memory constraints",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Test with >2x batch size for comprehensive validation",
          "context": "Ensuring batch processing logic handles multiple batches correctly",
          "details": "Create tests with datasets larger than 2x batch size to verify multiple batch handling and edge cases",
          "impact": "Catches off-by-one errors and batch boundary issues during development",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "lesson": "Ruff formatting automatically fixes whitespace issues in docstrings",
          "context": "Code quality and documentation formatting",
          "details": "Ruff's formatting automatically handles whitespace and indentation issues in docstrings, maintaining consistent documentation format",
          "impact": "Reduces manual formatting work and ensures consistent documentation style",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["pyproject.toml"]
        },
        {
          "lesson": "FastAPI metadata supports markdown in description field",
          "context": "API documentation and OpenAPI schema generation",
          "details": "FastAPI's app description field supports full markdown syntax for rich API documentation that appears in OpenAPI schema",
          "impact": "Enables better API documentation with formatted text, links, and examples",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Pydantic examples parameter provides inline examples in OpenAPI schema",
          "context": "API request/response documentation",
          "details": "Using 'examples' parameter in Pydantic models automatically generates example data in OpenAPI schema for better API documentation",
          "impact": "Improves API usability by providing clear examples in generated documentation",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Rate limiting documentation prevents user confusion with 429 errors",
          "context": "API error handling and user experience",
          "details": "Clear documentation of rate limits and proper HTTP 429 responses with retry headers helps users understand and handle rate limiting gracefully",
          "impact": "Reduces support requests and improves API adoption by making rate limits transparent",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "MCP manifest schemas need anyOf pattern for mixed-type parameters",
          "context": "MCP clients send parameters with inconsistent types (strings vs integers)",
          "details": "FastMCP has double validation - JSON Schema validation occurs before Pydantic field validators. Use anyOf: [{type: 'integer'}, {type: 'string'}] in MCP manifest to allow both types through schema validation, then handle type conversion in Pydantic with mode='before' field validators",
          "impact": "Enables robust parameter handling that works across different MCP client implementations",
          "dateLearned": "2025-08-05",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Database schema changes need backward compatibility",
          "context": "Adding new columns to existing database tables during development",
          "details": "Use NULL defaults for new columns in ALTER TABLE statements to ensure backward compatibility with existing databases",
          "impact": "Prevents database migration issues and allows incremental schema updates",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Clear cache directory before testing enhanced parsing",
          "context": "Testing database schema changes and parsing improvements",
          "details": "Clear cache directory before testing enhanced parsing to ensure fresh database creation with new schema and updated parsing logic",
          "impact": "Prevents test failures caused by stale database schemas or cached parsing results",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "tests/"]
        },
        {
          "lesson": "Always run Ruff formatting before committing",
          "context": "Code quality and consistency maintenance",
          "details": "Use 'uv run ruff format .' before committing to ensure consistent code formatting across the project",
          "impact": "Maintains code quality and prevents formatting-related merge conflicts",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["pyproject.toml"]
        },
        {
          "lesson": "Use docs.rs as primary source for stdlib documentation",
          "context": "Rust standard library documentation integration",
          "details": "docs.rs provides comprehensive stdlib documentation access, simpler than attempting to use rust-docs-json component directly",
          "impact": "Simplifies stdlib documentation access and reduces complexity compared to local JSON parsing",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Set lookup for O(1) stdlib crate detection",
          "context": "Performance optimization for standard library crate identification",
          "details": "Use Python set data structure for stdlib crate names to achieve O(1) lookup performance instead of list iteration",
          "impact": "Significantly improves performance when processing many crates by eliminating linear search overhead",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Provide helpful error messages for stdlib download failures",
          "context": "User experience when stdlib documentation is unavailable",
          "details": "When stdlib documentation download fails, provide clear instructions explaining the limitation and suggesting alternatives",
          "impact": "Improves user experience by explaining limitations rather than showing cryptic errors",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Async generator compatibility patterns",
          "context": "Memory optimization implementation with streaming data processing",
          "details": "parse_rustdoc_items must be async generator but generate_embeddings should be sync generator. Mixing async and sync generators requires careful handling - use wrapper functions for backwards compatibility",
          "impact": "Enables streaming data processing while maintaining compatibility with existing sync code and tests",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Test compatibility with generators vs lists",
          "context": "Maintaining backwards compatibility during streaming implementation",
          "details": "Tests expect list-returning functions, not generators. Wrapper functions maintain backwards compatibility while enabling streaming optimizations. Integration tests are critical for streaming pipelines",
          "impact": "Allows incremental migration to streaming while preserving existing test suite",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["tests/test_ingest.py"]
        },
        {
          "lesson": "Memory monitoring implementation patterns",
          "context": "Tracking memory usage during streaming operations",
          "details": "psutil.virtual_memory().percent gives system-wide usage, process.memory_info().rss for process-specific monitoring. Trigger GC after processing chunks of 100+ items for optimal memory management",
          "impact": "Enables proactive memory management preventing OOM errors during large dataset processing",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "MemoryMonitor context manager pattern",
          "context": "Operation-level memory tracking and reporting",
          "details": "Use MemoryMonitor context manager for operation tracking - pre-serialize vectors before batch processing, clear buffers and trigger GC between batches",
          "impact": "Provides structured memory management with clear operation boundaries and automatic cleanup",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Streaming error recovery strategies",
          "context": "Error handling in streaming data processing pipelines",
          "details": "Streaming requires different error recovery strategies than batch processing. Maintain per-batch transactions for database resilience, log memory status at key points for debugging",
          "impact": "Improves system resilience by enabling partial recovery from processing errors without losing all work",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Score normalization for ranking consistency",
          "context": "Implementing scoring algorithms for search ranking",
          "details": "Always normalize scores to [0, 1] range for consistency. Use max(0.0, min(1.0, score)) clamping to ensure valid score ranges across different ranking factors",
          "impact": "Prevents ranking inconsistencies and enables reliable score aggregation across multiple ranking factors",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Lazy imports for circular dependency resolution",
          "context": "Avoiding circular dependency issues in module imports",
          "details": "Lazy imports can resolve circular dependencies but may trigger linting warnings. Move imports to module level and use aliases (e.g., app_config) to avoid conflicts while maintaining clean code",
          "impact": "Resolves circular dependency issues while maintaining code quality and IDE support",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "SQLite connection pooling alternatives",
          "context": "Database performance optimization strategies",
          "details": "SQLite connections are lightweight; traditional connection pooling provides less benefit than query optimization. Focus on prepared statement caching and query optimization instead of connection pooling",
          "impact": "Optimizes development effort toward more impactful performance improvements for SQLite-based systems",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/database.py", "src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Over-fetching for re-ranking flexibility",
          "context": "Search result ranking and retrieval optimization",
          "details": "Over-fetch results (k+10) to allow for re-ranking without constraining initial retrieval. Fetch more results than needed, apply ranking algorithms, then return top k to user",
          "impact": "Enables sophisticated ranking algorithms without being constrained by initial retrieval limitations",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "LRU cache with TTL for search performance",
          "context": "Search result caching strategy for frequent queries",
          "details": "Cache search results with LRU eviction and TTL to improve response times for frequent queries. Balances memory usage with performance gains for repeated searches",
          "impact": "Significantly improves response times for repeated queries while managing memory usage effectively",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Always load sqlite-vec extension when testing database operations",
          "context": "Vector similarity search and database testing",
          "details": "The sqlite-vec extension must be loaded before performing any vector operations or database schema creation that depends on vector functionality. Failure to load the extension results in 'no such function' errors",
          "impact": "Prevents vector operation failures and ensures consistent database functionality across testing and production environments",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/database.py", "tests/"]
        },
        {
          "lesson": "Use Pydantic field_validator with mode='before' for flexible MCP parameter handling",
          "context": "MCP protocol parameter type conversion and validation",
          "details": "MCP clients may send parameters as different types (e.g., string '5' instead of integer 5). Using Pydantic field_validator with mode='before' allows flexible type conversion before validation. Combine with anyOf schema patterns in MCP manifests to pass JSON Schema validation",
          "impact": "Enables robust parameter handling across different MCP client implementations while maintaining type safety",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/models.py", "src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Partial indexes significantly improve performance for common filter patterns",
          "context": "Database query optimization for filtered searches",
          "details": "Creating partial indexes on commonly filtered columns (e.g., WHERE item_type = 'function') dramatically improves query performance for specific filter patterns. Partial indexes are smaller and more targeted than full column indexes",
          "impact": "Reduces query execution time for filtered searches by orders of magnitude, especially for common filter patterns",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/database.py"]
        },
        {
          "lesson": "Progressive filtering should only be used when result set is small (<10K items)",
          "context": "Search result filtering and performance optimization",
          "details": "Progressive filtering (applying filters after vector search) is only efficient when the initial result set is small. For large result sets, database-level filtering with proper indexes is more performant than in-memory filtering",
          "impact": "Prevents performance degradation when dealing with large datasets by choosing appropriate filtering strategies",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Use anyOf schema pattern in MCP manifests for parameters that may arrive as strings",
          "context": "MCP protocol schema validation and client compatibility",
          "details": "MCP clients may send numeric parameters as strings due to JSON serialization. Use anyOf: [{'type': 'integer'}, {'type': 'string'}] in MCP manifest schemas to handle this variability. This allows JSON Schema validation to pass so Pydantic field validators can perform type coercion",
          "impact": "Ensures compatibility with various MCP client implementations that may serialize parameters differently",
          "dateLearned": "2025-08-06",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "MCP parameter validation requires specific decorator ordering and validation patterns",
          "context": "Implementing robust parameter validation for MCP protocol compatibility",
          "details": "MCP parameter validation follows specific patterns: 1) Use @field_validator(mode='before') BEFORE @classmethod decorator (order matters!), 2) Check None first, then correct type, then string conversion, 3) Use anyOf schema in MCP manifest: {'anyOf': [{'type': 'integer'}, {'type': 'string'}]}, 4) Provide helpful error messages with examples, 5) Test both ValidationError (built-in constraints) and ValueError (custom validators)",
          "impact": "Enables robust parameter handling across different MCP client implementations while maintaining type safety and clear error reporting",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py", "src/docsrs_mcp/app.py", "tests/test_app.py"]
        },
        {
          "lesson": "Float vs integer string conversion have different error patterns",
          "context": "Testing numeric parameter validation with different data types",
          "details": "When testing string-to-numeric conversion failures: int() raises ValueError with 'invalid literal' message, while float() raises ValueError with 'could not convert' message. Test assertions must account for these different error message patterns",
          "impact": "Ensures comprehensive test coverage for numeric parameter validation across different data types",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["tests/test_app.py", "src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "MCP Double Validation Pattern requires anyOf schema flexibility",
          "context": "MCP tools have both JSON Schema and Pydantic validation layers",
          "details": "MCP protocol applies JSON Schema validation before Pydantic field validators can run. When clients send mixed types (e.g., string '5' for integer field), restrictive schemas block validation. Solution: Use anyOf patterns in JSON Schema for flexibility: {'anyOf': [{'type': 'integer'}, {'type': 'string'}]}, then handle coercion in Pydantic field validators",
          "impact": "Enables robust parameter handling across different MCP client implementations while maintaining type safety",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Decorator Order Critical for Pydantic field validators",
          "context": "MCP parameter validation with custom field validators using classmethod decorator",
          "details": "@field_validator must be placed BEFORE @classmethod decorator for proper decorator wrapping. Python decorators are applied bottom-up, so incorrect order (@classmethod @field_validator) prevents the validator from working properly. Correct pattern: @field_validator('field_name', mode='before') followed by @classmethod",
          "impact": "Ensures field validators execute correctly and prevent runtime validation failures",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "None Value Preservation in MCP parameter validators",
          "context": "Handling default values and None inputs in MCP parameter validation",
          "details": "Converting None to default values (e.g., 'latest') in validators breaks application logic that expects None for different default handling. Solution: Preserve None values in validators, handle defaults at application layer (e.g., in ingest_crate function). This allows proper conditional logic based on None vs explicit values",
          "impact": "Maintains proper application logic flow and enables different default handling strategies",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Error Message Best Practices for MCP parameter validation",
          "context": "Providing helpful error messages in Pydantic field validators",
          "details": "Comprehensive error messages should include: 1) Field name for context, 2) Examples of valid values for guidance, 3) What was actually received (truncated to 100 chars to prevent log spam), 4) Clear format pattern. Example: f'{field_name} must be X. Got: {repr(value)[:100]}. Examples: ...'. This helps users understand validation failures and correct their input",
          "impact": "Reduces user confusion and support requests by providing clear, actionable error messages",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Testing MCP Compatibility with multiple input types",
          "context": "Ensuring MCP parameter validation works across different client implementations",
          "details": "Comprehensive MCP validation testing requires: 1) Test with both native types (int, float) and string representations, 2) Use model_validate() to simulate JSON deserialization from MCP clients, 3) Verify whitespace trimming and null handling, 4) Test edge cases like empty strings and whitespace-only inputs, 5) Validate both ValidationError (built-in constraints) and ValueError (custom validators) paths",
          "impact": "Ensures compatibility with various MCP client implementations and prevents runtime failures",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["tests/test_app.py", "src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Check whitespace-only queries before stripping for proper error messages",
          "context": "Query preprocessing and user input validation",
          "details": "When validating user queries, check for whitespace-only content before stripping whitespace. This allows providing a specific error message for whitespace-only inputs instead of a generic 'empty query' message after stripping",
          "impact": "Provides more helpful and accurate error messages to users, improving user experience",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "NFKC normalization is irreversible but ideal for search and indexing",
          "context": "Unicode text normalization for search queries",
          "details": "Unicode NFKC (Normalization Form Compatibility Composition) is irreversible but excellent for search/indexing use cases. It handles ligatures (ï¬€ â†’ ff), fractions (Â½ â†’ 1â„2), superscripts/subscripts, and other compatibility characters. While information is lost, it creates consistent searchable text",
          "impact": "Improves search accuracy and consistency by normalizing varied Unicode representations to canonical forms",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Preserve special technical characters during Unicode normalization",
          "context": "Technical query processing with programming symbols",
          "details": "Technical queries often contain important special characters like :: (scope resolution), <> (generics), # (doc comments). Unicode NFKC normalization preserves these characters while still handling compatibility issues with ligatures and fractions",
          "impact": "Ensures technical search queries remain accurate while benefiting from Unicode normalization",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Provide helpful error messages with examples in Pydantic validators",
          "context": "User input validation and error reporting",
          "details": "Pydantic validators should include specific examples in error messages to help users understand what input is expected. For example, 'Query cannot be empty or contain only whitespace. Example: \"Vec::new\"' is more helpful than just 'Invalid query'",
          "impact": "Reduces user confusion and support requests by providing clear guidance on correct input format",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Module path validation edge cases require careful pattern checking",
          "context": "User input validation for module path patterns in search functionality",
          "details": "Simple strip() validation can make invalid patterns like 'runtime::' appear valid. Check for trailing/leading '::' before stripping whitespace to catch malformed module paths. Invalid patterns should fail validation with clear error messages",
          "impact": "Prevents invalid module path queries from reaching the database and provides clear feedback to users about correct module path syntax",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/models.py", "tests/test_app.py"]
        },
        {
          "lesson": "MCP manifest boolean parameter anyOf pattern implementation",
          "context": "Fixing MCP client boolean parameter validation errors in search_items tool",
          "details": "MCP clients can send boolean parameters as strings ('true', 'false') which fails JSON Schema validation. Solution requires anyOf pattern in manifest: {'anyOf': [{'type': 'boolean'}, {'type': 'string'}]}. This allows FastMCP's JSON Schema validation to pass so Pydantic field validators can perform conversion with mode='before'. Server testing shows port 8000 (not 8080) for REST mode endpoints",
          "impact": "Enables compatibility with MCP clients that serialize boolean parameters as strings while maintaining type safety through Pydantic validation",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "validationFlow": "MCP manifest anyOf â†’ FastMCP JSON Schema â†’ Pydantic field_validator â†’ Boolean conversion",
          "testingNotes": "Use --mode rest to test MCP manifest endpoints at localhost:8000"
        },
        {
          "lesson": "Code example extraction performance optimization",
          "context": "Implementation of search_examples functionality for retrieving code examples",
          "details": "search_examples successfully returns results in ~200ms for warm queries. Language detection adds minimal overhead during ingestion. Deduplication by hash is efficient for preventing duplicates during batch processing",
          "impact": "Enables fast code example retrieval with minimal performance impact from language detection and deduplication",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Backward compatibility patterns for data format changes",
          "context": "Handling transition from old list-based code examples to new JSON object format",
          "details": "When changing data formats, implement compatibility checks that detect old formats and convert them to new formats automatically. Example: detecting list of strings vs list of objects and converting appropriately with default values",
          "impact": "Ensures seamless upgrades without breaking existing cached data or requiring manual migration",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Database schema extraction patterns from file paths",
          "context": "Extracting metadata from database file structure when schema doesn't include all needed fields",
          "details": "When database schema lacks certain fields (like crate_version), extract information from file structure patterns. Use db_path.parent.name for crate name and db_path.stem for version from cache/{crate}/{version}.db structure",
          "impact": "Enables metadata extraction without requiring database schema changes or migrations",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Database path extraction pattern for module search",
          "context": "Converting database file paths to crate names for module pattern construction",
          "details": "Use db_path.parent.name to extract crate name from cache/{crate}/{version}.db structure. Module search patterns follow format: f'{crate_name}::{module_path}::%' for SQL LIKE queries",
          "impact": "Enables efficient module-scoped search by properly constructing database queries with correct crate and module path patterns",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Cache key generation must include all filter parameters",
          "context": "Maintaining cache consistency when adding new search parameters",
          "details": "When adding new filter parameters to search functions, always update _make_key(), get(), and set() methods to include the new parameters. Maintain consistent parameter ordering across all methods to ensure cache hits work correctly",
          "impact": "Prevents cache misses and incorrect result caching when new search parameters are added, ensuring search results remain accurate and performant",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "FastAPI validation error testing patterns",
          "context": "Testing Pydantic validation errors in FastAPI applications",
          "details": "FastAPI returns HTTP 422 status for Pydantic validation errors. Error details are available in response.json()['detail'] as an array of error objects. Test both the status code and specific error message content",
          "impact": "Enables comprehensive testing of input validation by properly checking both HTTP status and detailed error information",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["tests/test_app.py"]
        },
        {
          "lesson": "Background server testing with clean process management",
          "context": "Testing server applications without blocking terminal sessions",
          "details": "Use nohup with output redirection and PID capture for clean server testing: 'nohup uv run uvicorn docsrs_mcp.app:app > server.log 2>&1 & echo $!'. Capture the PID for clean shutdown with kill command",
          "impact": "Prevents terminal hanging during server testing and enables clean process cleanup, improving development workflow",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "SearchCache incompatibility with simple string caching needs",
          "context": "Implementing fuzzy path resolution with caching for performance",
          "details": "SearchCache is designed for embedding-based searches with complex cache key structures, not simple string-based path caching. For simple path caching needs, implement a basic dictionary cache with TTL instead of trying to adapt SearchCache to different use cases",
          "impact": "Prevents over-engineering caching solutions and ensures appropriate tool selection for specific caching requirements",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "FastAPI HTTPException detail format requirements",
          "context": "Returning structured error responses with suggestions in FastAPI",
          "details": "HTTPException with dictionary detail causes 500 error instead of proper status code handling. FastAPI expects string detail for proper error response processing. Include error suggestions directly in the error message text rather than as separate detail fields",
          "impact": "Ensures proper HTTP status code handling and prevents unexpected 500 errors when returning structured error information",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "TestClient async fixture compatibility patterns",
          "context": "Testing async endpoints with FastAPI TestClient and pytest fixtures",
          "details": "TestClient operates synchronously while async fixtures can cause compatibility issues. Mock at the appropriate abstraction level and use synchronous test functions with TestClient rather than trying to mix async fixtures with sync test clients",
          "impact": "Prevents test fixture compatibility issues and ensures reliable test execution patterns",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["tests/test_app.py"]
        },
        {
          "lesson": "RapidFuzz integration best practices for fallback search",
          "context": "Implementing fuzzy string matching as fallback for exact path lookups",
          "details": "RapidFuzz integrates cleanly with minimal code changes when used as fallback-only approach. This preserves exact match performance while adding fuzzy matching capability. Cache paths per crate to avoid repeated database queries and improve fuzzy search performance",
          "impact": "Enables fuzzy search capabilities without impacting exact match performance, providing better user experience for path resolution",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "SlowAPI rate limiting implementation gotchas",
          "context": "Implementing rate limiting with SlowAPI middleware in FastAPI applications",
          "details": "SlowAPI requires: 1) Request parameter MUST be included in endpoint function signatures or rate limiting won't work, 2) Middleware order matters - last added is outermost, 3) Memory backend doesn't share state between workers, use Redis for production, 4) Use limiter.limit() decorator on each endpoint that needs rate limiting, 5) Set app.state.limiter after app initialization for proper integration",
          "impact": "Ensures proper rate limiting implementation and prevents common configuration issues that lead to ineffective rate limiting",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/middleware.py", "src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Rate limiting testing requires concurrent request patterns",
          "context": "Testing rate limiting functionality to ensure proper enforcement",
          "details": "Effective rate limiting tests require: 1) Use concurrent requests (asyncio.gather) to test rate limiting behavior, 2) Verify both successful responses (200) and rate-limited responses (429), 3) Check that health/monitoring endpoints remain unprotected, 4) Test rate limit headers (X-RateLimit-*) in responses, 5) Validate that rate limits reset properly over time",
          "impact": "Ensures rate limiting works correctly under realistic concurrent load conditions and provides proper feedback to clients",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["tests/test_app.py", "src/docsrs_mcp/middleware.py"]
        },
        {
          "lesson": "Rate limiting integration patterns for clean code organization",
          "context": "Organizing rate limiting code for maintainability and separation of concerns",
          "details": "Best practices for rate limiting integration: 1) Create dedicated middleware.py for clean separation from main app logic, 2) Use limiter.limit() decorator on individual endpoints for granular control, 3) Set app.state.limiter after app initialization to ensure proper middleware access, 4) Add custom exception handler for RateLimitExceeded to provide consistent error responses, 5) Configure different limits for different endpoint types (search vs health checks)",
          "impact": "Maintains clean code architecture while enabling flexible and maintainable rate limiting configuration",
          "dateLearned": "2025-08-07",
          "relatedFiles": ["src/docsrs_mcp/middleware.py", "src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Path alias resolution implementation for improved user experience",
          "context": "Implementing path alias resolution to handle common user path shortcuts in Rust documentation search",
          "details": "Users often use common aliases like 'serde::Deserialize' instead of full rustdoc paths 'serde::de::Deserialize'. Solution: 1) Implement static PATH_ALIASES dictionary with O(1) lookup, 2) Create resolve_path_alias() function in fuzzy_resolver.py, 3) Add mapping for common patterns: serde::Deserialize â†’ serde::de::Deserialize, tokio::spawn â†’ tokio::task::spawn, Result â†’ std::result::Result, 4) Integrate before database query for minimal performance impact (<1ms overhead), 5) Test with both unit tests and integration tests for comprehensive coverage",
          "impact": "Significantly improves user experience by handling common path aliases automatically while maintaining sub-500ms response time requirements. Reduces 404 errors for commonly accessed items",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/fuzzy_resolver.py"],
          "testingStrategy": "Use --mode rest flag for easier HTTP/curl testing instead of STDIO mode during development and verification"
        },
        {
          "lesson": "PATH_ALIASES expansion for common Rust patterns",
          "context": "Improving path resolution for common Rust module patterns and shortcuts",
          "details": "Expand PATH_ALIASES in fuzzy_resolver.py with common patterns like 'tokio::spawn': 'tokio::task::spawn' to improve user experience when searching with abbreviated paths",
          "impact": "Reduces friction for users who use common shorthand patterns when searching for Rust functions and modules",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/fuzzy_resolver.py"],
          "implementationNotes": {
            "aliasPatterns": "Focus on commonly used shortcuts like tokio::spawn -> tokio::task::spawn",
            "performanceImpact": "O(1) dictionary lookup adds minimal overhead",
            "maintenanceStrategy": "Add aliases based on user feedback and common usage patterns"
          }
        },
        {
          "lesson": "Debug mode parameter for search query analysis",
          "context": "Adding debug capabilities for analyzing search query performance and scoring",
          "details": "Add debug=true parameter to search queries to return detailed scoring information including similarity scores, filter matches, and performance metrics",
          "impact": "Enables better understanding of search behavior and troubleshooting of relevance issues",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"],
          "implementationNotes": {
            "debugOutput": "Include similarity scores, filter matches, query timing, and result ranking details",
            "performanceConsideration": "Only enable debug output when explicitly requested to avoid performance overhead",
            "useCases": "Query optimization, relevance tuning, and search behavior analysis"
          }
        },
        {
          "lesson": "See-also suggestions implementation patterns",
          "context": "Implementing related suggestions functionality for search results with proper deduplication and graceful error handling",
          "details": "See-also suggestions require: 1) Exclude original search results to avoid duplicates using path exclusion sets, 2) Use similarity = 1.0 - distance for sqlite-vec cosine similarity scoring, 3) Add suggestions only to first search result to avoid UI redundancy, 4) Implement graceful degradation with empty suggestions array on any exception, 5) Mock Path objects with MagicMock(spec=Path) in tests with proper exists() method configuration",
          "impact": "Provides valuable related content discovery while maintaining clean UI and robust error handling",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py", "tests/test_app.py"],
          "implementationNotes": {
            "deduplication": "Use set comprehension for O(1) path exclusion: exclude_paths = {result.path for result in original_results}",
            "scoringFormula": "Convert distance to similarity: similarity = 1.0 - distance (sqlite-vec uses cosine distance)",
            "uiOptimization": "Add suggestions only to first result to prevent overwhelming the interface",
            "errorHandling": "Return empty suggestions array on exceptions to maintain search functionality",
            "testingPatterns": "Mock Path objects with spec parameter and configure exists() method explicitly"
          }
        },
        {
          "lesson": "Graceful degradation patterns for optional features",
          "context": "Implementing see-also suggestions as optional enhancement that doesn't break core functionality",
          "details": "Optional features should: 1) Never throw exceptions that break core functionality, 2) Return empty/null results on failure, 3) Log errors for debugging but continue execution, 4) Provide clear fallback behavior when external dependencies fail, 5) Design with graceful degradation from the start rather than adding it later",
          "impact": "Ensures core search functionality remains reliable even when optional features encounter errors",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "UI redundancy prevention in suggestion systems",
          "context": "Preventing information overload when displaying related suggestions to users",
          "details": "Suggestion systems should: 1) Only add suggestions to primary or first result to avoid repetition, 2) Exclude original search results from suggestions to provide new information, 3) Limit suggestion count to prevent overwhelming users (typically 3-5 suggestions), 4) Consider UI space and user attention when designing suggestion placement, 5) Make suggestions clearly distinguishable from primary results",
          "impact": "Improves user experience by providing valuable suggestions without cluttering the interface",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Rustdoc JSON impl block representation patterns",
          "context": "Implementing trait implementation search functionality in rustdoc JSON parsing",
          "details": "Rustdoc JSON represents impl blocks with empty names, requiring extraction from inner.trait and inner.for fields. Composite names like 'TraitName_for_TypeName' work well for impl block identification. Inherent impls (no trait) can be handled by checking for null trait field. The existing streaming parser architecture easily accommodates new item types without structural changes.",
          "impact": "Enables accurate trait implementation search without requiring database schema changes by leveraging existing item_type field patterns. Provides flexible naming scheme for both trait impls and inherent impls.",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/ingest.py"],
          "implementationNotes": {
            "emptyNames": "Impl blocks have empty name field - extract from inner.trait and inner.for instead",
            "compositeNaming": "Use 'TraitName_for_TypeName' pattern for trait implementations",
            "inherentImpls": "Check trait field for null to identify inherent implementations vs trait implementations",
            "streamingCompatible": "Existing streaming parser handles new impl item types without architecture changes",
            "schemaCompatible": "No database schema changes needed - uses existing item_type field infrastructure"
          },
          "parsingPatterns": {
            "traitImpl": "Extract from inner.trait.name and inner.for to create composite identifier",
            "inherentImpl": "Use inner.for as identifier when inner.trait is null",
            "typeExtraction": "Both trait and for fields may contain complex type information requiring careful parsing",
            "nameGeneration": "Generate meaningful searchable names from otherwise empty name fields in rustdoc JSON"
          }
        },
        {
          "lesson": "Background task reference management patterns",
          "context": "Implementing background schedulers with proper task lifecycle management",
          "details": "Background tasks must maintain strong references to prevent garbage collection. Use a set data structure (self.background_tasks = set()) to store task references, then add callback functions with task.add_done_callback(lambda t: self.background_tasks.discard(t)) for automatic cleanup when tasks complete",
          "impact": "Prevents background tasks from being garbage collected prematurely while ensuring proper cleanup to avoid memory leaks",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/scheduler.py"],
          "codePattern": "self.background_tasks = set(); task = asyncio.create_task(func()); self.background_tasks.add(task); task.add_done_callback(lambda t: self.background_tasks.discard(t))"
        },
        {
          "lesson": "Jitter implementation for distributed scheduler coordination",
          "context": "Preventing synchronized execution when multiple schedulers run simultaneously",
          "details": "Add random jitter to scheduler intervals using formula: base_interval + random.uniform(-jitter_range, jitter_range). Default Â±10% variance (jitter_range = base_interval * 0.1) provides good distribution without significantly affecting scheduling accuracy",
          "impact": "Prevents thundering herd problems when multiple scheduler instances start simultaneously, distributing load more evenly",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/scheduler.py"],
          "implementationNotes": {
            "formula": "jittered_interval = base_interval + random.uniform(-jitter_range, jitter_range)",
            "defaultVariance": "Â±10% of base interval",
            "purpose": "Load distribution and coordination prevention"
          }
        },
        {
          "lesson": "Memory-aware background task scheduling",
          "context": "Implementing resource-conscious background operations to prevent OOM errors",
          "details": "Check system memory usage before starting memory-intensive background tasks using psutil.virtual_memory().percent. Set reasonable thresholds (e.g., 80%) to leave headroom for memory spikes during processing. Skip operations when memory usage is too high and reschedule for next interval",
          "impact": "Prevents out-of-memory errors during background processing while maintaining system stability under varying load conditions",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/scheduler.py"],
          "implementationNotes": {
            "memoryCheck": "psutil.virtual_memory().percent < 80",
            "threshold": "80% leaves headroom for processing spikes",
            "fallbackBehavior": "Skip operation and wait for next scheduled interval"
          }
        },
        {
          "lesson": "Environment-driven scheduler configuration best practices",
          "context": "Making background schedulers configurable without requiring code changes",
          "details": "Use environment variables for all scheduler settings: enable/disable flags, intervals, memory thresholds, and jitter ranges. Default to enabled for better user experience but provide clear disable mechanism (SCHEDULER_ENABLED=false) for resource-constrained deployments. Document all configuration options clearly",
          "impact": "Enables flexible deployment configurations without code modifications while maintaining good defaults for most use cases",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/scheduler.py", "README.md"],
          "configurationPattern": {
            "enableFlag": "SCHEDULER_ENABLED (default: true)",
            "intervals": "Environment variables with reasonable defaults",
            "thresholds": "Configurable memory and resource limits",
            "jitter": "Configurable variance ranges"
          }
        },
        {
          "lesson": "Background task testing patterns with timeouts",
          "context": "Testing background schedulers and long-running tasks in test suites",
          "details": "Use asyncio.wait_for() with short timeouts when testing background tasks. Background tasks will timeout (expected behavior), but this allows testing of initialization, configuration, and cleanup without waiting for full execution cycles. Test both enabled and disabled states for backward compatibility",
          "impact": "Enables comprehensive testing of background task systems without extending test suite execution time or requiring complex mocking",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["tests/test_scheduler.py"],
          "testingPatterns": {
            "timeoutPattern": "asyncio.wait_for(background_task(), timeout=0.1)",
            "expectedBehavior": "TimeoutError is normal and expected",
            "statesTesting": "Test both enabled=True and enabled=False configurations",
            "cleanupTesting": "Verify proper task cleanup and reference management"
          }
        },
        {
          "lesson": "Simple direct field extension approach for Pydantic model enhancement",
          "context": "Adding tutorial fields to existing Pydantic models for enhanced API responses",
          "details": "When extending Pydantic models with new optional fields, direct field addition is more effective than complex nested model structures. Add Optional[str] fields directly to existing models (SearchResult, DocumentationItem) with appropriate default values (None). This approach maintains backward compatibility while enabling new functionality",
          "impact": "Enables clean model extensions without breaking existing API consumers or complicating model hierarchy",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "Ruff automatically formats Pydantic field definitions for consistency",
          "context": "Code formatting and Pydantic model field organization",
          "details": "Ruff's formatter automatically handles Pydantic field definition formatting, ensuring consistent spacing, alignment, and organization of field declarations. This includes proper handling of Optional types, default values, and field descriptions across model definitions",
          "impact": "Maintains consistent code style without manual formatting effort, improves code readability and maintainability",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/models.py", "pyproject.toml"]
        },
        {
          "lesson": "Tutorial content should be concise for token efficiency",
          "context": "Implementing tutorial fields with content length optimization",
          "details": "Tutorial content should be kept concise (15-30 tokens) to stay well under the 200 token limit per response. Focus on essential usage patterns, brief code examples, and key concepts rather than comprehensive documentation. This ensures tutorial additions enhance responses without significantly impacting token budgets",
          "impact": "Provides valuable tutorial information while maintaining efficient token usage and response performance",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/models.py", "src/docsrs_mcp/ingest.py"]
        },
        {
          "lesson": "Test both presence and content of tutorial fields for comprehensive validation",
          "context": "Testing strategies for optional Pydantic model fields",
          "details": "When testing tutorial field implementations, verify both field presence (is not None) and content quality. Test scenarios should include: 1) Fields are populated when tutorial content is available, 2) Content matches expected format and length constraints, 3) Fields remain None when no tutorial content exists, 4) Backward compatibility with clients not expecting tutorial fields",
          "impact": "Ensures tutorial field implementation works correctly across all use cases while maintaining backward compatibility",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["tests/test_app.py", "tests/test_models.py", "src/docsrs_mcp/models.py"]
        },
        {
          "lesson": "FastAPI/MCP automatically serializes optional None fields maintaining backward compatibility",
          "context": "API serialization behavior with optional Pydantic fields",
          "details": "FastAPI and MCP automatically handle serialization of optional fields with None values, maintaining backward compatibility with existing API consumers. Fields with None values are properly serialized in JSON responses, allowing clients to safely ignore fields they don't recognize while new clients can utilize the additional information",
          "impact": "Enables safe API extension without breaking existing integrations, supports gradual feature rollout",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/models.py", "src/docsrs_mcp/app.py"],
          "serializationBehavior": {
            "noneValues": "Serialized as null in JSON responses",
            "backwardCompatibility": "Existing clients can safely ignore new fields",
            "forwardCompatibility": "New clients can utilize additional tutorial information"
          }
        },
        {
          "lesson": "Pydantic model extension patterns for similar enhancements",
          "context": "Guidelines for future Pydantic model enhancements based on tutorial field implementation",
          "details": "Future Pydantic model extensions should follow established patterns: 1) Use Optional[Type] with None defaults for backward compatibility, 2) Add fields directly to existing models rather than creating nested structures, 3) Consider token efficiency for content fields, 4) Test both field presence and content validation, 5) Leverage Ruff for consistent formatting, 6) Verify serialization behavior maintains API compatibility",
          "impact": "Provides reusable patterns for future model enhancements, ensuring consistency and reliability across API evolution",
          "dateLearned": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/models.py"],
          "implementationChecklist": [
            "Use Optional[Type] with None defaults",
            "Add fields directly to existing models",
            "Consider content length and token efficiency",
            "Test field presence and content validation", 
            "Run Ruff formatting for consistency",
            "Verify backward/forward compatibility"
          ]
        },
        {
          "lesson": "RapidFuzz v3.0+ preprocessing changes for fuzzy matching implementation",
          "context": "Implementing enhanced fuzzy matching with composite scoring for path resolution",
          "details": "RapidFuzz v3.0+ removed default preprocessing - must explicitly use processor=default_process for case normalization. Unicode normalization is not built-in and requires unicodedata.normalize('NFC') for consistency. The resolve_path_alias function is async and tests must use @pytest.mark.asyncio with await calls",
          "impact": "Prevents fuzzy matching failures due to preprocessing changes and ensures proper test execution with async functions",
          "dateLearned": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/fuzzy_resolver.py", "tests/test_fuzzy_resolver.py"],
          "implementationNotes": {
            "preprocessing": "Must explicitly pass processor=default_process to RapidFuzz functions",
            "unicodeNormalization": "Use unicodedata.normalize('NFC', text) for consistent character representation",
            "asyncTesting": "All tests for resolve_path_alias must use @pytest.mark.asyncio and await",
            "versionCompatibility": "v3.0+ breaks backward compatibility with default preprocessing behavior"
          }
        },
        {
          "lesson": "Composite scoring algorithm significantly improves fuzzy matching accuracy",
          "context": "Enhanced path matching with multiple similarity algorithms for better results",
          "details": "Composite scoring using multiple RapidFuzz algorithms (ratio, token_sort_ratio, partial_ratio) with weighted averages provides ~25% better accuracy than single algorithm approaches. Path component bonuses help prioritize exact final component matches (e.g., 'Vec::new' gets bonus for exact 'new' match). This approach balances comprehensive similarity analysis with path-specific relevance",
          "impact": "Dramatically improves path resolution accuracy while maintaining performance, reduces false negatives in fuzzy search results",
          "dateLearned": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/fuzzy_resolver.py"],
          "implementationNotes": {
            "algorithms": "Combines ratio, token_sort_ratio, and partial_ratio with weighted averaging",
            "pathBonuses": "Final path component exact matches receive additional scoring bonus",
            "accuracyImprovement": "~25% better results compared to single algorithm approaches",
            "weightingStrategy": "Balanced weighting preserves both overall similarity and path-specific relevance"
          }
        },
        {
          "lesson": "Tutorial content pattern optimization for token efficiency",
          "context": "Implementing MCP tool tutorials with structured content patterns for optimal context usage",
          "details": "4-line structure (purpose, mechanism, performance, best practice) works well for tutorial content, keeping descriptions under 300 characters for optimal token usage. Use active voice and action-oriented language for maximum clarity. This structured approach provides comprehensive guidance while maintaining context efficiency",
          "impact": "Enables rich tutorial content without significant token overhead, improving user experience while maintaining performance",
          "dateLearned": "2025-08-10",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Direct modification approach simplifies tutorial implementation",
          "context": "Adding tutorial content to MCP tools without complex infrastructure changes",
          "details": "Direct modification of app.py is simpler than building complex tutorial infrastructure. Inline content eliminates file I/O overhead and following existing patterns (like start_pre_ingestion) ensures consistency with established code patterns. This pragmatic approach enables quick feature delivery",
          "impact": "Reduces development complexity while maintaining code consistency, enables faster feature implementation",
          "dateLearned": "2025-08-10",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        },
        {
          "lesson": "Tutorial validation success metrics and testing patterns",
          "context": "Ensuring tutorial content meets requirements and integrates properly with existing systems",
          "details": "All tutorials validated under 1000 character limit (actual range: 205-911 chars) with tutorial test (test_mcp_manifest_includes_tutorials) passing successfully. Manifest generation remains fast with embedded content approach. Pre-existing test failures were unrelated to tutorial changes (health check format, validation messages)",
          "impact": "Provides confidence in tutorial implementation quality while maintaining system performance and test suite integrity",
          "dateLearned": "2025-08-10",
          "relatedFiles": ["src/docsrs_mcp/app.py", "tests/test_app.py"]
        },
        {
          "lesson": "Character count validation script utility for content management",
          "context": "Implementing simple validation tools for ensuring tutorial content meets length requirements",
          "details": "Simple Python script can validate tutorial lengths effectively before deployment. Character count validation is important for maintaining performance requirements and ensuring consistent user experience across all tutorial content",
          "impact": "Prevents content length issues from reaching production, ensures consistent tutorial quality",
          "dateLearned": "2025-08-10",
          "relatedFiles": ["src/docsrs_mcp/app.py"]
        }
      ]
    },
    "performanceInsights": {
      "description": "Performance insights and optimizations discovered during implementation",
      "entries": [
        {
          "insight": "Enhanced fuzzy scoring adds minimal performance overhead",
          "context": "Composite scoring algorithm performance analysis during path resolution enhancement",
          "details": "Enhanced scoring with multiple RapidFuzz algorithms adds less than 5ms overhead while improving accuracy by approximately 25%. The composite approach (ratio + token_sort_ratio + partial_ratio with path bonuses) maintains sub-500ms response time requirements even with larger path datasets",
          "impact": "Enables significantly better fuzzy matching results without meaningful performance degradation",
          "dateMeasured": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/fuzzy_resolver.py"],
          "metrics": {
            "overheadAdded": "<5ms per fuzzy search operation",
            "accuracyGain": "~25% improvement over single algorithm",
            "responseTimeImpact": "Maintains sub-500ms requirement",
            "scalability": "Performance remains consistent with larger path datasets"
          }
        },
        {
          "insight": "Path caching with 5-minute TTL crucial for fuzzy search performance",
          "context": "Caching strategy optimization for repeated fuzzy path lookups",
          "details": "Caching resolved paths with 5-minute TTL provides ~90% cache hit rate for common path lookups, dramatically reducing database queries. Single database query pattern must be maintained to avoid N+1 query problems when building path datasets for fuzzy matching. TTL balances freshness with performance for path resolution scenarios",
          "impact": "Prevents repeated expensive database operations while maintaining reasonable data freshness for path resolution",
          "dateMeasured": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/fuzzy_resolver.py"],
          "metrics": {
            "cacheHitRate": "~90% for common path patterns",
            "ttlStrategy": "5-minute TTL balances freshness and performance",
            "queryReduction": "Single database query pattern prevents N+1 problems",
            "memoryFootprint": "Minimal memory impact with per-crate cache isolation"
          }
        }
      ]
    },
    "cicdBestPractices": {
      "description": "Best practices for CI/CD pipeline implementation and deployment",
      "entries": [
        {
          "practice": "Consistent UV usage across platforms",
          "description": "Always use 'uv run' pattern instead of direct executable calls to ensure Windows compatibility",
          "rationale": "Direct executable calls can fail on Windows due to path resolution issues, while 'uv run' provides consistent cross-platform behavior",
          "implementation": "Replace direct calls like 'docsrs-mcp' with 'uv run docsrs-mcp' in all CI workflows",
          "dateAdded": "2025-08-08"
        },
        {
          "practice": "Proper PyPI authentication",
          "description": "Use UV_PUBLISH_TOKEN environment variable for PyPI publishing authentication",
          "rationale": "UV_PUBLISH_TOKEN is the correct environment variable for PyPI authentication, not UV_PUBLISH_PASSWORD",
          "implementation": "Set UV_PUBLISH_TOKEN in CI secrets and use in publishing workflows",
          "dateAdded": "2025-08-08"
        },
        {
          "practice": "Background process management in CI",
          "description": "Use nohup with PID capture for testing background servers in CI environments",
          "rationale": "Prevents CI runners from hanging on background processes and enables proper cleanup",
          "implementation": "Pattern: 'SERVER_PID=$(nohup uv run server > server.log 2>&1 & echo $!)' followed by 'kill $SERVER_PID'",
          "dateAdded": "2025-08-08"
        },
        {
          "practice": "UV version consistency",
          "description": "Pin UV versions across all CI jobs to prevent cache deserialization errors",
          "rationale": "Different UV versions can cause cache corruption and build failures due to incompatible cache formats",
          "implementation": "Use specific UV version in CI workflows and clear cache when upgrading versions",
          "dateAdded": "2025-08-08"
        },
        {
          "practice": "PyPI-compatible builds",
          "description": "Use 'uv build --no-sources' for PyPI publishing to ensure package compatibility",
          "rationale": "Including source files can cause PyPI build failures and package incompatibility issues",
          "implementation": "Add --no-sources flag to build commands in publishing workflows",
          "dateAdded": "2025-08-08"
        },
        {
          "practice": "Runner-specific cache strategies",
          "description": "Implement different cache strategies for GitHub-hosted vs self-hosted runners",
          "rationale": "Self-hosted runners have persistent storage and different performance characteristics than GitHub-hosted runners",
          "implementation": "Use local disk cache for self-hosted runners, GitHub Actions cache for hosted runners",
          "dateAdded": "2025-08-08"
        }
      ]
    },
    "bestPractices": {
      "description": "Recommended practices and patterns for development",
      "implementation_patterns": [
        {
          "pattern": "Embeddings warmup",
          "implementation": "Comprehensive dual-mode warmup with representative samples",
          "description": "Eliminate cold-start latency through proactive model warming with fire-and-forget pattern",
          "details": {
            "samples": "Use 3-5 representative text samples (short, medium, long) for thorough warmup",
            "execution": "Fire-and-forget with asyncio.create_task() to avoid blocking startup",
            "tracking": "Global status tracking for health endpoint integration",
            "dualMode": "REST mode: startup_event + asyncio, MCP mode: threading + separate event loop"
          }
        },
        {
          "pattern": "Export endpoints",
          "implementation": "Use existing MCP tool endpoint patterns from app.py",
          "description": "Leverage FastMCP integration patterns for consistent API design"
        },
        {
          "pattern": "Batch operations",
          "implementation": "Leverage existing DB_BATCH_SIZE=999 pattern",
          "description": "Use consistent batch sizes across all database operations"
        },
        {
          "pattern": "Error messages",
          "implementation": "Extend validation.py with contextual examples",
          "description": "Include valid ranges and examples in all error messages"
        },
        {
          "pattern": "Version diff",
          "implementation": "Create new table following embeddings table pattern",
          "description": "Use consistent table schema patterns for new features"
        }
      ],
      "entries": [
        {
          "practice": "Dedicated embeddings for code examples",
          "description": "Separate example embeddings from document embeddings for better semantic search precision",
          "implementation": "Use dedicated tables (example_embeddings, vec_example_embeddings) with content hashing for deduplication. Format examples with context for better embedding quality.",
          "benefits": ["More precise example search", "Reduced storage through deduplication", "Better search performance with dedicated indexes"],
          "caveats": ["First search is slower due to model loading", "Requires additional database storage"],
          "dateAdded": "2025-08-07"
        },
        {
          "practice": "Embedding warmup implementation patterns",
          "description": "Best practices for eliminating cold-start latency in embedding-based applications",
          "implementation": {
            "representativeSamples": "Use 3-5 text samples of varying lengths to thoroughly warm up the model: short (~10 chars), medium (~100 chars), long (~500+ chars)",
            "fireAndForgetPattern": "Use asyncio.create_task() for non-blocking execution that doesn't delay server startup",
            "globalStatusTracking": "Maintain warmup status flags for health endpoint integration and monitoring",
            "dualModeSupport": {
              "restMode": "Use FastAPI startup_event with asyncio for async context",
              "mcpMode": "Use threading.Thread with separate event loop for STDIO compatibility"
            },
            "sharedWarmupFunction": "Both modes call the same async warmup function to eliminate code duplication"
          },
          "benefits": [
            "Eliminates 1.4s cold-start latency on first embedding request",
            "Non-blocking server startup maintains responsiveness",
            "Health endpoints can report warmup status for monitoring",
            "Consistent performance across all embedding operations"
          ],
          "codePattern": {
            "restMode": "@app.on_event('startup')\nasync def startup_event():\n    asyncio.create_task(warmup_embeddings())",
            "mcpMode": "def start_warmup_thread():\n    def warmup_worker():\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        loop.run_until_complete(warmup_embeddings())\n    threading.Thread(target=warmup_worker, daemon=True).start()",
            "sharedFunction": "async def warmup_embeddings():\n    samples = ['short', 'medium length sample', 'comprehensive warmup text']\n    await embed_model.embed(samples)\n    global warmup_complete\n    warmup_complete = True"
          },
          "considerations": [
            "Use daemon threads in MCP mode to avoid blocking process termination",
            "Include warmup status in health endpoints for monitoring",
            "Representative samples should reflect actual usage patterns",
            "Fire-and-forget pattern prevents startup delays"
          ],
          "dateAdded": "2025-08-09"
        }
      ]
    },
    "cache_management": {
      "description": "Cache management patterns and solutions",
      "entries": [
        {
          "issue": "Circular import between ingest.py and popular_crates.py",
          "solution": "Use lazy import inside function to avoid circular dependency. Import get_popular_manager inside evict_cache_if_needed() instead of at module level.",
          "lesson": "When modules have bidirectional dependencies, use lazy imports inside functions rather than module-level imports to break the cycle.",
          "context": "Priority-aware cache eviction feature implementation",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["src/docsrs_mcp/ingest.py", "src/docsrs_mcp/popular_crates.py"]
        },
        {
          "issue": "Cache invalidation strategy for re-export path resolution",
          "solution": "Implement 5-minute TTL with cache key per crate for balancing cache freshness with performance. Use simple dictionary cache with timestamp tracking for path resolution caching.",
          "lesson": "Slight staleness (5 minutes) is acceptable for path resolution as re-exports don't change frequently, but cache must be invalidated per crate to avoid cross-crate contamination.",
          "context": "Re-export auto-discovery implementation requiring fast path lookups with reasonable freshness",
          "dateEncountered": "2025-08-09",
          "relatedFiles": ["src/docsrs_mcp/app.py", "src/docsrs_mcp/ingest.py"],
          "performanceImpact": {
            "cacheTTL": "5 minutes",
            "keyStrategy": "Per-crate isolation",
            "tradeoff": "Slight staleness acceptable for 90% cache hit rate",
            "fallbackBehavior": "Direct database lookup on cache miss"
          }
        }
      ]
    },
    "testing": {
      "description": "Testing patterns and solutions for complex scenarios",
      "entries": [
        {
          "issue": "Mocking imported functions that are lazily imported",
          "solution": "When a function is imported inside another function (lazy import), patch it at its original module location, not where it's imported. Example: patch 'module.function' not 'importing_module.function'",
          "lesson": "Always patch at the source module, not at the import location, especially for lazy imports.",
          "context": "Testing priority-aware cache eviction with lazy imports",
          "dateEncountered": "2025-08-08",
          "relatedFiles": ["tests/test_ingest.py"]
        }
      ]
    }
  },
  "errorTemplate": {
    "error": "Error message or description",
    "context": "When/where the error occurred",
    "solution": "How the error was resolved",
    "prevention": "How to avoid this error in the future",
    "dateEncountered": "YYYY-MM-DD",
    "relatedFiles": ["file1.py", "file2.py"]
  },
  "knownLimitations": {
    "sqliteVss": {
      "issue": "1GB index size limit",
      "impact": "Cannot index very large crates",
      "workaround": "Implement chunking or use alternative vector DB for large crates"
    },
    "rustdocJson": {
      "issue": "Not all crates have rustdoc JSON available",
      "impact": "Cannot provide documentation for older crates",
      "workaround": "Return graceful error message without attempting local build"
    },
    "windowsCompatibility": {
      "issue": "uvloop not compatible with Windows",
      "impact": "Performance degradation on Windows",
      "workaround": "Fallback to standard asyncio event loop on Windows"
    }
  },
  "debuggingTips": {
    "vectorSearch": [
      "Check embedding dimensions match (384 for BAAI/bge-small-en-v1.5)",
      "Verify FAISS index is properly initialized with vss_index!",
      "Monitor memory usage during batch operations",
      "Use MATCH operator instead of vec_distance() for queries",
      "Always include 'AND k = ?' parameter in vector search queries"
    ],
    "ingestion": [
      "Check asyncio.Lock is properly acquired/released",
      "Verify URL construction for docs.rs API",
      "Monitor decompression memory usage for large files",
      "Use await with all aiosqlite database operations",
      "Ensure ijson receives bytes input using io.BytesIO(content.encode())",
      "Set reasonable limits: MAX_DOWNLOAD_SIZE=100MB, MAX_DECOMPRESSED_SIZE=100MB",
      "Use DOWNLOAD_CHUNK_SIZE=8KB for streaming downloads",
      "Clean up test databases between runs to avoid state pollution",
      "Use 'SELECT last_insert_rowid()' after executemany() to get last inserted ID",
      "Calculate batch sizes as 999 // params_per_row to respect SQLite parameter limits",
      "Pre-serialize complex data before batching to avoid repeated serialization overhead",
      "Test batch logic with datasets >2x batch size to verify multiple batch handling",
      "Clear cache directory before testing enhanced parsing to ensure fresh database creation",
      "Use exact key matching in type dictionaries to avoid false positive substring matches",
      "Implement fallback mechanisms for optional data structures in rustdoc JSON",
      "Use distinct variable names in nested loops to prevent accidental overwrites",
      "Use docs.rs as primary source for stdlib docs instead of local rust-docs-json component",
      "Implement stdlib crate detection using set lookup for O(1) performance",
      "Configure AsyncMock context manager methods (__aenter__, __aexit__) when testing async sessions",
      "Always provide fallback version when external API calls (like Rust version fetch) fail",
      "Provide clear error messages with helpful instructions when stdlib download fails",
      "Use async generators for streaming data processing, sync generators for embedding batches",
      "Implement wrapper functions to maintain backwards compatibility between generators and lists",
      "Use MemoryMonitor context manager to track operation-level memory usage and cleanup",
      "Monitor both system-wide (psutil.virtual_memory().percent) and process-specific (process.memory_info().rss) memory usage",
      "Trigger garbage collection after processing 100+ items to maintain optimal memory usage",
      "Pre-serialize vectors and complex data structures before batch processing",
      "Clear buffers and trigger GC between batches in streaming operations",
      "Implement per-batch transactions for database resilience in streaming pipelines",
      "Log memory status at key processing points for debugging streaming operations",
      "Use integration tests to validate streaming pipeline error recovery",
      "Always load sqlite-vec extension before testing vector operations to prevent 'no such function' errors",
      "Handle both old list format and new JSON format for backward compatibility during data format changes",
      "Extract crate version from database filename when schema doesn't include version column",
      "Always import all required typing components (including Optional) when adding type hints",
      "Load sqlite-vec extension with proper enable/disable pattern: enable_load_extension(True) -> load_extension() -> enable_load_extension(False)",
      "Create partial indexes for common filter patterns to dramatically improve query performance",
      "Use progressive filtering only for small result sets (<10K items) - prefer database-level filtering for large datasets",
      "Use version-specific docs.rs URLs (/crate/{name}/{version}/json) to avoid redirect overhead",
      "Check magic bytes (0x28, 0xb5, 0x2f, 0xfd) for zstd compression detection instead of relying on headers",
      "Store full path_info dictionaries instead of just path strings when building module hierarchies",
      "Extract item kind from inner field as single-key dictionary in rustdoc JSON parsing",
      "Module names are derived from last element of path arrays, not separate name fields",
      "Preserve full data structures when building hierarchies to maintain context information",
      "FIXED: Always check if examples_data is string before iteration to prevent character fragmentation - apply type guard: if isinstance(examples_data, str): examples_data = [examples_data]",
      "Impl blocks in rustdoc JSON have empty names - extract from inner.trait and inner.for fields instead",
      "Use composite naming pattern 'TraitName_for_TypeName' for trait implementations to create meaningful identifiers",
      "Check inner.trait for null to distinguish between trait implementations and inherent implementations",
      "Existing streaming parser architecture accommodates new item types without structural changes",
      "No database schema changes needed for impl blocks - leverage existing item_type field patterns",
      "CRITICAL: When mocking Path objects in tests, use MagicMock(spec=Path) with exists() method configured",
      "CRITICAL: sqlite-vec MATCH operator requires explicit k parameter - never omit k constraint in vector queries",
      "See-also suggestions: exclude original search results using path exclusion to avoid duplicates",
      "sqlite-vec similarity scoring: use similarity = 1.0 - distance for proper ranking (higher = more similar)",
      "UI optimization: add suggestions only to first search result to prevent interface redundancy",
      "Graceful degradation: return empty suggestions array on any exception to maintain core functionality",
      "Test mock patterns: ingest_crate must return Path object with exists() method, not string",
      "Suggestion deduplication: use set comprehension for O(1) path exclusion performance",
      "Error handling: log suggestion generation failures but never break main search functionality",
      "Search filtering: Review restrictive crate_pattern and module_pattern filters to ensure function-level items are included",
      "sqlite-vec constraints: Always use explicit 'k = N' in WHERE clauses, not just LIMIT for vector queries",
      "PATH_ALIASES expansion: Add common Rust patterns like tokio::spawn -> tokio::task::spawn for better UX",
      "Fuzzy matching optimization: Consider Nucleo library for 6x performance improvement over RapidFuzz",
      "Hybrid search strategy: Combine vector similarity (60%) with BM25 keyword search (40%) for balanced results",
      "Debug mode implementation: Add debug=true parameter for detailed query scoring and performance analysis",
      "Re-export detection in rustdoc JSON: Look for items with 'kind' containing 'import' or 'use' keywords, extract alias from item path and target from inner structure",
      "Re-export path resolution: Extract alias name from item path array (last element) and resolve target path from inner.id or inner.path fields",
      "Re-export auto-discovery: Use streaming JSON parser to identify re-export patterns without loading entire JSON into memory",
      "CRITICAL: FastEmbed global singleton causes memory leaks - configure ONNX with sess_options.enable_cpu_mem_arena = False",
      "Memory management: Implement explicit cleanup with del embedding_session and gc.collect() after processing",
      "Model selection: Consider lighter models like all-MiniLM-L6-v2 to reduce memory footprint",
      "Database constraints: Add UNIQUE indexes on item_path to prevent duplicate entries during re-ingestion"
    ],
    "rateLimiting": [
      "MUST include Request parameter in endpoint function signatures or rate limiting won't work",
      "Middleware order matters - last added middleware is outermost in execution order",
      "Memory backend doesn't share state between workers - use Redis for production/multi-worker scenarios",
      "Use limiter.limit() decorator on each endpoint that needs rate limiting for granular control",
      "Set app.state.limiter after app initialization for proper middleware integration",
      "Create dedicated middleware.py for clean separation of rate limiting logic",
      "Add custom exception handler for RateLimitExceeded to provide consistent error responses",
      "Test rate limiting with concurrent requests using asyncio.gather to verify proper enforcement",
      "Verify both successful (200) and rate-limited (429) responses in tests",
      "Check that health/monitoring endpoints remain unprotected from rate limiting",
      "Test rate limit headers (X-RateLimit-*) are properly included in responses",
      "Ensure Redis is running for distributed limiting in production environments",
      "Check IP extraction middleware ordering for proper client identification",
      "Verify rate limit headers in responses for client feedback"
    ],
    "serverManagement": [
      "Start MCP server (default): nohup uv run docsrs-mcp > server.log 2>&1 & echo $!",
      "Start REST server: nohup uv run docsrs-mcp --mode rest > server.log 2>&1 & echo $!",
      "Alternative MCP: nohup uvx docsrs-mcp > server.log 2>&1 & echo $!",
      "Alternative REST: nohup uvx docsrs-mcp --mode rest > server.log 2>&1 & echo $!",
      "Kill server: kill <PID>",
      "Test REST endpoints: curl -s http://localhost:8000/endpoint | jq . (server runs on port 8000, not 8080)",
      "Test MCP manifest: Use --mode rest to test MCP manifest endpoints at localhost:8000",
      "Check embeddings: sqlite3 cache/crate/version.db \"SELECT * FROM embeddings;\""
    ],
    "cicdQuickReference": [
      "Windows compatibility: Use 'uv run' instead of direct executable calls in CI workflows",
      "PyPI publishing: Set UV_PUBLISH_TOKEN (not UV_PUBLISH_PASSWORD) in CI secrets",
      "Server testing in CI: SERVER_PID=$(nohup uv run server > server.log 2>&1 & echo $!); kill $SERVER_PID",
      "UV version consistency: Pin UV version in workflows to prevent cache deserialization errors",
      "PyPI builds: Use 'uv build --no-sources' for PyPI-compatible package builds",
      "Runner caching: Use local disk cache for self-hosted, GitHub Actions cache for hosted runners",
      "Cache management: Clear UV cache when upgrading UV versions to prevent corruption"
    ],
    "criticalBugs": [
      "RESOLVED: searchExamples character fragmentation bug - FIXED in ingest.py:758-762 and app.py:614-620",
      "Previous issue: String iteration bug caused characters instead of code blocks to be returned",
      "Root cause was: isinstance(examples_data, str) not checked before iteration, causing ['[', '{', '\"'] instead of complete blocks",
      "Solution applied: Added type guard pattern: if isinstance(examples_data, str): examples_data = [examples_data]",
      "Testing: Verified fix with live MCP calls to serde crate - now returns complete code blocks",
      "Status: RESOLVED 2025-08-08 - All example functionality now working correctly"
    ],
    "mcpServer": [
      "Run MCP mode (default): uvx docsrs-mcp",
      "Test MCP server: nohup uvx docsrs-mcp > mcp.log 2>&1 & echo $!",
      "Debug with REST mode: uvx docsrs-mcp --mode rest (easier debugging)",
      "Check MCP logs: tail -f mcp.log (logs go to stderr in MCP mode)",
      "Claude Desktop config: Use simplified args: [\"docsrs-mcp\"]",
      "Kill MCP server: kill <PID> (use captured PID from nohup)",
      "Verify MCP protocol: Check that STDIO is clean, no stdout pollution",
      "FastMCP conversion: Use FastMCP.from_fastapi() for automatic REST-to-MCP conversion",
      "Parameter type issues: MCP clients may send numeric parameters as strings - use Pydantic field validators with mode='before' for type coercion",
      "Double validation conflicts: When MCP manifest schema is too restrictive, it prevents Pydantic field validators from running - use anyOf schema patterns for flexible type acceptance",
      "Schema flexibility: Use anyOf: [{'type': 'integer'}, {'type': 'string'}] in MCP manifests for parameters that may arrive as strings from different clients",
      "Decorator ordering: Always use @field_validator BEFORE @classmethod decorator, not after - decorator execution is bottom-up",
      "Validation patterns: Check None first, then correct type, then string conversion with try/catch and helpful error messages",
      "Error types: Expect ValidationError for built-in Pydantic constraints, ValueError for custom field_validator methods",
      "Float conversion: Use 'could not convert' in error checks for float string conversion, 'invalid literal' for int conversion",
      "Testing approach: Test both native type validation (Pydantic constraints) and string validation (custom validators) paths",
      "Comprehensive validation: Handle integer-to-float conversion for float fields when clients send integer strings",
      "MCP Double Validation: Use anyOf schema patterns to handle JSON Schema + Pydantic validation conflicts",
      "Decorator ordering: @field_validator must come BEFORE @classmethod for proper wrapping",
      "None preservation: Don't convert None to defaults in validators - handle at application layer",
      "Error messages: Include field name, examples, and received value (truncated to 100 chars) for helpful feedback",
      "Compatibility testing: Test with both native types and string representations using model_validate()",
      "CRITICAL: All parameters with field validators in models.py need corresponding anyOf patterns in app.py's get_mcp_manifest() function",
      "anyOf pattern for numeric: {'anyOf': [{'type': 'integer'}, {'type': 'string'}]} in MCP manifest",
      "anyOf pattern for boolean: {'anyOf': [{'type': 'boolean'}, {'type': 'string'}]} in MCP manifest",
      "anyOf pattern for optional strings: {'anyOf': [{'type': 'string'}, {'type': 'null'}]} in MCP manifest",
      "Test MCP parameter validation with curl: both '{\"k\": \"5\"}' (string) and '{\"k\": 5}' (integer) should work",
      "Validation flow order: MCP manifest anyOf â†’ FastMCP JSON Schema â†’ Pydantic field validators â†’ Type coercion",
      "CRITICAL BUG: start_pre_ingestion is the ONLY tool without anyOf patterns - add consistent anyOf patterns to all tools with parameters",
      "Schema consistency: All MCP tools must have matching anyOf patterns between manifest schema and Pydantic validators",
      "Memory management: FastEmbed global singleton causes memory leaks - implement explicit ONNX Runtime cleanup"
    ],
    "queryPreprocessing": [
      "Check for whitespace-only queries before stripping to provide specific error messages",
      "Use Unicode NFKC normalization for consistent search text while preserving technical characters",
      "Technical symbols (::, <>, #) are preserved during NFKC normalization",
      "NFKC handles ligatures (ï¬€ â†’ ff), fractions (Â½ â†’ 1â„2), and compatibility characters",
      "Include specific examples in Pydantic validator error messages for better user experience",
      "Test normalization with various Unicode inputs including mathematical symbols and ligatures",
      "Verify that programming syntax elements remain intact after normalization"
    ],
    "moduleMetadataSearch": [
      "Check for trailing/leading '::' in module paths before stripping whitespace to catch malformed patterns",
      "Use db_path.parent.name to extract crate name from cache/{crate}/{version}.db file structure",
      "Construct module search patterns as: f'{crate_name}::{module_path}::%' for SQL LIKE queries",
      "Always add new filter parameters to _make_key(), get(), and set() methods for cache consistency",
      "Maintain parameter ordering consistency across cache methods to ensure proper cache hits",
      "Test FastAPI validation errors by checking both 422 status code and response.json()['detail'] array",
      "Use nohup with PID capture for background server testing: 'nohup uv run uvicorn docsrs_mcp.app:app > server.log 2>&1 & echo $!'",
      "Server testing: Always use nohup when starting servers in background, use kill PID to stop servers cleanly, check logs with tail -f for debugging"
    ],
    "fuzzyPathResolution": [
      "SearchCache is designed for embedding-based searches, not simple string caching - use basic dictionary cache with TTL for simple path caching needs",
      "FastAPI HTTPException requires string detail, not dictionary - include suggestions in error message text to avoid 500 errors",
      "TestClient works synchronously - avoid mixing async fixtures, mock at appropriate level and use sync test functions",
      "RapidFuzz works best as fallback-only approach to preserve exact match performance while adding fuzzy capabilities",
      "Cache paths per crate to avoid repeated database queries during fuzzy search operations",
      "Use fallback pattern: attempt exact match first, then fuzzy search if no results found",
      "Implement simple TTL caching with dictionary for path lookups rather than complex caching frameworks",
      "RapidFuzz v3.0+ requires explicit processor=default_process - default preprocessing removed",
      "Use unicodedata.normalize('NFC') for Unicode consistency before fuzzy matching",
      "Composite scoring (ratio + token_sort_ratio + partial_ratio) improves accuracy ~25% over single algorithms",
      "Path component bonuses help prioritize exact final component matches in composite scoring",
      "resolve_path_alias is async function - tests must use @pytest.mark.asyncio and await calls",
      "5-minute TTL caching provides ~90% hit rate while maintaining reasonable data freshness"
    ],
    "pathAliasResolution": [
      "Implement PATH_ALIASES dictionary with O(1) lookup for common path shortcuts before database queries",
      "Include mappings for frequently used patterns: serde::Deserialize â†’ serde::de::Deserialize, tokio::spawn â†’ tokio::task::spawn",
      "Add std library aliases like Result â†’ std::result::Result, Option â†’ std::option::Option for better UX",
      "Place resolve_path_alias() function before database lookup to minimize performance impact (<1ms overhead)",
      "Test both unit tests for the alias function and integration tests for API endpoints",
      "Use --mode rest flag for easier HTTP/curl testing during development instead of STDIO mode",
      "Update PATH_ALIASES based on user feedback and common usage patterns to improve coverage",
      "Maintain sub-500ms response time requirement even with alias resolution overhead"
    ],
    "rustdocJsonParsing": [
      "Impl blocks have empty name fields - extract meaningful names from inner.trait and inner.for fields",
      "Use composite naming pattern: 'TraitName_for_TypeName' for trait implementations",
      "Check inner.trait field for null to identify inherent vs trait implementations",
      "Generate searchable identifiers from inner.for field when inner.trait is null (inherent impls)",
      "Existing streaming parser accommodates new item types without architecture changes",
      "No database schema modifications needed - use existing item_type field for impl blocks",
      "Complex type information may be nested in both trait and for fields - parse carefully",
      "Empty name fields are normal for impl blocks - don't treat as parsing errors"
    ],
    "backgroundScheduler": [
      "Use set() to maintain strong references: self.background_tasks = set() with add/discard callbacks",
      "Add jitter to prevent coordination: base_interval + random.uniform(-jitter_range, jitter_range)",
      "Check memory before intensive operations: psutil.virtual_memory().percent < 80",
      "Use environment variables for configuration: SCHEDULER_ENABLED, intervals, thresholds",
      "Test with asyncio.wait_for() and short timeouts - background tasks will timeout (expected)",
      "Test both enabled and disabled states for backward compatibility",
      "Background task cleanup: task.add_done_callback(lambda t: self.background_tasks.discard(t))",
      "Default jitter: Â±10% variance provides good load distribution without affecting accuracy",
      "Memory threshold: 80% leaves headroom for processing spikes, skip operations when exceeded",
      "Configuration pattern: Default enabled for UX, clear disable mechanism for resource constraints"
    ]
  },
  "performanceMetrics": {
    "targets": {
      "warmSearchLatency": "< 500ms P95",
      "coldIngestTime": "< 3s for 10MB crates",
      "memoryUsage": "< 1GB RSS (NOTE: FastEmbed memory leak can cause 1.5GB+ growth without proper ONNX configuration)",
      "cacheSize": "< 2GB total"
    },
    "optimizationStrategies": {
      "embedding": "Batch size 32 (EMBEDDING_BATCH_SIZE) for optimal CPU utilization",
      "database": "Insert batches respecting SQLite's 999 parameter limit, pre-serialize data",
      "caching": "LRU eviction when > 2GB",
      "asyncio": "Use asyncio.gather for concurrent operations",
      "batchProcessing": "Maintains constant memory usage regardless of dataset size",
      "memoryManagement": "Use MemoryMonitor context manager, trigger GC after 100+ items, pre-serialize before batching",
      "streaming": "Async generators for data processing, wrapper functions for backwards compatibility",
      "errorRecovery": "Per-batch transactions, memory status logging, streaming-aware error handling",
      "databaseOptimization": "Create partial indexes for common filter patterns, use progressive filtering only for small result sets (<10K items)",
      "extensionManagement": "Always load sqlite-vec extension before vector operations, especially in testing environments",
      "codeExampleExtraction": "Language detection adds minimal overhead (~200ms warm queries), deduplication by hash prevents duplicates efficiently, backward compatibility essential for format changes",
      "fuzzyPathResolution": "Use fallback-only approach with RapidFuzz for minimal performance impact, cache paths per crate, implement simple TTL dictionary cache instead of complex caching frameworks. Composite scoring adds <5ms overhead while improving accuracy ~25%. 5-minute TTL provides ~90% cache hit rate",
      "pathAliasResolution": "Static PATH_ALIASES dictionary with O(1) lookup adds <1ms overhead, maintains sub-500ms response time requirement while significantly improving user experience",
      "implBlockParsing": "Impl block parsing uses existing streaming architecture without performance impact, composite naming creates searchable identifiers efficiently, no schema changes required for trait implementation search",
      "databaseBatchInsertion": "Use executemany() with IGNORE clause for duplicate handling achieves 70% reduction in insertion time compared to individual INSERT statements, especially beneficial for large re-export datasets",
      "batchInsertOptimization": "Pre-process re-export data into tuples before batching to avoid repeated serialization overhead during executemany() operations",
      "memoryLeakPrevention": "Configure FastEmbed ONNX Runtime with sess_options.enable_cpu_mem_arena = False to prevent memory accumulation, implement explicit model lifecycle management"
    }
  },
  "codeQuality": {
    "ruff": {
      "description": "Exclusive linting and formatting tool for this project",
      "replacesTools": ["black", "flake8", "isort", "pylint", "pycodestyle", "autopep8"],
      "commonCommands": {
        "lint": "uv run ruff check .",
        "lintFix": "uv run ruff check --fix .",
        "format": "uv run ruff format .",
        "formatCheck": "uv run ruff format --check .",
        "showDiff": "uv run ruff check --diff ."
      },
      "configurationTips": {
        "location": "pyproject.toml under [tool.ruff]",
        "basicSetup": {
          "lineLength": 88,
          "target-version": "py310",
          "selectRules": "Most rules enabled by default",
          "ignorePatterns": "Use 'exclude' for directories"
        },
        "commonRules": {
          "E": "pycodestyle errors",
          "W": "pycodestyle warnings", 
          "F": "Pyflakes",
          "I": "isort import sorting",
          "N": "pep8-naming",
          "UP": "pyupgrade"
        }
      },
      "integrationTips": [
        "Add ruff extension to VS Code for real-time feedback",
        "Configure pre-commit hook: 'uv run ruff check --fix && uv run ruff format'",
        "CI should run both 'ruff check' and 'ruff format --check'",
        "Use --fix flag in development, never in CI",
        "Ruff auto-fixes are safe and preserve code semantics",
        "Ruff formatting automatically fixes whitespace issues in docstrings"
      ],
      "ignorableWarnings": [
        "PLR0912 (too-many-branches): Can be ignored for documentation processing tasks",
        "PLR0915 (too-many-statements): Can be ignored for documentation processing tasks"
      ],
      "performanceNotes": [
        "10-100x faster than traditional Python tools",
        "Processes entire codebase in milliseconds",
        "No need for separate tools or complex configuration"
      ]
    }
  },
  "securityConsiderations": {
    "security_vulnerabilities": [
      "CVE-2025-49596: Critical RCE in MCP Inspector (CVSS 9.4) - upgrade to v0.14.1+",
      "Command injection possible through unsanitized file paths - use parameterized queries",
      "Path traversal attacks via ../ sequences - implement allow-lists for directories",
      "STDIO corruption from stdout writes - use stderr for all logging",
      "Prompt injection via tool descriptions - sanitize all tool metadata"
    ],
    "compatibility_issues": [
      "Windows path handling requires double backslashes in JSON config",
      "Python ModuleNotFoundError - ensure consistent virtual environments",
      "MCP clients reject array type parameters - use anyOf patterns",
      "Platform-specific Python path resolution - use absolute paths",
      "JSON Schema validation occurs before Pydantic - design schemas accordingly"
    ],
    "placeholders": {
      "securityEmail": {
        "issue": "Security contact placeholder (security@example.com) should be updated",
        "impact": "Users cannot report security issues properly",
        "action": "Replace security@example.com with actual security contact email",
        "relatedFiles": ["src/docsrs_mcp/app.py"]
      }
    }
  }
}